// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: token_split.sql

package coredb

import (
	"context"
	"time"
)

const upsertAssets = `-- name: UpsertAssets :many
insert into assets
( id
, version
, owner_address
, token_address
, balance
, block_number
, created_at
, last_updated) (select id
                      , version
                      , owner_address
                      , token_address
                      , balance
                      , block_number
                      , created_at
                      , last_updated
                 from (select unnest($1::varchar[])               as id
                            , unnest($2::int[])              as version
                            , unnest($3::varchar[])    as owner_address
                            , unnest($4::varchar[])    as token_address
                            , unnest($5::varchar[])          as balance
                            , unnest($6::bigint[])      as block_number
                            , unnest($7::timestamptz[])   as created_at
                            , unnest($8::timestamptz[]) as last_updated) bulk_upsert)
on conflict (token_address, owner_address)
    do update set version       = excluded.version
                , owner_address = excluded.owner_address
                , token_address = excluded.token_address
                , balance       = excluded.balance
                , block_number  = excluded.block_number
                , last_updated  = excluded.last_updated
returning id, version, last_updated, created_at, chain, token_address, owner_address, balance, block_number
`

type UpsertAssetsParams struct {
	ID           []string    `db:"id" json:"id"`
	Version      []int32     `db:"version" json:"version"`
	OwnerAddress []string    `db:"owner_address" json:"owner_address"`
	TokenAddress []string    `db:"token_address" json:"token_address"`
	Balance      []string    `db:"balance" json:"balance"`
	BlockNumber  []int64     `db:"block_number" json:"block_number"`
	CreatedAt    []time.Time `db:"created_at" json:"created_at"`
	LastUpdated  []time.Time `db:"last_updated" json:"last_updated"`
}

func (q *Queries) UpsertAssets(ctx context.Context, arg UpsertAssetsParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, upsertAssets,
		arg.ID,
		arg.Version,
		arg.OwnerAddress,
		arg.TokenAddress,
		arg.Balance,
		arg.BlockNumber,
		arg.CreatedAt,
		arg.LastUpdated,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Chain,
			&i.TokenAddress,
			&i.OwnerAddress,
			&i.Balance,
			&i.BlockNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
