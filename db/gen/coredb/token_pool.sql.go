// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: token_pool.sql

package coredb

import (
	"context"

	"github.com/SplitFi/go-splitfi/service/persist"
)

const upsertTokenMetadatas = `-- name: UpsertTokenMetadatas :many
WITH token_metadatas_insert AS (
    INSERT INTO token_metadatas
        (
         id, created_at, last_updated, deleted, name, symbol, chain, logo, thumbnail, contract_address
            ) (SELECT UNNEST($1::varchar[])             AS id
                    , NOW()
                    , NOW()
                    , FALSE
                    , UNNEST($2::varchar[])             AS name
                    , UNNEST($3::varchar[])           AS symbol
                    , UNNEST($4::chain[])              AS chain
                    , UNNEST($5::varchar[])             AS logo
                    , UNNEST($6::varchar[])        AS thumbnail
                    , UNNEST($7::address[]) AS contract_address)
        ON CONFLICT (chain, contract_address) WHERE deleted = FALSE
            DO UPDATE SET
                last_updated = excluded.last_updated
                , name = COALESCE(NULLIF(excluded.name, ''), NULLIF(token_metadatas.name, ''))
                , symbol = COALESCE(NULLIF(excluded.symbol, ''), NULLIF(token_metadatas.symbol, ''))
                , logo = COALESCE(NULLIF(excluded.logo, ''), NULLIF(token_metadatas.logo, ''))
                , thumbnail = COALESCE(NULLIF(excluded.thumbnail, ''), NULLIF(token_metadatas.thumbnail, ''))
        RETURNING id, deleted, created_at, last_updated, symbol, name, logo, thumbnail, chain, contract_address)
SELECT token_metadatas.id, token_metadatas.deleted, token_metadatas.created_at, token_metadatas.last_updated, token_metadatas.symbol, token_metadatas.name, token_metadatas.logo, token_metadatas.thumbnail, token_metadatas.chain, token_metadatas.contract_address, (prior_state.id IS NULL)::bool is_new_metadata
FROM token_metadatas_insert token_metadatas
         LEFT JOIN token_metadatas prior_state ON token_metadatas.chain = prior_state.chain AND
                                                  token_metadatas.contract_address = prior_state.contract_address AND
                                                  NOT prior_state.deleted
`

type UpsertTokenMetadatasParams struct {
	Dbid            []string          `db:"dbid" json:"dbid"`
	Name            []string          `db:"name" json:"name"`
	Symbol          []string          `db:"symbol" json:"symbol"`
	Chain           []persist.Chain   `db:"chain" json:"chain"`
	Logo            []string          `db:"logo" json:"logo"`
	Thumbnail       []string          `db:"thumbnail" json:"thumbnail"`
	ContractAddress []persist.Address `db:"contract_address" json:"contract_address"`
}

type UpsertTokenMetadatasRow struct {
	TokenMetadata TokenMetadata `db:"tokenmetadata" json:"tokenmetadata"`
	IsNewMetadata bool          `db:"is_new_metadata" json:"is_new_metadata"`
}

// token_metadatas is the snapshot of the table prior to inserting. We can determine if a token is new by checking against this snapshot.
func (q *Queries) UpsertTokenMetadatas(ctx context.Context, arg UpsertTokenMetadatasParams) ([]UpsertTokenMetadatasRow, error) {
	rows, err := q.db.Query(ctx, upsertTokenMetadatas,
		arg.Dbid,
		arg.Name,
		arg.Symbol,
		arg.Chain,
		arg.Logo,
		arg.Thumbnail,
		arg.ContractAddress,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpsertTokenMetadatasRow
	for rows.Next() {
		var i UpsertTokenMetadatasRow
		if err := rows.Scan(
			&i.TokenMetadata.ID,
			&i.TokenMetadata.Deleted,
			&i.TokenMetadata.CreatedAt,
			&i.TokenMetadata.LastUpdated,
			&i.TokenMetadata.Symbol,
			&i.TokenMetadata.Name,
			&i.TokenMetadata.Logo,
			&i.TokenMetadata.Thumbnail,
			&i.TokenMetadata.Chain,
			&i.TokenMetadata.ContractAddress,
			&i.IsNewMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertTokens = `-- name: UpsertTokens :many
WITH tokens_insert AS (
    INSERT INTO tokens
        (
         id, deleted, version, created_at, last_updated, chain, token_address, owner_address,
         balance) (SELECT bulk_upsert.id
                        , FALSE
                        , bulk_upsert.version
                        , NOW()
                        , NOW()
                        , bulk_upsert.chain
                        , bulk_upsert.token_address
                        , bulk_upsert.owner_address
                        , bulk_upsert.balance
                   FROM (SELECT UNNEST($1::dbid[])             AS id
                              , UNNEST($2::int[])           AS version
                              , UNNEST($3::chain[])           AS chain
                              , UNNEST($4::address[]) AS token_address
                              , UNNEST($5::address[]) AS owner_address
                              , UNNEST($6::varchar[])       AS balance) bulk_upsert)
        ON CONFLICT (owner_address, token_address, chain) WHERE deleted = FALSE
            DO UPDATE SET
                balance = excluded.quantity
                , version = excluded.version
                , last_updated = excluded.last_updated RETURNING id, deleted, version, created_at, last_updated, chain, token_address, owner_address, balance)
SELECT tokens.id, tokens.deleted, tokens.version, tokens.created_at, tokens.last_updated, tokens.chain, tokens.token_address, tokens.owner_address, tokens.balance, token_metadatas.id, token_metadatas.deleted, token_metadatas.created_at, token_metadatas.last_updated, token_metadatas.symbol, token_metadatas.name, token_metadatas.logo, token_metadatas.thumbnail, token_metadatas.chain, token_metadatas.contract_address
FROM tokens_insert tokens
         JOIN token_metadatas
              ON tokens.token_address = token_metadatas.contract_address AND tokens.chain = token_metadatas.chain AND
                 NOT token_metadatas.deleted
         LEFT JOIN tokens prior_state ON tokens.owner_address = prior_state.owner_address AND
                                         tokens.token_address = prior_state.token_address AND
                                         tokens.chain = prior_state.chain AND
                                         NOT prior_state.deleted
WHERE prior_state.id IS NULL
`

type UpsertTokensParams struct {
	Dbid         []persist.DBID    `db:"dbid" json:"dbid"`
	Version      []int32           `db:"version" json:"version"`
	Chain        []persist.Chain   `db:"chain" json:"chain"`
	TokenAddress []persist.Address `db:"token_address" json:"token_address"`
	OwnerAddress []persist.Address `db:"owner_address" json:"owner_address"`
	Balance      []string          `db:"balance" json:"balance"`
}

type UpsertTokensRow struct {
	Token         Token         `db:"token" json:"token"`
	TokenMetadata TokenMetadata `db:"tokenmetadata" json:"tokenmetadata"`
}

// tokens is the snapshot of the table prior to inserting. We can determine if a token is new by checking against this snapshot.
func (q *Queries) UpsertTokens(ctx context.Context, arg UpsertTokensParams) ([]UpsertTokensRow, error) {
	rows, err := q.db.Query(ctx, upsertTokens,
		arg.Dbid,
		arg.Version,
		arg.Chain,
		arg.TokenAddress,
		arg.OwnerAddress,
		arg.Balance,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpsertTokensRow
	for rows.Next() {
		var i UpsertTokensRow
		if err := rows.Scan(
			&i.Token.ID,
			&i.Token.Deleted,
			&i.Token.Version,
			&i.Token.CreatedAt,
			&i.Token.LastUpdated,
			&i.Token.Chain,
			&i.Token.TokenAddress,
			&i.Token.OwnerAddress,
			&i.Token.Balance,
			&i.TokenMetadata.ID,
			&i.TokenMetadata.Deleted,
			&i.TokenMetadata.CreatedAt,
			&i.TokenMetadata.LastUpdated,
			&i.TokenMetadata.Symbol,
			&i.TokenMetadata.Name,
			&i.TokenMetadata.Logo,
			&i.TokenMetadata.Thumbnail,
			&i.TokenMetadata.Chain,
			&i.TokenMetadata.ContractAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
