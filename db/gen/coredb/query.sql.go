// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package coredb

import (
	"context"
	"database/sql"
	"time"

	"github.com/SplitFi/go-splitfi/service/persist"
	"github.com/jackc/pgtype"
)

const addPiiAccountCreationInfo = `-- name: AddPiiAccountCreationInfo :exec
insert into pii.account_creation_info (user_id, ip_address, created_at) values ($1, $2, now())
on conflict do nothing
`

type AddPiiAccountCreationInfoParams struct {
	UserID    persist.DBID `db:"user_id" json:"user_id"`
	IpAddress string       `db:"ip_address" json:"ip_address"`
}

func (q *Queries) AddPiiAccountCreationInfo(ctx context.Context, arg AddPiiAccountCreationInfoParams) error {
	_, err := q.db.Exec(ctx, addPiiAccountCreationInfo, arg.UserID, arg.IpAddress)
	return err
}

const addUserRoles = `-- name: AddUserRoles :exec
insert into user_roles (id, user_id, role, created_at, last_updated)
select unnest($2::varchar[]), $1, unnest($3::varchar[]), now(), now()
on conflict (user_id, role) do update set deleted = false, last_updated = now()
`

type AddUserRolesParams struct {
	UserID persist.DBID `db:"user_id" json:"user_id"`
	Ids    []string     `db:"ids" json:"ids"`
	Roles  []string     `db:"roles" json:"roles"`
}

func (q *Queries) AddUserRoles(ctx context.Context, arg AddUserRolesParams) error {
	_, err := q.db.Exec(ctx, addUserRoles, arg.UserID, arg.Ids, arg.Roles)
	return err
}

const blockUser = `-- name: BlockUser :one
with user_to_block as (select id from users where users.id = $3 and not deleted and not universal)
insert into user_blocklist (id, user_id, blocked_user_id, active) (select $1, $2, user_to_block.id, true from user_to_block)
on conflict(user_id, blocked_user_id) where not deleted do update set active = true, last_updated = now() returning id
`

type BlockUserParams struct {
	ID            persist.DBID `db:"id" json:"id"`
	UserID        persist.DBID `db:"user_id" json:"user_id"`
	BlockedUserID persist.DBID `db:"blocked_user_id" json:"blocked_user_id"`
}

func (q *Queries) BlockUser(ctx context.Context, arg BlockUserParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, blockUser, arg.ID, arg.UserID, arg.BlockedUserID)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const clearNotificationsForUser = `-- name: ClearNotificationsForUser :many
UPDATE notifications SET seen = true WHERE owner_id = $1 AND seen = false RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount
`

func (q *Queries) ClearNotificationsForUser(ctx context.Context, ownerID persist.DBID) ([]Notification, error) {
	rows, err := q.db.Query(ctx, clearNotificationsForUser, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countAllUsers = `-- name: CountAllUsers :one
SELECT count(*) FROM users WHERE deleted = false and universal = false
`

func (q *Queries) CountAllUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSplitsByRecipientUserID = `-- name: CountSplitsByRecipientUserID :one
select count(distinct s.id)
    from users u, unnest(u.wallets) with ordinality as a(wallet_id, wallet_ord)
                      join wallets w on w.id = a.wallet_id
                      join recipients r on r.address = w.address
                      join splits s on s.id = r.split_id
    where u.id = $1
      and u.deleted = false
      and w.deleted = false
      and r.deleted = false
      and s.deleted = false
`

func (q *Queries) CountSplitsByRecipientUserID(ctx context.Context, id persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countSplitsByRecipientUserID, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserNotifications = `-- name: CountUserNotifications :one
SELECT count(*) FROM notifications WHERE owner_id = $1 AND deleted = false
`

func (q *Queries) CountUserNotifications(ctx context.Context, ownerID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserNotifications, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserUnseenNotifications = `-- name: CountUserUnseenNotifications :one
SELECT count(*) FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false
`

func (q *Queries) CountUserUnseenNotifications(ctx context.Context, ownerID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserUnseenNotifications, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAnnouncementNotifications = `-- name: CreateAnnouncementNotifications :many
WITH
    id_with_row_number AS (
        SELECT unnest($5::varchar(255)[]) AS id, row_number() OVER (ORDER BY unnest($5::varchar(255)[])) AS rn
    ),
    user_with_row_number AS (
        SELECT id AS user_id, row_number() OVER () AS rn
        FROM users
        WHERE deleted = false AND universal = false
    )
INSERT INTO notifications (id, owner_id, action, data, event_ids)
SELECT
    i.id,
    u.user_id,
    $1,
    $2,
    $3
FROM
    id_with_row_number i
        JOIN
    user_with_row_number u ON i.rn = u.rn
WHERE NOT EXISTS (
    SELECT 1
    FROM notifications n
    WHERE n.owner_id = u.user_id
      AND n.data ->> 'internal_id' = $4::varchar
)
RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount
`

type CreateAnnouncementNotificationsParams struct {
	Action   persist.Action           `db:"action" json:"action"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
	Internal string                   `db:"internal" json:"internal"`
	Ids      []string                 `db:"ids" json:"ids"`
}

// later on, we might want to add a "global" column to notifications or even an enum column like "match" to determine how largely consumed
// notifications will get searched for for a given user. For example, global notifications will always return for a user and follower notifications will
// perform the check to see if the user follows the owner of the notification. Where this breaks is how we handle "seen" notifications. Since there is 1:1 notifications to users
// right now, we can't have a "seen" field on the notification itself. We would have to move seen out into a separate table.
func (q *Queries) CreateAnnouncementNotifications(ctx context.Context, arg CreateAnnouncementNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, createAnnouncementNotifications,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.Internal,
		arg.Ids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createPushTickets = `-- name: CreatePushTickets :exec
insert into push_notification_tickets (id, push_token_id, ticket_id, created_at, check_after, num_check_attempts, status, deleted) values
    (
        unnest($1::text[]),
        unnest($2::text[]),
        unnest($3::text[]),
        now(),
        now() + interval '15 minutes',
        0,
        'pending',
        false
    )
`

type CreatePushTicketsParams struct {
	Ids          []string `db:"ids" json:"ids"`
	PushTokenIds []string `db:"push_token_ids" json:"push_token_ids"`
	TicketIds    []string `db:"ticket_ids" json:"ticket_ids"`
}

func (q *Queries) CreatePushTickets(ctx context.Context, arg CreatePushTicketsParams) error {
	_, err := q.db.Exec(ctx, createPushTickets, arg.Ids, arg.PushTokenIds, arg.TicketIds)
	return err
}

const createPushTokenForUser = `-- name: CreatePushTokenForUser :one
insert into push_notification_tokens (id, user_id, push_token, created_at, deleted) values ($1, $2, $3, now(), false) returning id, user_id, push_token, created_at, deleted
`

type CreatePushTokenForUserParams struct {
	ID        persist.DBID `db:"id" json:"id"`
	UserID    persist.DBID `db:"user_id" json:"user_id"`
	PushToken string       `db:"push_token" json:"push_token"`
}

func (q *Queries) CreatePushTokenForUser(ctx context.Context, arg CreatePushTokenForUserParams) (PushNotificationToken, error) {
	row := q.db.QueryRow(ctx, createPushTokenForUser, arg.ID, arg.UserID, arg.PushToken)
	var i PushNotificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PushToken,
		&i.CreatedAt,
		&i.Deleted,
	)
	return i, err
}

const createSimpleNotification = `-- name: CreateSimpleNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids) VALUES ($1, $2, $3, $4, $5) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount
`

type CreateSimpleNotificationParams struct {
	ID       persist.DBID             `db:"id" json:"id"`
	OwnerID  persist.DBID             `db:"owner_id" json:"owner_id"`
	Action   persist.Action           `db:"action" json:"action"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
}

func (q *Queries) CreateSimpleNotification(ctx context.Context, arg CreateSimpleNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createSimpleNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.SplitID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const createSplit = `-- name: CreateSplit :one
insert into splits (id, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership, created_at, last_updated) values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, now(), now()) returning id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership
`

type CreateSplitParams struct {
	SplitID        persist.DBID    `db:"split_id" json:"split_id"`
	Chain          persist.Chain   `db:"chain" json:"chain"`
	Address        persist.Address `db:"address" json:"address"`
	Name           string          `db:"name" json:"name"`
	Description    string          `db:"description" json:"description"`
	CreatorAddress persist.Address `db:"creator_address" json:"creator_address"`
	LogoUrl        sql.NullString  `db:"logo_url" json:"logo_url"`
	BannerUrl      sql.NullString  `db:"banner_url" json:"banner_url"`
	BadgeUrl       sql.NullString  `db:"badge_url" json:"badge_url"`
	TotalOwnership int32           `db:"total_ownership" json:"total_ownership"`
}

func (q *Queries) CreateSplit(ctx context.Context, arg CreateSplitParams) (Split, error) {
	row := q.db.QueryRow(ctx, createSplit,
		arg.SplitID,
		arg.Chain,
		arg.Address,
		arg.Name,
		arg.Description,
		arg.CreatorAddress,
		arg.LogoUrl,
		arg.BannerUrl,
		arg.BadgeUrl,
		arg.TotalOwnership,
	)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Deleted,
		&i.Chain,
		&i.Address,
		&i.Name,
		&i.Description,
		&i.CreatorAddress,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.BadgeUrl,
		&i.TotalOwnership,
	)
	return i, err
}

const createSplitEvent = `-- name: CreateSplitEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, split_id, subject_id, data, external_id, group_id, caption) VALUES ($1, $2, $3, $4, $5, $5, $6, $7, $8, $9) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id
`

type CreateSplitEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	SplitID        persist.DBID         `db:"split_id" json:"split_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	ExternalID     sql.NullString       `db:"external_id" json:"external_id"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
}

func (q *Queries) CreateSplitEvent(ctx context.Context, arg CreateSplitEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createSplitEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.SplitID,
		arg.Data,
		arg.ExternalID,
		arg.GroupID,
		arg.Caption,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.SplitID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const createUserEvent = `-- name: CreateUserEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, user_id, subject_id, data, group_id, caption) VALUES ($1, $2, $3, $4, $5, $5, $6, $7, $8) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id
`

type CreateUserEventParams struct {
	ID             persist.DBID         `db:"id" json:"id"`
	ActorID        sql.NullString       `db:"actor_id" json:"actor_id"`
	Action         persist.Action       `db:"action" json:"action"`
	ResourceTypeID persist.ResourceType `db:"resource_type_id" json:"resource_type_id"`
	UserID         persist.DBID         `db:"user_id" json:"user_id"`
	Data           persist.EventData    `db:"data" json:"data"`
	GroupID        sql.NullString       `db:"group_id" json:"group_id"`
	Caption        sql.NullString       `db:"caption" json:"caption"`
}

func (q *Queries) CreateUserEvent(ctx context.Context, arg CreateUserEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createUserEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.UserID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.SplitID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const createViewSplitNotification = `-- name: CreateViewSplitNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, split_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount
`

type CreateViewSplitNotificationParams struct {
	ID       persist.DBID             `db:"id" json:"id"`
	OwnerID  persist.DBID             `db:"owner_id" json:"owner_id"`
	Action   persist.Action           `db:"action" json:"action"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
	SplitID  persist.DBID             `db:"split_id" json:"split_id"`
}

func (q *Queries) CreateViewSplitNotification(ctx context.Context, arg CreateViewSplitNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createViewSplitNotification,
		arg.ID,
		arg.OwnerID,
		arg.Action,
		arg.Data,
		arg.EventIds,
		arg.SplitID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.SplitID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const deletePushTokensByIDs = `-- name: DeletePushTokensByIDs :exec
update push_notification_tokens set deleted = true where id = any($1) and deleted = false
`

func (q *Queries) DeletePushTokensByIDs(ctx context.Context, ids persist.DBIDList) error {
	_, err := q.db.Exec(ctx, deletePushTokensByIDs, ids)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
update users set deleted = true where id = $1
`

func (q *Queries) DeleteUserByID(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, deleteUserByID, id)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
update user_roles set deleted = true, last_updated = now() where user_id = $1 and role = any($2)
`

type DeleteUserRolesParams struct {
	UserID persist.DBID     `db:"user_id" json:"user_id"`
	Roles  persist.RoleList `db:"roles" json:"roles"`
}

func (q *Queries) DeleteUserRoles(ctx context.Context, arg DeleteUserRolesParams) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, arg.UserID, arg.Roles)
	return err
}

const deleteWalletByID = `-- name: DeleteWalletByID :exec
update wallets set deleted = true, last_updated = now() where id = $1
`

func (q *Queries) DeleteWalletByID(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, deleteWalletByID, id)
	return err
}

const getActorForGroup = `-- name: GetActorForGroup :one
select actor_id from events where group_id = $1 and deleted = false order by(created_at, id) asc limit 1
`

func (q *Queries) GetActorForGroup(ctx context.Context, groupID sql.NullString) (sql.NullString, error) {
	row := q.db.QueryRow(ctx, getActorForGroup, groupID)
	var actor_id sql.NullString
	err := row.Scan(&actor_id)
	return actor_id, err
}

const getCheckablePushTickets = `-- name: GetCheckablePushTickets :many
select id, push_token_id, ticket_id, created_at, check_after, num_check_attempts, deleted from push_notification_tickets where check_after <= now() and deleted = false limit $1
`

func (q *Queries) GetCheckablePushTickets(ctx context.Context, limit int32) ([]PushNotificationTicket, error) {
	rows, err := q.db.Query(ctx, getCheckablePushTickets, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PushNotificationTicket
	for rows.Next() {
		var i PushNotificationTicket
		if err := rows.Scan(
			&i.ID,
			&i.PushTokenID,
			&i.TicketID,
			&i.CreatedAt,
			&i.CheckAfter,
			&i.NumCheckAttempts,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentTime = `-- name: GetCurrentTime :one
select now()::timestamptz
`

func (q *Queries) GetCurrentTime(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRow(ctx, getCurrentTime)
	var column_1 time.Time
	err := row.Scan(&column_1)
	return column_1, err
}

const getEvent = `-- name: GetEvent :one
SELECT id, version, actor_id, resource_type_id, subject_id, user_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id FROM events WHERE id = $1 AND deleted = false
`

func (q *Queries) GetEvent(ctx context.Context, id persist.DBID) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.SplitID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const getEventsInGroup = `-- name: GetEventsInGroup :many
select id, version, actor_id, resource_type_id, subject_id, user_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where group_id = $1 and deleted = false order by(created_at, id) asc
`

func (q *Queries) GetEventsInGroup(ctx context.Context, groupID sql.NullString) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.SplitID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsInWindow = `-- name: GetEventsInWindow :many
with recursive activity as (
    select id, version, actor_id, resource_type_id, subject_id, user_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where events.id = $1 and deleted = false
    union
    select e.id, e.version, e.actor_id, e.resource_type_id, e.subject_id, e.user_id, e.action, e.data, e.deleted, e.last_updated, e.created_at, e.split_id, e.external_id, e.caption, e.group_id from events e, activity a
    where e.actor_id = a.actor_id
      and e.action = any($3)
      and e.created_at < a.created_at
      and e.created_at >= a.created_at - make_interval(secs => $2)
      and e.deleted = false
      and e.caption is null
      and (not $4::bool or e.subject_id = a.subject_id)
)
select id, version, actor_id, resource_type_id, subject_id, user_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where id = any(select id from activity) order by (created_at, id) asc
`

type GetEventsInWindowParams struct {
	ID             persist.DBID       `db:"id" json:"id"`
	Secs           float64            `db:"secs" json:"secs"`
	Actions        persist.ActionList `db:"actions" json:"actions"`
	IncludeSubject bool               `db:"include_subject" json:"include_subject"`
}

func (q *Queries) GetEventsInWindow(ctx context.Context, arg GetEventsInWindowParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsInWindow,
		arg.ID,
		arg.Secs,
		arg.Actions,
		arg.IncludeSubject,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.SplitID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRecentNotificationByOwnerIDForAction = `-- name: GetMostRecentNotificationByOwnerIDForAction :one
select id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount from notifications
where owner_id = $1
  and action = $2
  and deleted = false
order by created_at desc
limit 1
`

type GetMostRecentNotificationByOwnerIDForActionParams struct {
	OwnerID persist.DBID   `db:"owner_id" json:"owner_id"`
	Action  persist.Action `db:"action" json:"action"`
}

func (q *Queries) GetMostRecentNotificationByOwnerIDForAction(ctx context.Context, arg GetMostRecentNotificationByOwnerIDForActionParams) (Notification, error) {
	row := q.db.QueryRow(ctx, getMostRecentNotificationByOwnerIDForAction, arg.OwnerID, arg.Action)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.SplitID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE id = $1 AND deleted = false
`

func (q *Queries) GetNotificationByID(ctx context.Context, id persist.DBID) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.SplitID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const getNotificationsByOwnerIDForActionAfter = `-- name: GetNotificationsByOwnerIDForActionAfter :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications
WHERE owner_id = $1 AND action = $2 AND deleted = false AND created_at > $3
ORDER BY created_at DESC
`

type GetNotificationsByOwnerIDForActionAfterParams struct {
	OwnerID      persist.DBID   `db:"owner_id" json:"owner_id"`
	Action       persist.Action `db:"action" json:"action"`
	CreatedAfter time.Time      `db:"created_after" json:"created_after"`
}

func (q *Queries) GetNotificationsByOwnerIDForActionAfter(ctx context.Context, arg GetNotificationsByOwnerIDForActionAfterParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByOwnerIDForActionAfter, arg.OwnerID, arg.Action, arg.CreatedAfter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPushTokenByPushToken = `-- name: GetPushTokenByPushToken :one
select id, user_id, push_token, created_at, deleted from push_notification_tokens where push_token = $1 and deleted = false
`

func (q *Queries) GetPushTokenByPushToken(ctx context.Context, pushToken string) (PushNotificationToken, error) {
	row := q.db.QueryRow(ctx, getPushTokenByPushToken, pushToken)
	var i PushNotificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PushToken,
		&i.CreatedAt,
		&i.Deleted,
	)
	return i, err
}

const getPushTokensByIDs = `-- name: GetPushTokensByIDs :many
with keys as (
    select unnest ($1::text[]) as id
         , generate_subscripts($1::text[], 1) as index
)
select t.id, t.user_id, t.push_token, t.created_at, t.deleted from keys k join push_notification_tokens t on t.id = k.id and t.deleted = false
order by k.index
`

func (q *Queries) GetPushTokensByIDs(ctx context.Context, ids []string) ([]PushNotificationToken, error) {
	rows, err := q.db.Query(ctx, getPushTokensByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PushNotificationToken
	for rows.Next() {
		var i PushNotificationToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PushToken,
			&i.CreatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPushTokensByUserID = `-- name: GetPushTokensByUserID :many
select id, user_id, push_token, created_at, deleted from push_notification_tokens where user_id = $1 and deleted = false
`

func (q *Queries) GetPushTokensByUserID(ctx context.Context, userID persist.DBID) ([]PushNotificationToken, error) {
	rows, err := q.db.Query(ctx, getPushTokensByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PushNotificationToken
	for rows.Next() {
		var i PushNotificationToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PushToken,
			&i.CreatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentUnseenNotifications = `-- name: GetRecentUnseenNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false and created_at > $2 order by created_at desc limit $3
`

type GetRecentUnseenNotificationsParams struct {
	OwnerID      persist.DBID `db:"owner_id" json:"owner_id"`
	CreatedAfter time.Time    `db:"created_after" json:"created_after"`
	Lim          int32        `db:"lim" json:"lim"`
}

func (q *Queries) GetRecentUnseenNotifications(ctx context.Context, arg GetRecentUnseenNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getRecentUnseenNotifications, arg.OwnerID, arg.CreatedAfter, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitByChainAddress = `-- name: GetSplitByChainAddress :one
SELECT id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership FROM splits WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetSplitByChainAddressParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetSplitByChainAddress(ctx context.Context, arg GetSplitByChainAddressParams) (Split, error) {
	row := q.db.QueryRow(ctx, getSplitByChainAddress, arg.Address, arg.Chain)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Deleted,
		&i.Chain,
		&i.Address,
		&i.Name,
		&i.Description,
		&i.CreatorAddress,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.BadgeUrl,
		&i.TotalOwnership,
	)
	return i, err
}

const getSplitById = `-- name: GetSplitById :one
SELECT id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership FROM splits WHERE id = $1 AND deleted = false
`

func (q *Queries) GetSplitById(ctx context.Context, id persist.DBID) (Split, error) {
	row := q.db.QueryRow(ctx, getSplitById, id)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Deleted,
		&i.Chain,
		&i.Address,
		&i.Name,
		&i.Description,
		&i.CreatorAddress,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.BadgeUrl,
		&i.TotalOwnership,
	)
	return i, err
}

const getSplitByRecipientUserID = `-- name: GetSplitByRecipientUserID :one
SELECT s.id, s.version, s.last_updated, s.created_at, s.deleted, s.chain, s.address, s.name, s.description, s.creator_address, s.logo_url, s.banner_url, s.badge_url, s.total_ownership FROM users u, unnest(u.wallets)
    WITH ORDINALITY AS a(wallet_id, wallet_ord)
    INNER JOIN wallets w on w.id = a.wallet_id
    INNER JOIN recipients r ON r.address = w.address
    INNER JOIN splits s ON s.id = r.split_id
    WHERE u.id = $1 AND s.id = $2 AND u.deleted = false AND w.deleted = false AND r.deleted = false AND s.deleted = false
`

type GetSplitByRecipientUserIDParams struct {
	UserID  persist.DBID `db:"user_id" json:"user_id"`
	SplitID persist.DBID `db:"split_id" json:"split_id"`
}

func (q *Queries) GetSplitByRecipientUserID(ctx context.Context, arg GetSplitByRecipientUserIDParams) (Split, error) {
	row := q.db.QueryRow(ctx, getSplitByRecipientUserID, arg.UserID, arg.SplitID)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Deleted,
		&i.Chain,
		&i.Address,
		&i.Name,
		&i.Description,
		&i.CreatorAddress,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.BadgeUrl,
		&i.TotalOwnership,
	)
	return i, err
}

const getSplitEventsInWindow = `-- name: GetSplitEventsInWindow :many
with recursive activity as (
    select id, version, actor_id, resource_type_id, subject_id, user_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where events.id = $1 and deleted = false
    union
    select e.id, e.version, e.actor_id, e.resource_type_id, e.subject_id, e.user_id, e.action, e.data, e.deleted, e.last_updated, e.created_at, e.split_id, e.external_id, e.caption, e.group_id from events e, activity a
    where e.actor_id = a.actor_id
      and e.action = any($3)
      and e.split_id = $4
      and e.created_at < a.created_at
      and e.created_at >= a.created_at - make_interval(secs => $2)
      and e.deleted = false
      and e.caption is null
      and (not $5::bool or e.subject_id = a.subject_id)
)
select id, version, actor_id, resource_type_id, subject_id, user_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where id = any(select id from activity) order by (created_at, id) asc
`

type GetSplitEventsInWindowParams struct {
	ID             persist.DBID       `db:"id" json:"id"`
	Secs           float64            `db:"secs" json:"secs"`
	Actions        persist.ActionList `db:"actions" json:"actions"`
	SplitID        persist.DBID       `db:"split_id" json:"split_id"`
	IncludeSubject bool               `db:"include_subject" json:"include_subject"`
}

func (q *Queries) GetSplitEventsInWindow(ctx context.Context, arg GetSplitEventsInWindowParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getSplitEventsInWindow,
		arg.ID,
		arg.Secs,
		arg.Actions,
		arg.SplitID,
		arg.IncludeSubject,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.SplitID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByChainsAndAddresses = `-- name: GetSplitsByChainsAndAddresses :many
SELECT id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership FROM splits WHERE chain = any($1::int[]) OR contract_address = any($2::varchar[]) AND deleted = false
`

type GetSplitsByChainsAndAddressesParams struct {
	Chains    []int32  `db:"chains" json:"chains"`
	Addresses []string `db:"addresses" json:"addresses"`
}

func (q *Queries) GetSplitsByChainsAndAddresses(ctx context.Context, arg GetSplitsByChainsAndAddressesParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByChainsAndAddresses, arg.Chains, arg.Addresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Split
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByRecipientAddress = `-- name: GetSplitsByRecipientAddress :many
SELECT s.id, s.version, s.last_updated, s.created_at, s.deleted, s.chain, s.address, s.name, s.description, s.creator_address, s.logo_url, s.banner_url, s.badge_url, s.total_ownership FROM recipients r
                    JOIN splits s ON s.id = r.split_id
WHERE r.address = $1 AND s.deleted = false
`

func (q *Queries) GetSplitsByRecipientAddress(ctx context.Context, address persist.Address) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByRecipientAddress, address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Split
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByRecipientChainAddress = `-- name: GetSplitsByRecipientChainAddress :many
SELECT s.id, s.version, s.last_updated, s.created_at, s.deleted, s.chain, s.address, s.name, s.description, s.creator_address, s.logo_url, s.banner_url, s.badge_url, s.total_ownership FROM recipients r
                    JOIN splits s ON s.id = r.split_id
WHERE r.address = $1 AND s.chain = $2 AND s.deleted = false
`

type GetSplitsByRecipientChainAddressParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetSplitsByRecipientChainAddress(ctx context.Context, arg GetSplitsByRecipientChainAddressParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByRecipientChainAddress, arg.Address, arg.Chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Split
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByRecipientUserIDPaginate = `-- name: GetSplitsByRecipientUserIDPaginate :many
select s.id, s.version, s.last_updated, s.created_at, s.deleted, s.chain, s.address, s.name, s.description, s.creator_address, s.logo_url, s.banner_url, s.badge_url, s.total_ownership
    from users u, unnest(u.wallets)
    with ordinality as a(wallet_id, wallet_ord)
        join wallets w on w.id = a.wallet_id
        join recipients r on r.address = w.address
        join splits s on s.id = r.split_id
    where u.id = $1
      and u.deleted = false
      and w.deleted = false
      and r.deleted = false
      and s.deleted = false
      and (s.created_at,s.id) < ($3::timestamptz, $4::dbid)
      and (s.created_at,s.id) > ($5::timestamptz, $6::dbid)
    order by case when $7::bool then (s.created_at,s.id) end asc,
             case when not $7::bool then (s.created_at,s.id) end desc
    limit $2
`

type GetSplitsByRecipientUserIDPaginateParams struct {
	ID            persist.DBID `db:"id" json:"id"`
	Limit         int32        `db:"limit" json:"limit"`
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   interface{}  `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    interface{}  `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetSplitsByRecipientUserIDPaginate(ctx context.Context, arg GetSplitsByRecipientUserIDPaginateParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByRecipientUserIDPaginate,
		arg.ID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Split
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByChainAddress = `-- name: GetUserByChainAddress :one
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_split, users.primary_wallet_id, users.user_experiences
from users, wallets
where wallets.address = $1
  and wallets.chain = $2
  and array[wallets.id] <@ users.wallets
  and wallets.deleted = false
  and users.deleted = false
`

type GetUserByChainAddressParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetUserByChainAddress(ctx context.Context, arg GetUserByChainAddressParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByChainAddress, arg.Address, arg.Chain)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE id = $1 AND deleted = false
`

func (q *Queries) GetUserById(ctx context.Context, id persist.DBID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE username_idempotent = lower($1) AND deleted = false
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
	)
	return i, err
}

const getUserByVerifiedEmailAddress = `-- name: GetUserByVerifiedEmailAddress :one
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_split, u.primary_wallet_id, u.user_experiences from users u join pii.for_users p on u.id = p.user_id
where p.pii_verified_email_address = lower($1)
  and p.deleted = false
  and u.deleted = false
`

func (q *Queries) GetUserByVerifiedEmailAddress(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByVerifiedEmailAddress, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
	)
	return i, err
}

const getUserByWalletID = `-- name: GetUserByWalletID :one
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences from users where array[$1::varchar]::varchar[] <@ wallets and deleted = false
`

func (q *Queries) GetUserByWalletID(ctx context.Context, wallet string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByWalletID, wallet)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
	)
	return i, err
}

const getUserExperiencesByUserID = `-- name: GetUserExperiencesByUserID :one
select user_experiences from users where id = $1
`

func (q *Queries) GetUserExperiencesByUserID(ctx context.Context, id persist.DBID) (pgtype.JSONB, error) {
	row := q.db.QueryRow(ctx, getUserExperiencesByUserID, id)
	var user_experiences pgtype.JSONB
	err := row.Scan(&user_experiences)
	return user_experiences, err
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false
                              AND (created_at, id) < ($3, $4)
                              AND (created_at, id) > ($5, $6)
ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
         CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
LIMIT $2
`

type GetUserNotificationsParams struct {
	OwnerID       persist.DBID `db:"owner_id" json:"owner_id"`
	Limit         int32        `db:"limit" json:"limit"`
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserNotifications,
		arg.OwnerID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRolesByUserId = `-- name: GetUserRolesByUserId :many
select role from user_roles where user_id = $1 and deleted = false
`

func (q *Queries) GetUserRolesByUserId(ctx context.Context, userID persist.DBID) ([]persist.Role, error) {
	rows, err := q.db.Query(ctx, getUserRolesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.Role
	for rows.Next() {
		var role persist.Role
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserUnseenNotifications = `-- name: GetUserUnseenNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false
                              AND (created_at, id) < ($3, $4)
                              AND (created_at, id) > ($5, $6)
ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
         CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
LIMIT $2
`

type GetUserUnseenNotificationsParams struct {
	OwnerID       persist.DBID `db:"owner_id" json:"owner_id"`
	Limit         int32        `db:"limit" json:"limit"`
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetUserUnseenNotifications(ctx context.Context, arg GetUserUnseenNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserUnseenNotifications,
		arg.OwnerID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithPIIByID = `-- name: GetUserWithPIIByID :one
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences, pii_unverified_email_address, pii_verified_email_address from pii.user_view where id = $1 and deleted = false
`

func (q *Queries) GetUserWithPIIByID(ctx context.Context, userID persist.DBID) (PiiUserView, error) {
	row := q.db.QueryRow(ctx, getUserWithPIIByID, userID)
	var i PiiUserView
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.PiiUnverifiedEmailAddress,
		&i.PiiVerifiedEmailAddress,
	)
	return i, err
}

const getUsersByChainAddresses = `-- name: GetUsersByChainAddresses :many
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_unsubscriptions, users.featured_split, users.primary_wallet_id, users.user_experiences,wallets.address from users, wallets where wallets.address = ANY($1::varchar[]) AND wallets.chain = $2::int AND ARRAY[wallets.id] <@ users.wallets AND users.deleted = false AND wallets.deleted = false
`

type GetUsersByChainAddressesParams struct {
	Addresses []string `db:"addresses" json:"addresses"`
	Chain     int32    `db:"chain" json:"chain"`
}

type GetUsersByChainAddressesRow struct {
	ID                   persist.DBID                     `db:"id" json:"id"`
	Deleted              bool                             `db:"deleted" json:"deleted"`
	Version              sql.NullInt32                    `db:"version" json:"version"`
	LastUpdated          time.Time                        `db:"last_updated" json:"last_updated"`
	CreatedAt            time.Time                        `db:"created_at" json:"created_at"`
	Username             sql.NullString                   `db:"username" json:"username"`
	UsernameIdempotent   sql.NullString                   `db:"username_idempotent" json:"username_idempotent"`
	Wallets              persist.WalletList               `db:"wallets" json:"wallets"`
	Bio                  sql.NullString                   `db:"bio" json:"bio"`
	Traits               pgtype.JSONB                     `db:"traits" json:"traits"`
	Universal            bool                             `db:"universal" json:"universal"`
	NotificationSettings persist.UserNotificationSettings `db:"notification_settings" json:"notification_settings"`
	EmailUnsubscriptions persist.EmailUnsubscriptions     `db:"email_unsubscriptions" json:"email_unsubscriptions"`
	FeaturedSplit        *persist.DBID                    `db:"featured_split" json:"featured_split"`
	PrimaryWalletID      persist.DBID                     `db:"primary_wallet_id" json:"primary_wallet_id"`
	UserExperiences      pgtype.JSONB                     `db:"user_experiences" json:"user_experiences"`
	Address              persist.Address                  `db:"address" json:"address"`
}

func (q *Queries) GetUsersByChainAddresses(ctx context.Context, arg GetUsersByChainAddressesParams) ([]GetUsersByChainAddressesRow, error) {
	rows, err := q.db.Query(ctx, getUsersByChainAddresses, arg.Addresses, arg.Chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByChainAddressesRow
	for rows.Next() {
		var i GetUsersByChainAddressesRow
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE id = ANY($2) AND deleted = false
                      AND (created_at, id) < ($3, $4)
                      AND (created_at, id) > ($5, $6)
ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
         CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
LIMIT $1
`

type GetUsersByIDsParams struct {
	Limit         int32            `db:"limit" json:"limit"`
	UserIds       persist.DBIDList `db:"user_ids" json:"user_ids"`
	CurBeforeTime time.Time        `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID     `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time        `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID     `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool             `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetUsersByIDs(ctx context.Context, arg GetUsersByIDsParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs,
		arg.Limit,
		arg.UserIds,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithEmailNotificationsOnForEmailType = `-- name: GetUsersWithEmailNotificationsOnForEmailType :many
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_split, u.primary_wallet_id, u.user_experiences, u.pii_unverified_email_address, u.pii_verified_email_address from pii.user_view u
                    left join user_roles r on r.user_id = u.id and r.role = 'EMAIL_TESTER' and r.deleted = false
where (u.email_unsubscriptions->>'all' = 'false' or u.email_unsubscriptions->>'all' is null)
  and (u.email_unsubscriptions->>$2::varchar = 'false' or u.email_unsubscriptions->>$2::varchar is null)
  and u.deleted = false and u.pii_verified_email_address is not null
  and (u.created_at, u.id) < ($3, $4::dbid)
  and (u.created_at, u.id) > ($5, $6::dbid)
  and ($7::bool = false or r.user_id is not null)
order by case when $8::bool then (u.created_at, u.id) end asc,
         case when not $8::bool then (u.created_at, u.id) end desc
limit $1
`

type GetUsersWithEmailNotificationsOnForEmailTypeParams struct {
	Limit               int32       `db:"limit" json:"limit"`
	EmailUnsubscription string      `db:"email_unsubscription" json:"email_unsubscription"`
	CurBeforeTime       time.Time   `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID         interface{} `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime        time.Time   `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID          interface{} `db:"cur_after_id" json:"cur_after_id"`
	EmailTestersOnly    bool        `db:"email_testers_only" json:"email_testers_only"`
	PagingForward       bool        `db:"paging_forward" json:"paging_forward"`
}

// for some reason this query will not allow me to use @tags for $1
func (q *Queries) GetUsersWithEmailNotificationsOnForEmailType(ctx context.Context, arg GetUsersWithEmailNotificationsOnForEmailTypeParams) ([]PiiUserView, error) {
	rows, err := q.db.Query(ctx, getUsersWithEmailNotificationsOnForEmailType,
		arg.Limit,
		arg.EmailUnsubscription,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.EmailTestersOnly,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PiiUserView
	for rows.Next() {
		var i PiiUserView
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.PiiUnverifiedEmailAddress,
			&i.PiiVerifiedEmailAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRolePaginate = `-- name: GetUsersWithRolePaginate :many
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_unsubscriptions, u.featured_split, u.primary_wallet_id, u.user_experiences from users u, user_roles ur where u.deleted = false and ur.deleted = false
                                         and u.id = ur.user_id and ur.role = $2
                                         and (u.username_idempotent, u.id) < ($3::varchar, $4::dbid)
                                         and (u.username_idempotent, u.id) > ($5::varchar, $6::dbid)
order by case when $7::bool then (u.username_idempotent, u.id) end asc,
         case when not $7::bool then (u.username_idempotent, u.id) end desc
limit $1
`

type GetUsersWithRolePaginateParams struct {
	Limit         int32        `db:"limit" json:"limit"`
	Role          persist.Role `db:"role" json:"role"`
	CurBeforeKey  string       `db:"cur_before_key" json:"cur_before_key"`
	CurBeforeID   interface{}  `db:"cur_before_id" json:"cur_before_id"`
	CurAfterKey   string       `db:"cur_after_key" json:"cur_after_key"`
	CurAfterID    interface{}  `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
}

func (q *Queries) GetUsersWithRolePaginate(ctx context.Context, arg GetUsersWithRolePaginateParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithRolePaginate,
		arg.Limit,
		arg.Role,
		arg.CurBeforeKey,
		arg.CurBeforeID,
		arg.CurAfterKey,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithTrait = `-- name: GetUsersWithTrait :many
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE (traits->$1::string) IS NOT NULL AND deleted = false
`

func (q *Queries) GetUsersWithTrait(ctx context.Context, dollar_1 string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithTrait, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByChainAddress = `-- name: GetWalletByChainAddress :one
SELECT wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type, wallets.chain FROM wallets WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetWalletByChainAddressParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetWalletByChainAddress(ctx context.Context, arg GetWalletByChainAddressParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByChainAddress, arg.Address, arg.Chain)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Version,
		&i.Address,
		&i.WalletType,
		&i.Chain,
	)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, created_at, last_updated, deleted, version, address, wallet_type, chain FROM wallets WHERE id = $1 AND deleted = false
`

func (q *Queries) GetWalletByID(ctx context.Context, id persist.DBID) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Version,
		&i.Address,
		&i.WalletType,
		&i.Chain,
	)
	return i, err
}

const getWalletsByUserID = `-- name: GetWalletsByUserID :many
SELECT w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type, w.chain FROM users u, unnest(u.wallets) WITH ORDINALITY AS a(wallet_id, wallet_ord)INNER JOIN wallets w on w.id = a.wallet_id WHERE u.id = $1 AND u.deleted = false AND w.deleted = false ORDER BY a.wallet_ord
`

func (q *Queries) GetWalletsByUserID(ctx context.Context, id persist.DBID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getWalletsByUserID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasLaterGroupedEvent = `-- name: HasLaterGroupedEvent :one
select exists(
    select 1 from events where deleted = false
                           and group_id = $1
                           and id > $2
)
`

type HasLaterGroupedEventParams struct {
	GroupID sql.NullString `db:"group_id" json:"group_id"`
	EventID persist.DBID   `db:"event_id" json:"event_id"`
}

func (q *Queries) HasLaterGroupedEvent(ctx context.Context, arg HasLaterGroupedEventParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasLaterGroupedEvent, arg.GroupID, arg.EventID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const insertUser = `-- name: InsertUser :one
insert into users (id, username, username_idempotent, bio, universal, email_unsubscriptions) values ($1, $2, $3, $4, $5, $6) returning id
`

type InsertUserParams struct {
	ID                   persist.DBID                 `db:"id" json:"id"`
	Username             sql.NullString               `db:"username" json:"username"`
	UsernameIdempotent   sql.NullString               `db:"username_idempotent" json:"username_idempotent"`
	Bio                  sql.NullString               `db:"bio" json:"bio"`
	Universal            bool                         `db:"universal" json:"universal"`
	EmailUnsubscriptions persist.EmailUnsubscriptions `db:"email_unsubscriptions" json:"email_unsubscriptions"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (persist.DBID, error) {
	row := q.db.QueryRow(ctx, insertUser,
		arg.ID,
		arg.Username,
		arg.UsernameIdempotent,
		arg.Bio,
		arg.Universal,
		arg.EmailUnsubscriptions,
	)
	var id persist.DBID
	err := row.Scan(&id)
	return id, err
}

const insertWallet = `-- name: InsertWallet :exec
with new_wallet as (insert into wallets(id, address, chain, wallet_type) values ($1, $2, $3, $4) returning id)
update users set
                 primary_wallet_id = coalesce(users.primary_wallet_id, new_wallet.id),
                 wallets = array_append(users.wallets, new_wallet.id)
from new_wallet
where users.id = $5 and not users.deleted
`

type InsertWalletParams struct {
	ID         persist.DBID       `db:"id" json:"id"`
	Address    persist.Address    `db:"address" json:"address"`
	Chain      persist.Chain      `db:"chain" json:"chain"`
	WalletType persist.WalletType `db:"wallet_type" json:"wallet_type"`
	UserID     persist.DBID       `db:"user_id" json:"user_id"`
}

func (q *Queries) InsertWallet(ctx context.Context, arg InsertWalletParams) error {
	_, err := q.db.Exec(ctx, insertWallet,
		arg.ID,
		arg.Address,
		arg.Chain,
		arg.WalletType,
		arg.UserID,
	)
	return err
}

const invalidateSession = `-- name: InvalidateSession :exec
update sessions set invalidated = true, active_until = least(active_until, now()), last_updated = now() where id = $1 and deleted = false and invalidated = false
`

func (q *Queries) InvalidateSession(ctx context.Context, id persist.DBID) error {
	_, err := q.db.Exec(ctx, invalidateSession, id)
	return err
}

const isActorActionActive = `-- name: IsActorActionActive :one
select exists(
    select 1 from events where deleted = false
                           and actor_id = $1
                           and action = any($2)
                           and created_at > $3 and created_at <= $4
)
`

type IsActorActionActiveParams struct {
	ActorID     sql.NullString     `db:"actor_id" json:"actor_id"`
	Actions     persist.ActionList `db:"actions" json:"actions"`
	WindowStart time.Time          `db:"window_start" json:"window_start"`
	WindowEnd   time.Time          `db:"window_end" json:"window_end"`
}

func (q *Queries) IsActorActionActive(ctx context.Context, arg IsActorActionActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorActionActive,
		arg.ActorID,
		arg.Actions,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSplitActive = `-- name: IsActorSplitActive :one
select exists(
    select 1 from events where deleted = false
                           and actor_id = $1
                           and split_id = $2
                           and created_at > $3 and created_at <= $4
)
`

type IsActorSplitActiveParams struct {
	ActorID     sql.NullString `db:"actor_id" json:"actor_id"`
	SplitID     persist.DBID   `db:"split_id" json:"split_id"`
	WindowStart time.Time      `db:"window_start" json:"window_start"`
	WindowEnd   time.Time      `db:"window_end" json:"window_end"`
}

func (q *Queries) IsActorSplitActive(ctx context.Context, arg IsActorSplitActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSplitActive,
		arg.ActorID,
		arg.SplitID,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSubjectActionActive = `-- name: IsActorSubjectActionActive :one
select exists(
    select 1 from events where deleted = false
                           and actor_id = $1
                           and subject_id = $2
                           and action = any($3)
                           and created_at > $4 and created_at <= $5
)
`

type IsActorSubjectActionActiveParams struct {
	ActorID     sql.NullString     `db:"actor_id" json:"actor_id"`
	SubjectID   persist.DBID       `db:"subject_id" json:"subject_id"`
	Actions     persist.ActionList `db:"actions" json:"actions"`
	WindowStart time.Time          `db:"window_start" json:"window_start"`
	WindowEnd   time.Time          `db:"window_end" json:"window_end"`
}

func (q *Queries) IsActorSubjectActionActive(ctx context.Context, arg IsActorSubjectActionActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSubjectActionActive,
		arg.ActorID,
		arg.SubjectID,
		arg.Actions,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSubjectActive = `-- name: IsActorSubjectActive :one
select exists(
    select 1 from events where deleted = false
                           and actor_id = $1
                           and subject_id = $2
                           and created_at > $3 and created_at <= $4
)
`

type IsActorSubjectActiveParams struct {
	ActorID     sql.NullString `db:"actor_id" json:"actor_id"`
	SubjectID   persist.DBID   `db:"subject_id" json:"subject_id"`
	WindowStart time.Time      `db:"window_start" json:"window_start"`
	WindowEnd   time.Time      `db:"window_end" json:"window_end"`
}

func (q *Queries) IsActorSubjectActive(ctx context.Context, arg IsActorSubjectActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSubjectActive,
		arg.ActorID,
		arg.SubjectID,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const unblockUser = `-- name: UnblockUser :exec
update user_blocklist set active = false, last_updated = now() where user_id = $1 and blocked_user_id = $2 and not deleted
`

type UnblockUserParams struct {
	UserID        persist.DBID `db:"user_id" json:"user_id"`
	BlockedUserID persist.DBID `db:"blocked_user_id" json:"blocked_user_id"`
}

func (q *Queries) UnblockUser(ctx context.Context, arg UnblockUserParams) error {
	_, err := q.db.Exec(ctx, unblockUser, arg.UserID, arg.BlockedUserID)
	return err
}

const updateEventCaptionByGroup = `-- name: UpdateEventCaptionByGroup :exec
update events set caption = $1 where group_id = $2 and deleted = false
`

type UpdateEventCaptionByGroupParams struct {
	Caption sql.NullString `db:"caption" json:"caption"`
	GroupID sql.NullString `db:"group_id" json:"group_id"`
}

func (q *Queries) UpdateEventCaptionByGroup(ctx context.Context, arg UpdateEventCaptionByGroupParams) error {
	_, err := q.db.Exec(ctx, updateEventCaptionByGroup, arg.Caption, arg.GroupID)
	return err
}

const updateNotification = `-- name: UpdateNotification :exec
UPDATE notifications SET data = $2, event_ids = event_ids || $3, amount = $4, last_updated = now(), seen = false WHERE id = $1 AND deleted = false AND NOT amount = $4
`

type UpdateNotificationParams struct {
	ID       persist.DBID             `db:"id" json:"id"`
	Data     persist.NotificationData `db:"data" json:"data"`
	EventIds persist.DBIDList         `db:"event_ids" json:"event_ids"`
	Amount   int32                    `db:"amount" json:"amount"`
}

func (q *Queries) UpdateNotification(ctx context.Context, arg UpdateNotificationParams) error {
	_, err := q.db.Exec(ctx, updateNotification,
		arg.ID,
		arg.Data,
		arg.EventIds,
		arg.Amount,
	)
	return err
}

const updateNotificationSettingsByID = `-- name: UpdateNotificationSettingsByID :exec
UPDATE users SET notification_settings = $2 WHERE id = $1
`

type UpdateNotificationSettingsByIDParams struct {
	ID                   persist.DBID                     `db:"id" json:"id"`
	NotificationSettings persist.UserNotificationSettings `db:"notification_settings" json:"notification_settings"`
}

func (q *Queries) UpdateNotificationSettingsByID(ctx context.Context, arg UpdateNotificationSettingsByIDParams) error {
	_, err := q.db.Exec(ctx, updateNotificationSettingsByID, arg.ID, arg.NotificationSettings)
	return err
}

const updatePushTickets = `-- name: UpdatePushTickets :exec
with updates as (
    select unnest($1::text[]) as id, unnest($2::timestamptz[]) as check_after, unnest($3::int[]) as num_check_attempts, unnest($4::text[]) as status, unnest($5::bool[]) as deleted
)
update push_notification_tickets t set check_after = updates.check_after, num_check_attempts = updates.num_check_attempts, status = updates.status, deleted = updates.deleted from updates where t.id = updates.id and t.deleted = false
`

type UpdatePushTicketsParams struct {
	Ids              []string    `db:"ids" json:"ids"`
	CheckAfter       []time.Time `db:"check_after" json:"check_after"`
	NumCheckAttempts []int32     `db:"num_check_attempts" json:"num_check_attempts"`
	Status           []string    `db:"status" json:"status"`
	Deleted          []bool      `db:"deleted" json:"deleted"`
}

func (q *Queries) UpdatePushTickets(ctx context.Context, arg UpdatePushTicketsParams) error {
	_, err := q.db.Exec(ctx, updatePushTickets,
		arg.Ids,
		arg.CheckAfter,
		arg.NumCheckAttempts,
		arg.Status,
		arg.Deleted,
	)
	return err
}

const updateSplitInfo = `-- name: UpdateSplitInfo :exec
/*
// name: UpdateSplitHidden :one
update splits set hidden = @hidden, last_updated = now() where id = @id and deleted = false returning *;
*/

update splits set name = case when $1::bool then $2 else name end, description = case when $3::bool then $4 else description end, logo_url = case when $5::bool then $6 else logo_url end, last_updated = now() where id = $7 and deleted = false
`

type UpdateSplitInfoParams struct {
	NameSet        bool           `db:"name_set" json:"name_set"`
	Name           string         `db:"name" json:"name"`
	DescriptionSet bool           `db:"description_set" json:"description_set"`
	Description    string         `db:"description" json:"description"`
	LogoUrlSet     bool           `db:"logo_url_set" json:"logo_url_set"`
	LogoUrl        sql.NullString `db:"logo_url" json:"logo_url"`
	ID             persist.DBID   `db:"id" json:"id"`
}

func (q *Queries) UpdateSplitInfo(ctx context.Context, arg UpdateSplitInfoParams) error {
	_, err := q.db.Exec(ctx, updateSplitInfo,
		arg.NameSet,
		arg.Name,
		arg.DescriptionSet,
		arg.Description,
		arg.LogoUrlSet,
		arg.LogoUrl,
		arg.ID,
	)
	return err
}

const updateSplitShares = `-- name: UpdateSplitShares :exec
with updates as (
    select unnest($1::text[]) as split_id, unnest($2::text[]) as recipient_address, unnest($3::int[]) as ownership
)
update recipients r set ownership = updates.ownership, last_updated = now() from updates where r.split_id = updates.split_id and r.address = updates.recipient_address
`

type UpdateSplitSharesParams struct {
	SplitIds           []string `db:"split_ids" json:"split_ids"`
	RecipientAddresses []string `db:"recipient_addresses" json:"recipient_addresses"`
	Ownerships         []int32  `db:"ownerships" json:"ownerships"`
}

func (q *Queries) UpdateSplitShares(ctx context.Context, arg UpdateSplitSharesParams) error {
	_, err := q.db.Exec(ctx, updateSplitShares, arg.SplitIds, arg.RecipientAddresses, arg.Ownerships)
	return err
}

const updateUserEmailUnsubscriptions = `-- name: UpdateUserEmailUnsubscriptions :exec
UPDATE users SET email_unsubscriptions = $2 WHERE id = $1
`

type UpdateUserEmailUnsubscriptionsParams struct {
	ID                   persist.DBID                 `db:"id" json:"id"`
	EmailUnsubscriptions persist.EmailUnsubscriptions `db:"email_unsubscriptions" json:"email_unsubscriptions"`
}

func (q *Queries) UpdateUserEmailUnsubscriptions(ctx context.Context, arg UpdateUserEmailUnsubscriptionsParams) error {
	_, err := q.db.Exec(ctx, updateUserEmailUnsubscriptions, arg.ID, arg.EmailUnsubscriptions)
	return err
}

const updateUserExperience = `-- name: UpdateUserExperience :exec
update users set user_experiences = user_experiences || $1 where id = $2
`

type UpdateUserExperienceParams struct {
	Experience pgtype.JSONB `db:"experience" json:"experience"`
	UserID     persist.DBID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUserExperience(ctx context.Context, arg UpdateUserExperienceParams) error {
	_, err := q.db.Exec(ctx, updateUserExperience, arg.Experience, arg.UserID)
	return err
}

const updateUserPrimaryWallet = `-- name: UpdateUserPrimaryWallet :exec
update users set primary_wallet_id = $1 from wallets
where users.id = $2 and wallets.id = $1
  and wallets.id = any(users.wallets) and wallets.deleted = false
`

type UpdateUserPrimaryWalletParams struct {
	WalletID persist.DBID `db:"wallet_id" json:"wallet_id"`
	UserID   persist.DBID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUserPrimaryWallet(ctx context.Context, arg UpdateUserPrimaryWalletParams) error {
	_, err := q.db.Exec(ctx, updateUserPrimaryWallet, arg.WalletID, arg.UserID)
	return err
}

const updateUserUnverifiedEmail = `-- name: UpdateUserUnverifiedEmail :exec
insert into pii.for_users (user_id, pii_unverified_email_address, pii_verified_email_address) values ($1, $2, null)
on conflict (user_id) do update
    set pii_unverified_email_address = excluded.pii_unverified_email_address,
        pii_verified_email_address = excluded.pii_verified_email_address
`

type UpdateUserUnverifiedEmailParams struct {
	UserID       persist.DBID  `db:"user_id" json:"user_id"`
	EmailAddress persist.Email `db:"email_address" json:"email_address"`
}

func (q *Queries) UpdateUserUnverifiedEmail(ctx context.Context, arg UpdateUserUnverifiedEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserUnverifiedEmail, arg.UserID, arg.EmailAddress)
	return err
}

const updateUserVerifiedEmail = `-- name: UpdateUserVerifiedEmail :exec
insert into pii.for_users (user_id, pii_unverified_email_address, pii_verified_email_address) values ($1, null, $2)
on conflict (user_id) do update
    set pii_verified_email_address = excluded.pii_verified_email_address,
        pii_unverified_email_address = excluded.pii_unverified_email_address
`

type UpdateUserVerifiedEmailParams struct {
	UserID       persist.DBID  `db:"user_id" json:"user_id"`
	EmailAddress persist.Email `db:"email_address" json:"email_address"`
}

func (q *Queries) UpdateUserVerifiedEmail(ctx context.Context, arg UpdateUserVerifiedEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserVerifiedEmail, arg.UserID, arg.EmailAddress)
	return err
}

const upsertSession = `-- name: UpsertSession :one
insert into sessions (id, user_id,
                      created_at, created_with_user_agent, created_with_platform, created_with_os,
                      last_refreshed, last_user_agent, last_platform, last_os, current_refresh_id, active_until, invalidated, last_updated, deleted)
values ($1, $2, now(), $3, $4, $5, now(), $3, $4, $5, $6, $7, false, now(), false)
on conflict (id) where deleted = false do update set
                                                     last_refreshed = case when sessions.invalidated then sessions.last_refreshed else excluded.last_refreshed end,
                                                     last_user_agent = case when sessions.invalidated then sessions.last_user_agent else excluded.last_user_agent end,
                                                     last_platform = case when sessions.invalidated then sessions.last_platform else excluded.last_platform end,
                                                     last_os = case when sessions.invalidated then sessions.last_os else excluded.last_os end,
                                                     current_refresh_id = case when sessions.invalidated then sessions.current_refresh_id else excluded.current_refresh_id end,
                                                     last_updated = case when sessions.invalidated then sessions.last_updated else excluded.last_updated end,
                                                     active_until = case when sessions.invalidated then sessions.active_until else greatest(sessions.active_until, excluded.active_until) end
returning id, user_id, created_at, created_with_user_agent, created_with_platform, created_with_os, last_refreshed, last_user_agent, last_platform, last_os, current_refresh_id, active_until, invalidated, last_updated, deleted
`

type UpsertSessionParams struct {
	ID               persist.DBID `db:"id" json:"id"`
	UserID           persist.DBID `db:"user_id" json:"user_id"`
	UserAgent        string       `db:"user_agent" json:"user_agent"`
	Platform         string       `db:"platform" json:"platform"`
	Os               string       `db:"os" json:"os"`
	CurrentRefreshID persist.DBID `db:"current_refresh_id" json:"current_refresh_id"`
	ActiveUntil      time.Time    `db:"active_until" json:"active_until"`
}

func (q *Queries) UpsertSession(ctx context.Context, arg UpsertSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, upsertSession,
		arg.ID,
		arg.UserID,
		arg.UserAgent,
		arg.Platform,
		arg.Os,
		arg.CurrentRefreshID,
		arg.ActiveUntil,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.CreatedWithUserAgent,
		&i.CreatedWithPlatform,
		&i.CreatedWithOs,
		&i.LastRefreshed,
		&i.LastUserAgent,
		&i.LastPlatform,
		&i.LastOs,
		&i.CurrentRefreshID,
		&i.ActiveUntil,
		&i.Invalidated,
		&i.LastUpdated,
		&i.Deleted,
	)
	return i, err
}
