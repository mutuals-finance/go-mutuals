// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package coredb

import (
	"context"
	"database/sql"
	"time"

	"github.com/SplitFi/go-splitfi/service/persist"
	"github.com/jackc/pgtype"
)

const addPiiAccountCreationInfo = `-- name: AddPiiAccountCreationInfo :exec
insert into pii.account_creation_info (user_id, ip_address, created_at) values ($1, $2, now())
  on conflict do nothing
`

type AddPiiAccountCreationInfoParams struct {
	UserID    persist.DBID
	IpAddress string
}

func (q *Queries) AddPiiAccountCreationInfo(ctx context.Context, arg AddPiiAccountCreationInfoParams) error {
	_, err := q.db.Exec(ctx, addPiiAccountCreationInfo, arg.UserID, arg.IpAddress)
	return err
}

const addSocialToUser = `-- name: AddSocialToUser :exec
insert into pii.for_users (user_id, pii_socials) values ($1, $2) on conflict (user_id) where deleted = false do update set pii_socials = for_users.pii_socials || $2
`

type AddSocialToUserParams struct {
	UserID  persist.DBID
	Socials persist.Socials
}

func (q *Queries) AddSocialToUser(ctx context.Context, arg AddSocialToUserParams) error {
	_, err := q.db.Exec(ctx, addSocialToUser, arg.UserID, arg.Socials)
	return err
}

const addUserRoles = `-- name: AddUserRoles :exec
insert into user_roles (id, user_id, role, created_at, last_updated)
select unnest($2::varchar[]), $1, unnest($3::varchar[]), now(), now()
on conflict (user_id, role) do update set deleted = false, last_updated = now()
`

type AddUserRolesParams struct {
	UserID persist.DBID
	Ids    []string
	Roles  []string
}

func (q *Queries) AddUserRoles(ctx context.Context, arg AddUserRolesParams) error {
	_, err := q.db.Exec(ctx, addUserRoles, arg.UserID, arg.Ids, arg.Roles)
	return err
}

const clearNotificationsForUser = `-- name: ClearNotificationsForUser :many
UPDATE notifications SET seen = true WHERE owner_id = $1 AND seen = false RETURNING id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount
`

func (q *Queries) ClearNotificationsForUser(ctx context.Context, ownerID persist.DBID) ([]Notification, error) {
	rows, err := q.db.Query(ctx, clearNotificationsForUser, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countSocialConnections = `-- name: CountSocialConnections :one
select count(*)
from (select unnest($1::varchar[]) as social_id) as s
    inner join pii.user_view on user_view.pii_socials->$2::text->>'id'::varchar = s.social_id and user_view.deleted = false
where case when $3::bool then true end
`

type CountSocialConnectionsParams struct {
	SocialIds       []string
	Social          string
	OnlyUnfollowing bool
}

func (q *Queries) CountSocialConnections(ctx context.Context, arg CountSocialConnectionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSocialConnections, arg.SocialIds, arg.Social, arg.OnlyUnfollowing)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserNotifications = `-- name: CountUserNotifications :one
SELECT count(*) FROM notifications WHERE owner_id = $1 AND deleted = false
`

func (q *Queries) CountUserNotifications(ctx context.Context, ownerID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserNotifications, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserUnseenNotifications = `-- name: CountUserUnseenNotifications :one
SELECT count(*) FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false
`

func (q *Queries) CountUserUnseenNotifications(ctx context.Context, ownerID persist.DBID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserUnseenNotifications, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSplitEvent = `-- name: CreateSplitEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, split_id, subject_id, data, external_id, group_id, caption) VALUES ($1, $2, $3, $4, $5, $5, $6, $7, $8, $9) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id
`

type CreateSplitEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	SplitID        persist.DBID
	Data           persist.EventData
	ExternalID     sql.NullString
	GroupID        sql.NullString
	Caption        sql.NullString
}

func (q *Queries) CreateSplitEvent(ctx context.Context, arg CreateSplitEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createSplitEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.SplitID,
		arg.Data,
		arg.ExternalID,
		arg.GroupID,
		arg.Caption,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.SplitID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const createTokenEvent = `-- name: CreateTokenEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, token_id, subject_id, data, group_id, caption, split_id) VALUES ($1, $2, $3, $4, $5, $5, $6, $7, $8, $9) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id
`

type CreateTokenEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	TokenID        persist.DBID
	Data           persist.EventData
	GroupID        sql.NullString
	Caption        sql.NullString
	SplitID        persist.DBID
}

func (q *Queries) CreateTokenEvent(ctx context.Context, arg CreateTokenEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createTokenEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.TokenID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
		arg.SplitID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.SplitID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const createUserEvent = `-- name: CreateUserEvent :one
INSERT INTO events (id, actor_id, action, resource_type_id, user_id, subject_id, data, group_id, caption) VALUES ($1, $2, $3, $4, $5, $5, $6, $7, $8) RETURNING id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id
`

type CreateUserEventParams struct {
	ID             persist.DBID
	ActorID        sql.NullString
	Action         persist.Action
	ResourceTypeID persist.ResourceType
	UserID         persist.DBID
	Data           persist.EventData
	GroupID        sql.NullString
	Caption        sql.NullString
}

func (q *Queries) CreateUserEvent(ctx context.Context, arg CreateUserEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createUserEvent,
		arg.ID,
		arg.ActorID,
		arg.Action,
		arg.ResourceTypeID,
		arg.UserID,
		arg.Data,
		arg.GroupID,
		arg.Caption,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.SplitID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
update user_roles set deleted = true, last_updated = now() where user_id = $1 and role = any($2)
`

type DeleteUserRolesParams struct {
	UserID persist.DBID
	Roles  persist.RoleList
}

func (q *Queries) DeleteUserRoles(ctx context.Context, arg DeleteUserRolesParams) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, arg.UserID, arg.Roles)
	return err
}

const getActorForGroup = `-- name: GetActorForGroup :one
select actor_id from events where group_id = $1 and deleted = false order by(created_at, id) asc limit 1
`

func (q *Queries) GetActorForGroup(ctx context.Context, groupID sql.NullString) (sql.NullString, error) {
	row := q.db.QueryRow(ctx, getActorForGroup, groupID)
	var actor_id sql.NullString
	err := row.Scan(&actor_id)
	return actor_id, err
}

const getAssetsByChainAddress = `-- name: GetAssetsByChainAddress :many
SELECT a.id, a.version, a.last_updated, a.created_at, a.token_id, a.owner_address, a.balance, a.block_number FROM assets a
    LEFT JOIN tokens t
    ON a.token_id = t.id
    WHERE a.owner_address = $1 AND t.chain = $2 AND t.deleted = false
    ORDER BY a.balance
`

type GetAssetsByChainAddressParams struct {
	OwnerAddress persist.Address
	Chain        persist.Chain
}

func (q *Queries) GetAssetsByChainAddress(ctx context.Context, arg GetAssetsByChainAddressParams) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssetsByChainAddress, arg.OwnerAddress, arg.Chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.TokenID,
			&i.OwnerAddress,
			&i.Balance,
			&i.BlockNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetsBySplitChainAddressPaginate = `-- name: GetAssetsBySplitChainAddressPaginate :many
/*
TODO pagination for assets per split
SELECT t.* FROM tokens t
                    JOIN users u ON u.id = t.owner_user_id
WHERE t.contract = $1 AND t.deleted = false
  AND (NOT @splitfi_users_only::bool OR u.universal = false)
  AND (u.universal,t.created_at,t.id) < (@cur_before_universal, @cur_before_time::timestamptz, @cur_before_id)
  AND (u.universal,t.created_at,t.id) > (@cur_after_universal, @cur_after_time::timestamptz, @cur_after_id)
ORDER BY CASE WHEN @paging_forward::bool THEN (u.universal,t.created_at,t.id) END ASC,
         CASE WHEN NOT @paging_forward::bool THEN (u.universal,t.created_at,t.id) END DESC
LIMIT $2;

SELECT t.* FROM tokens t
                    JOIN users u ON u.id = t.owner_user_id
WHERE t.contract = sqlc.arg('contract') AND t.deleted = false
  AND (NOT @splitfi_users_only::bool OR u.universal = false)
  AND (u.universal,t.created_at,t.id) < (@cur_before_universal, @cur_before_time::timestamptz, @cur_before_id)
  AND (u.universal,t.created_at,t.id) > (@cur_after_universal, @cur_after_time::timestamptz, @cur_after_id)
ORDER BY CASE WHEN @paging_forward::bool THEN (u.universal,t.created_at,t.id) END ASC,
         CASE WHEN NOT @paging_forward::bool THEN (u.universal,t.created_at,t.id) END DESC
LIMIT sqlc.arg('limit');

SELECT count(*) FROM tokens JOIN users ON users.id = tokens.owner_user_id WHERE contract = $1 AND (NOT @splitfi_users_only::bool OR users.universal = false) AND tokens.deleted = false;
*/

SELECT id, created_at, last_updated, deleted, version, address, wallet_type, chain FROM wallets WHERE id = $1 AND deleted = false
`

func (q *Queries) GetAssetsBySplitChainAddressPaginate(ctx context.Context, id persist.DBID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getAssetsBySplitChainAddressPaginate, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentTime = `-- name: GetCurrentTime :one
select now()::timestamptz
`

func (q *Queries) GetCurrentTime(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRow(ctx, getCurrentTime)
	var column_1 time.Time
	err := row.Scan(&column_1)
	return column_1, err
}

const getEvent = `-- name: GetEvent :one
SELECT id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id FROM events WHERE id = $1 AND deleted = false
`

func (q *Queries) GetEvent(ctx context.Context, id persist.DBID) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ActorID,
		&i.ResourceTypeID,
		&i.SubjectID,
		&i.UserID,
		&i.TokenID,
		&i.Action,
		&i.Data,
		&i.Deleted,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.SplitID,
		&i.ExternalID,
		&i.Caption,
		&i.GroupID,
	)
	return i, err
}

const getEventsInGroup = `-- name: GetEventsInGroup :many
select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where group_id = $1 and deleted = false order by(created_at, id) asc
`

func (q *Queries) GetEventsInGroup(ctx context.Context, groupID sql.NullString) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.TokenID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.SplitID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsInWindow = `-- name: GetEventsInWindow :many
with recursive activity as (
    select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where events.id = $1 and deleted = false
    union
    select e.id, e.version, e.actor_id, e.resource_type_id, e.subject_id, e.user_id, e.token_id, e.action, e.data, e.deleted, e.last_updated, e.created_at, e.split_id, e.external_id, e.caption, e.group_id from events e, activity a
    where e.actor_id = a.actor_id
        and e.action = any($3)
        and e.created_at < a.created_at
        and e.created_at >= a.created_at - make_interval(secs => $2)
        and e.deleted = false
        and e.caption is null
        and (not $4::bool or e.subject_id = a.subject_id)
)
select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where id = any(select id from activity) order by (created_at, id) asc
`

type GetEventsInWindowParams struct {
	ID             persist.DBID
	Secs           float64
	Actions        persist.ActionList
	IncludeSubject bool
}

func (q *Queries) GetEventsInWindow(ctx context.Context, arg GetEventsInWindowParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsInWindow,
		arg.ID,
		arg.Secs,
		arg.Actions,
		arg.IncludeSubject,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.TokenID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.SplitID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRecentNotificationByOwnerIDForAction = `-- name: GetMostRecentNotificationByOwnerIDForAction :one
select id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount from notifications
    where owner_id = $1
    and action = $2
    and deleted = false
    order by created_at desc
    limit 1
`

type GetMostRecentNotificationByOwnerIDForActionParams struct {
	OwnerID persist.DBID
	Action  persist.Action
}

func (q *Queries) GetMostRecentNotificationByOwnerIDForAction(ctx context.Context, arg GetMostRecentNotificationByOwnerIDForActionParams) (Notification, error) {
	row := q.db.QueryRow(ctx, getMostRecentNotificationByOwnerIDForAction, arg.OwnerID, arg.Action)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.SplitID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE id = $1 AND deleted = false
`

func (q *Queries) GetNotificationByID(ctx context.Context, id persist.DBID) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.OwnerID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Action,
		&i.Data,
		&i.EventIds,
		&i.SplitID,
		&i.Seen,
		&i.Amount,
	)
	return i, err
}

const getNotificationsByOwnerIDForActionAfter = `-- name: GetNotificationsByOwnerIDForActionAfter :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications
    WHERE owner_id = $1 AND action = $2 AND deleted = false AND created_at > $3
    ORDER BY created_at DESC
`

type GetNotificationsByOwnerIDForActionAfterParams struct {
	OwnerID      persist.DBID
	Action       persist.Action
	CreatedAfter time.Time
}

func (q *Queries) GetNotificationsByOwnerIDForActionAfter(ctx context.Context, arg GetNotificationsByOwnerIDForActionAfterParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByOwnerIDForActionAfter, arg.OwnerID, arg.Action, arg.CreatedAfter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentUnseenNotifications = `-- name: GetRecentUnseenNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false and created_at > $2 order by created_at desc limit $3
`

type GetRecentUnseenNotificationsParams struct {
	OwnerID      persist.DBID
	CreatedAfter time.Time
	Lim          int32
}

func (q *Queries) GetRecentUnseenNotifications(ctx context.Context, arg GetRecentUnseenNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getRecentUnseenNotifications, arg.OwnerID, arg.CreatedAfter, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSocialAuthByUserID = `-- name: GetSocialAuthByUserID :one
select id, deleted, version, created_at, last_updated, user_id, provider, access_token, refresh_token from pii.socials_auth where user_id = $1 and provider = $2 and deleted = false
`

type GetSocialAuthByUserIDParams struct {
	UserID   persist.DBID
	Provider persist.SocialProvider
}

func (q *Queries) GetSocialAuthByUserID(ctx context.Context, arg GetSocialAuthByUserIDParams) (PiiSocialsAuth, error) {
	row := q.db.QueryRow(ctx, getSocialAuthByUserID, arg.UserID, arg.Provider)
	var i PiiSocialsAuth
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.UserID,
		&i.Provider,
		&i.AccessToken,
		&i.RefreshToken,
	)
	return i, err
}

const getSocialConnections = `-- name: GetSocialConnections :many
select s.social_id, s.social_username, s.social_displayname, s.social_profile_image, user_view.id as user_id, user_view.created_at as user_created_at, (f.id is not null)::bool as already_following
from (select unnest($1::varchar[]) as social_id, unnest($2::varchar[]) as social_username, unnest($3::varchar[]) as social_displayname, unnest($4::varchar[]) as social_profile_image) as s
    inner join pii.user_view on user_view.pii_socials->$5::text->>'id'::varchar = s.social_id and user_view.deleted = false
where case when $6::bool then true end
order by (true,user_view.created_at,user_view.id)
`

type GetSocialConnectionsParams struct {
	SocialIds           []string
	SocialUsernames     []string
	SocialDisplaynames  []string
	SocialProfileImages []string
	Social              string
	OnlyUnfollowing     bool
}

type GetSocialConnectionsRow struct {
	SocialID           interface{}
	SocialUsername     interface{}
	SocialDisplayname  interface{}
	SocialProfileImage interface{}
	UserID             persist.DBID
	UserCreatedAt      time.Time
	AlreadyFollowing   bool
}

func (q *Queries) GetSocialConnections(ctx context.Context, arg GetSocialConnectionsParams) ([]GetSocialConnectionsRow, error) {
	rows, err := q.db.Query(ctx, getSocialConnections,
		arg.SocialIds,
		arg.SocialUsernames,
		arg.SocialDisplaynames,
		arg.SocialProfileImages,
		arg.Social,
		arg.OnlyUnfollowing,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSocialConnectionsRow
	for rows.Next() {
		var i GetSocialConnectionsRow
		if err := rows.Scan(
			&i.SocialID,
			&i.SocialUsername,
			&i.SocialDisplayname,
			&i.SocialProfileImage,
			&i.UserID,
			&i.UserCreatedAt,
			&i.AlreadyFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSocialConnectionsPaginate = `-- name: GetSocialConnectionsPaginate :many
select s.social_id, s.social_username, s.social_displayname, s.social_profile_image, user_view.id as user_id, user_view.created_at as user_created_at, (f.id is not null)::bool as already_following
from (select unnest($2::varchar[]) as social_id, unnest($3::varchar[]) as social_username, unnest($4::varchar[]) as social_displayname, unnest($5::varchar[]) as social_profile_image) as s
    inner join pii.user_view on user_view.pii_socials->$6::text->>'id'::varchar = s.social_id and user_view.deleted = false
where case when $7::bool then true end
order by case when $8::bool then (true,user_view.created_at,user_view.id) end asc,
    case when not $8::bool then (true,user_view.created_at,user_view.id) end desc
limit $1
`

type GetSocialConnectionsPaginateParams struct {
	Limit               int32
	SocialIds           []string
	SocialUsernames     []string
	SocialDisplaynames  []string
	SocialProfileImages []string
	Social              string
	OnlyUnfollowing     bool
	PagingForward       bool
}

type GetSocialConnectionsPaginateRow struct {
	SocialID           interface{}
	SocialUsername     interface{}
	SocialDisplayname  interface{}
	SocialProfileImage interface{}
	UserID             persist.DBID
	UserCreatedAt      time.Time
	AlreadyFollowing   bool
}

// this query will take in enough info to create a sort of fake table of social accounts matching them up to users in split with twitter connected.
// it will also go and search for whether the specified user follows any of the users returned
func (q *Queries) GetSocialConnectionsPaginate(ctx context.Context, arg GetSocialConnectionsPaginateParams) ([]GetSocialConnectionsPaginateRow, error) {
	rows, err := q.db.Query(ctx, getSocialConnectionsPaginate,
		arg.Limit,
		arg.SocialIds,
		arg.SocialUsernames,
		arg.SocialDisplaynames,
		arg.SocialProfileImages,
		arg.Social,
		arg.OnlyUnfollowing,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSocialConnectionsPaginateRow
	for rows.Next() {
		var i GetSocialConnectionsPaginateRow
		if err := rows.Scan(
			&i.SocialID,
			&i.SocialUsername,
			&i.SocialDisplayname,
			&i.SocialProfileImage,
			&i.UserID,
			&i.UserCreatedAt,
			&i.AlreadyFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSocialsByUserID = `-- name: GetSocialsByUserID :one
select pii_socials from pii.user_view where id = $1
`

func (q *Queries) GetSocialsByUserID(ctx context.Context, id persist.DBID) (persist.Socials, error) {
	row := q.db.QueryRow(ctx, getSocialsByUserID, id)
	var pii_socials persist.Socials
	err := row.Scan(&pii_socials)
	return pii_socials, err
}

const getSplitByChainAddress = `-- name: GetSplitByChainAddress :one
SELECT id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership FROM splits WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetSplitByChainAddressParams struct {
	Address persist.Address
	Chain   persist.Chain
}

func (q *Queries) GetSplitByChainAddress(ctx context.Context, arg GetSplitByChainAddressParams) (Split, error) {
	row := q.db.QueryRow(ctx, getSplitByChainAddress, arg.Address, arg.Chain)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Deleted,
		&i.Chain,
		&i.Address,
		&i.Name,
		&i.Description,
		&i.CreatorAddress,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.BadgeUrl,
		&i.TotalOwnership,
	)
	return i, err
}

const getSplitById = `-- name: GetSplitById :one
SELECT id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership FROM splits WHERE id = $1 AND deleted = false
`

func (q *Queries) GetSplitById(ctx context.Context, id persist.DBID) (Split, error) {
	row := q.db.QueryRow(ctx, getSplitById, id)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Deleted,
		&i.Chain,
		&i.Address,
		&i.Name,
		&i.Description,
		&i.CreatorAddress,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.BadgeUrl,
		&i.TotalOwnership,
	)
	return i, err
}

const getSplitEventsInWindow = `-- name: GetSplitEventsInWindow :many
with recursive activity as (
    select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where events.id = $1 and deleted = false
    union
    select e.id, e.version, e.actor_id, e.resource_type_id, e.subject_id, e.user_id, e.token_id, e.action, e.data, e.deleted, e.last_updated, e.created_at, e.split_id, e.external_id, e.caption, e.group_id from events e, activity a
    where e.actor_id = a.actor_id
        and e.action = any($3)
        and e.split_id = $4
        and e.created_at < a.created_at
        and e.created_at >= a.created_at - make_interval(secs => $2)
        and e.deleted = false
        and e.caption is null
        and (not $5::bool or e.subject_id = a.subject_id)
)
select id, version, actor_id, resource_type_id, subject_id, user_id, token_id, action, data, deleted, last_updated, created_at, split_id, external_id, caption, group_id from events where id = any(select id from activity) order by (created_at, id) asc
`

type GetSplitEventsInWindowParams struct {
	ID             persist.DBID
	Secs           float64
	Actions        persist.ActionList
	SplitID        persist.DBID
	IncludeSubject bool
}

func (q *Queries) GetSplitEventsInWindow(ctx context.Context, arg GetSplitEventsInWindowParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getSplitEventsInWindow,
		arg.ID,
		arg.Secs,
		arg.Actions,
		arg.SplitID,
		arg.IncludeSubject,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.ActorID,
			&i.ResourceTypeID,
			&i.SubjectID,
			&i.UserID,
			&i.TokenID,
			&i.Action,
			&i.Data,
			&i.Deleted,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.SplitID,
			&i.ExternalID,
			&i.Caption,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByChainsAndAddresses = `-- name: GetSplitsByChainsAndAddresses :many
SELECT id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership FROM splits WHERE chain = any($1::int[]) OR contract_address = any($2::varchar[]) AND deleted = false
`

type GetSplitsByChainsAndAddressesParams struct {
	Chains    []int32
	Addresses []string
}

func (q *Queries) GetSplitsByChainsAndAddresses(ctx context.Context, arg GetSplitsByChainsAndAddressesParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByChainsAndAddresses, arg.Chains, arg.Addresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Split
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByRecipientAddress = `-- name: GetSplitsByRecipientAddress :many
SELECT s.id, s.version, s.last_updated, s.created_at, s.deleted, s.chain, s.address, s.name, s.description, s.creator_address, s.logo_url, s.banner_url, s.badge_url, s.total_ownership FROM recipients r
    JOIN splits s ON s.id = r.split_id
    WHERE r.address = $1 AND s.deleted = false
`

func (q *Queries) GetSplitsByRecipientAddress(ctx context.Context, address persist.Address) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByRecipientAddress, address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Split
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByRecipientChainAddress = `-- name: GetSplitsByRecipientChainAddress :many
SELECT s.id, s.version, s.last_updated, s.created_at, s.deleted, s.chain, s.address, s.name, s.description, s.creator_address, s.logo_url, s.banner_url, s.badge_url, s.total_ownership FROM recipients r
    JOIN splits s ON s.id = r.split_id
    WHERE r.address = $1 AND s.chain = $2 AND s.deleted = false
`

type GetSplitsByRecipientChainAddressParams struct {
	Address persist.Address
	Chain   persist.Chain
}

func (q *Queries) GetSplitsByRecipientChainAddress(ctx context.Context, arg GetSplitsByRecipientChainAddressParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByRecipientChainAddress, arg.Address, arg.Chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Split
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenById = `-- name: GetTokenById :one
SELECT id, deleted, version, created_at, last_updated, name, symbol, logo, token_type, block_number, chain, contract_address FROM tokens WHERE id = $1 AND deleted = false
`

func (q *Queries) GetTokenById(ctx context.Context, id persist.DBID) (Token, error) {
	row := q.db.QueryRow(ctx, getTokenById, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Name,
		&i.Symbol,
		&i.Logo,
		&i.TokenType,
		&i.BlockNumber,
		&i.Chain,
		&i.ContractAddress,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE id = $1 AND deleted = false
`

func (q *Queries) GetUserById(ctx context.Context, id persist.DBID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailVerified,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE username_idempotent = lower($1) AND deleted = false
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailVerified,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
	)
	return i, err
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type GetUserNotificationsParams struct {
	OwnerID       persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserNotifications,
		arg.OwnerID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRolesByUserId = `-- name: GetUserRolesByUserId :many
select role from user_roles where user_id = $1 and deleted = false
union
select role from (
  select
    case when exists(
      select 1
      from tokens
      where owner_user_id = $1
        and token_id = any($2::varchar[])
       -- and contract = (select id from contracts where address = @membership_address and contracts.chain = @chain and contracts.deleted = false)
        and exists(select 1 from users where id = $1 and email_verified = 1 and deleted = false)
        and deleted = false
      )
      then $3 end as role
) r where role is not null
`

type GetUserRolesByUserIdParams struct {
	UserID                persist.DBID
	MembershipTokenIds    []string
	GrantedMembershipRole string
}

func (q *Queries) GetUserRolesByUserId(ctx context.Context, arg GetUserRolesByUserIdParams) ([]persist.Role, error) {
	rows, err := q.db.Query(ctx, getUserRolesByUserId, arg.UserID, arg.MembershipTokenIds, arg.GrantedMembershipRole)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.Role
	for rows.Next() {
		var role persist.Role
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserUnseenNotifications = `-- name: GetUserUnseenNotifications :many
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false AND seen = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $2
`

type GetUserUnseenNotificationsParams struct {
	OwnerID       persist.DBID
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUserUnseenNotifications(ctx context.Context, arg GetUserUnseenNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserUnseenNotifications,
		arg.OwnerID,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithPIIByID = `-- name: GetUserWithPIIByID :one
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences, fts_username, fts_bio_english, pii_email_address, pii_socials from pii.user_view where id = $1 and deleted = false
`

func (q *Queries) GetUserWithPIIByID(ctx context.Context, userID persist.DBID) (PiiUserView, error) {
	row := q.db.QueryRow(ctx, getUserWithPIIByID, userID)
	var i PiiUserView
	err := row.Scan(
		&i.ID,
		&i.Deleted,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Username,
		&i.UsernameIdempotent,
		&i.Wallets,
		&i.Bio,
		&i.Traits,
		&i.Universal,
		&i.NotificationSettings,
		&i.EmailVerified,
		&i.EmailUnsubscriptions,
		&i.FeaturedSplit,
		&i.PrimaryWalletID,
		&i.UserExperiences,
		&i.FtsUsername,
		&i.FtsBioEnglish,
		&i.PiiEmailAddress,
		&i.PiiSocials,
	)
	return i, err
}

const getUsersByChainAddresses = `-- name: GetUsersByChainAddresses :many
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_verified, users.email_unsubscriptions, users.featured_split, users.primary_wallet_id, users.user_experiences,wallets.address from users, wallets where wallets.address = ANY($1::varchar[]) AND wallets.chain = $2::int AND ARRAY[wallets.id] <@ users.wallets AND users.deleted = false AND wallets.deleted = false
`

type GetUsersByChainAddressesParams struct {
	Addresses []string
	Chain     int32
}

type GetUsersByChainAddressesRow struct {
	ID                   persist.DBID
	Deleted              bool
	Version              sql.NullInt32
	LastUpdated          time.Time
	CreatedAt            time.Time
	Username             sql.NullString
	UsernameIdempotent   sql.NullString
	Wallets              persist.WalletList
	Bio                  sql.NullString
	Traits               pgtype.JSONB
	Universal            bool
	NotificationSettings persist.UserNotificationSettings
	EmailVerified        persist.EmailVerificationStatus
	EmailUnsubscriptions persist.EmailUnsubscriptions
	FeaturedSplit        *persist.DBID
	PrimaryWalletID      persist.DBID
	UserExperiences      pgtype.JSONB
	Address              persist.Address
}

func (q *Queries) GetUsersByChainAddresses(ctx context.Context, arg GetUsersByChainAddressesParams) ([]GetUsersByChainAddressesRow, error) {
	rows, err := q.db.Query(ctx, getUsersByChainAddresses, arg.Addresses, arg.Chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByChainAddressesRow
	for rows.Next() {
		var i GetUsersByChainAddressesRow
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE id = ANY($2) AND deleted = false
    AND (created_at, id) < ($3, $4)
    AND (created_at, id) > ($5, $6)
    ORDER BY CASE WHEN $7::bool THEN (created_at, id) END ASC,
             CASE WHEN NOT $7::bool THEN (created_at, id) END DESC
    LIMIT $1
`

type GetUsersByIDsParams struct {
	Limit         int32
	UserIds       persist.DBIDList
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUsersByIDs(ctx context.Context, arg GetUsersByIDsParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs,
		arg.Limit,
		arg.UserIds,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByPositionPaginate = `-- name: GetUsersByPositionPaginate :many
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_verified, u.email_unsubscriptions, u.featured_split, u.primary_wallet_id, u.user_experiences from users u join unnest($1::text[]) with ordinality t(id, pos) using(id) where u.deleted = false
  and t.pos > $2::int
  and t.pos < $3::int
  order by case when $4::bool then t.pos end desc,
          case when not $4::bool then t.pos end asc
  limit $5
`

type GetUsersByPositionPaginateParams struct {
	UserIds       []string
	CurBeforePos  int32
	CurAfterPos   int32
	PagingForward bool
	Limit         int32
}

func (q *Queries) GetUsersByPositionPaginate(ctx context.Context, arg GetUsersByPositionPaginateParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByPositionPaginate,
		arg.UserIds,
		arg.CurBeforePos,
		arg.CurAfterPos,
		arg.PagingForward,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithEmailNotificationsOn = `-- name: GetUsersWithEmailNotificationsOn :many
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences, fts_username, fts_bio_english, pii_email_address, pii_socials from pii.user_view
    where (email_unsubscriptions->>'all' = 'false' or email_unsubscriptions->>'all' is null)
    and deleted = false and pii_email_address is not null and email_verified = $1
    and (created_at, id) < ($3, $4)
    and (created_at, id) > ($5, $6)
    order by case when $7::bool then (created_at, id) end asc,
             case when not $7::bool then (created_at, id) end desc
    limit $2
`

type GetUsersWithEmailNotificationsOnParams struct {
	EmailVerified persist.EmailVerificationStatus
	Limit         int32
	CurBeforeTime time.Time
	CurBeforeID   persist.DBID
	CurAfterTime  time.Time
	CurAfterID    persist.DBID
	PagingForward bool
}

// TODO: Does not appear to be used
func (q *Queries) GetUsersWithEmailNotificationsOn(ctx context.Context, arg GetUsersWithEmailNotificationsOnParams) ([]PiiUserView, error) {
	rows, err := q.db.Query(ctx, getUsersWithEmailNotificationsOn,
		arg.EmailVerified,
		arg.Limit,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PiiUserView
	for rows.Next() {
		var i PiiUserView
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.FtsUsername,
			&i.FtsBioEnglish,
			&i.PiiEmailAddress,
			&i.PiiSocials,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithEmailNotificationsOnForEmailType = `-- name: GetUsersWithEmailNotificationsOnForEmailType :many
select id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences, fts_username, fts_bio_english, pii_email_address, pii_socials from pii.user_view
    where (email_unsubscriptions->>'all' = 'false' or email_unsubscriptions->>'all' is null)
    and (email_unsubscriptions->>$3::varchar = 'false' or email_unsubscriptions->>$3::varchar is null)
    and deleted = false and pii_email_address is not null and email_verified = $1
    and (created_at, id) < ($4, $5)
    and (created_at, id) > ($6, $7)
    order by case when $8::bool then (created_at, id) end asc,
             case when not $8::bool then (created_at, id) end desc
    limit $2
`

type GetUsersWithEmailNotificationsOnForEmailTypeParams struct {
	EmailVerified       persist.EmailVerificationStatus
	Limit               int32
	EmailUnsubscription string
	CurBeforeTime       time.Time
	CurBeforeID         persist.DBID
	CurAfterTime        time.Time
	CurAfterID          persist.DBID
	PagingForward       bool
}

// for some reason this query will not allow me to use @tags for $1
func (q *Queries) GetUsersWithEmailNotificationsOnForEmailType(ctx context.Context, arg GetUsersWithEmailNotificationsOnForEmailTypeParams) ([]PiiUserView, error) {
	rows, err := q.db.Query(ctx, getUsersWithEmailNotificationsOnForEmailType,
		arg.EmailVerified,
		arg.Limit,
		arg.EmailUnsubscription,
		arg.CurBeforeTime,
		arg.CurBeforeID,
		arg.CurAfterTime,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PiiUserView
	for rows.Next() {
		var i PiiUserView
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
			&i.FtsUsername,
			&i.FtsBioEnglish,
			&i.PiiEmailAddress,
			&i.PiiSocials,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRolePaginate = `-- name: GetUsersWithRolePaginate :many
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_verified, u.email_unsubscriptions, u.featured_split, u.primary_wallet_id, u.user_experiences from users u, user_roles ur where u.deleted = false and ur.deleted = false
    and u.id = ur.user_id and ur.role = $2
    and (u.username_idempotent, u.id) < ($3::varchar, $4)
    and (u.username_idempotent, u.id) > ($5::varchar, $6)
    order by case when $7::bool then (u.username_idempotent, u.id) end asc,
             case when not $7::bool then (u.username_idempotent, u.id) end desc
    limit $1
`

type GetUsersWithRolePaginateParams struct {
	Limit         int32
	Role          persist.Role
	CurBeforeKey  string
	CurBeforeID   persist.DBID
	CurAfterKey   string
	CurAfterID    persist.DBID
	PagingForward bool
}

func (q *Queries) GetUsersWithRolePaginate(ctx context.Context, arg GetUsersWithRolePaginateParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithRolePaginate,
		arg.Limit,
		arg.Role,
		arg.CurBeforeKey,
		arg.CurBeforeID,
		arg.CurAfterKey,
		arg.CurAfterID,
		arg.PagingForward,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithTrait = `-- name: GetUsersWithTrait :many
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE (traits->$1::string) IS NOT NULL AND deleted = false
`

func (q *Queries) GetUsersWithTrait(ctx context.Context, dollar_1 string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersWithTrait, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByChainAddress = `-- name: GetWalletByChainAddress :one
SELECT wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type, wallets.chain FROM wallets WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetWalletByChainAddressParams struct {
	Address persist.Address
	Chain   persist.Chain
}

func (q *Queries) GetWalletByChainAddress(ctx context.Context, arg GetWalletByChainAddressParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByChainAddress, arg.Address, arg.Chain)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.Deleted,
		&i.Version,
		&i.Address,
		&i.WalletType,
		&i.Chain,
	)
	return i, err
}

const getWalletsByUserID = `-- name: GetWalletsByUserID :many
SELECT w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type, w.chain FROM users u, unnest(u.wallets) WITH ORDINALITY AS a(wallet_id, wallet_ord)INNER JOIN wallets w on w.id = a.wallet_id WHERE u.id = $1 AND u.deleted = false AND w.deleted = false ORDER BY a.wallet_ord
`

func (q *Queries) GetWalletsByUserID(ctx context.Context, id persist.DBID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, getWalletsByUserID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasLaterGroupedEvent = `-- name: HasLaterGroupedEvent :one
select exists(
  select 1 from events where deleted = false
  and group_id = $1
  and id > $2
)
`

type HasLaterGroupedEventParams struct {
	GroupID sql.NullString
	EventID persist.DBID
}

func (q *Queries) HasLaterGroupedEvent(ctx context.Context, arg HasLaterGroupedEventParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasLaterGroupedEvent, arg.GroupID, arg.EventID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorActionActive = `-- name: IsActorActionActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and action = any($2)
  and created_at > $3 and created_at <= $4
)
`

type IsActorActionActiveParams struct {
	ActorID     sql.NullString
	Actions     persist.ActionList
	WindowStart time.Time
	WindowEnd   time.Time
}

func (q *Queries) IsActorActionActive(ctx context.Context, arg IsActorActionActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorActionActive,
		arg.ActorID,
		arg.Actions,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSplitActive = `-- name: IsActorSplitActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and split_id = $2
  and created_at > $3 and created_at <= $4
)
`

type IsActorSplitActiveParams struct {
	ActorID     sql.NullString
	SplitID     persist.DBID
	WindowStart time.Time
	WindowEnd   time.Time
}

func (q *Queries) IsActorSplitActive(ctx context.Context, arg IsActorSplitActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSplitActive,
		arg.ActorID,
		arg.SplitID,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSubjectActionActive = `-- name: IsActorSubjectActionActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and subject_id = $2
  and action = any($3)
  and created_at > $4 and created_at <= $5
)
`

type IsActorSubjectActionActiveParams struct {
	ActorID     sql.NullString
	SubjectID   persist.DBID
	Actions     persist.ActionList
	WindowStart time.Time
	WindowEnd   time.Time
}

func (q *Queries) IsActorSubjectActionActive(ctx context.Context, arg IsActorSubjectActionActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSubjectActionActive,
		arg.ActorID,
		arg.SubjectID,
		arg.Actions,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isActorSubjectActive = `-- name: IsActorSubjectActive :one
select exists(
  select 1 from events where deleted = false
  and actor_id = $1
  and subject_id = $2
  and created_at > $3 and created_at <= $4
)
`

type IsActorSubjectActiveParams struct {
	ActorID     sql.NullString
	SubjectID   persist.DBID
	WindowStart time.Time
	WindowEnd   time.Time
}

func (q *Queries) IsActorSubjectActive(ctx context.Context, arg IsActorSubjectActiveParams) (bool, error) {
	row := q.db.QueryRow(ctx, isActorSubjectActive,
		arg.ActorID,
		arg.SubjectID,
		arg.WindowStart,
		arg.WindowEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeSocialFromUser = `-- name: RemoveSocialFromUser :exec
update pii.for_users set pii_socials = pii_socials - $1::varchar where user_id = $2
`

type RemoveSocialFromUserParams struct {
	Social string
	UserID persist.DBID
}

func (q *Queries) RemoveSocialFromUser(ctx context.Context, arg RemoveSocialFromUserParams) error {
	_, err := q.db.Exec(ctx, removeSocialFromUser, arg.Social, arg.UserID)
	return err
}

const updateEventCaptionByGroup = `-- name: UpdateEventCaptionByGroup :exec
update events set caption = $1 where group_id = $2 and deleted = false
`

type UpdateEventCaptionByGroupParams struct {
	Caption sql.NullString
	GroupID sql.NullString
}

func (q *Queries) UpdateEventCaptionByGroup(ctx context.Context, arg UpdateEventCaptionByGroupParams) error {
	_, err := q.db.Exec(ctx, updateEventCaptionByGroup, arg.Caption, arg.GroupID)
	return err
}

const updateNotification = `-- name: UpdateNotification :exec
/*
TODO example for notification creation
name: CreateViewSplitNotification :one
INSERT INTO notifications (id, owner_id, action, data, event_ids, split_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *;
*/

UPDATE notifications SET data = $2, event_ids = event_ids || $3, amount = $4, last_updated = now(), seen = false WHERE id = $1 AND deleted = false AND NOT amount = $4
`

type UpdateNotificationParams struct {
	ID       persist.DBID
	Data     persist.NotificationData
	EventIds persist.DBIDList
	Amount   int32
}

func (q *Queries) UpdateNotification(ctx context.Context, arg UpdateNotificationParams) error {
	_, err := q.db.Exec(ctx, updateNotification,
		arg.ID,
		arg.Data,
		arg.EventIds,
		arg.Amount,
	)
	return err
}

const updateNotificationSettingsByID = `-- name: UpdateNotificationSettingsByID :exec
UPDATE users SET notification_settings = $2 WHERE id = $1
`

type UpdateNotificationSettingsByIDParams struct {
	ID                   persist.DBID
	NotificationSettings persist.UserNotificationSettings
}

func (q *Queries) UpdateNotificationSettingsByID(ctx context.Context, arg UpdateNotificationSettingsByIDParams) error {
	_, err := q.db.Exec(ctx, updateNotificationSettingsByID, arg.ID, arg.NotificationSettings)
	return err
}

const updateSplitHidden = `-- name: UpdateSplitHidden :one
/*
update splits set hidden = @hidden, last_updated = now() where id = @id and deleted = false returning *;

update splits set name = case when @name_set::bool then @name else name end, description = case when @description_set::bool then @description else description end, last_updated = now() where id = @id and deleted = false;
*/

select user_experiences from users where id = $1
`

func (q *Queries) UpdateSplitHidden(ctx context.Context, id persist.DBID) (pgtype.JSONB, error) {
	row := q.db.QueryRow(ctx, updateSplitHidden, id)
	var user_experiences pgtype.JSONB
	err := row.Scan(&user_experiences)
	return user_experiences, err
}

const updateTokenMetadataFieldsByChainAddress = `-- name: UpdateTokenMetadataFieldsByChainAddress :exec
update tokens
set name = $1,
    symbol = $2,
    logo = $3,
    last_updated = now()
where contract_address = $4
  and chain = $5
  and deleted = false
`

type UpdateTokenMetadataFieldsByChainAddressParams struct {
	Name            sql.NullString
	Symbol          sql.NullString
	Logo            sql.NullString
	ContractAddress persist.Address
	Chain           persist.Chain
}

func (q *Queries) UpdateTokenMetadataFieldsByChainAddress(ctx context.Context, arg UpdateTokenMetadataFieldsByChainAddressParams) error {
	_, err := q.db.Exec(ctx, updateTokenMetadataFieldsByChainAddress,
		arg.Name,
		arg.Symbol,
		arg.Logo,
		arg.ContractAddress,
		arg.Chain,
	)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
with upsert_pii as (
    insert into pii.for_users (user_id, pii_email_address) values ($1, $2)
        on conflict (user_id) do update set pii_email_address = excluded.pii_email_address
),

upsert_metadata as (
    insert into dev_metadata_users (user_id, has_email_address) values ($1, ($2 is not null))
        on conflict (user_id) do update set has_email_address = excluded.has_email_address
)

update users set email_verified = 0 where users.id = $1
`

type UpdateUserEmailParams struct {
	UserID       persist.DBID
	EmailAddress persist.Email
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserEmail, arg.UserID, arg.EmailAddress)
	return err
}

const updateUserEmailUnsubscriptions = `-- name: UpdateUserEmailUnsubscriptions :exec
UPDATE users SET email_unsubscriptions = $2 WHERE id = $1
`

type UpdateUserEmailUnsubscriptionsParams struct {
	ID                   persist.DBID
	EmailUnsubscriptions persist.EmailUnsubscriptions
}

func (q *Queries) UpdateUserEmailUnsubscriptions(ctx context.Context, arg UpdateUserEmailUnsubscriptionsParams) error {
	_, err := q.db.Exec(ctx, updateUserEmailUnsubscriptions, arg.ID, arg.EmailUnsubscriptions)
	return err
}

const updateUserExperience = `-- name: UpdateUserExperience :exec
update users set user_experiences = user_experiences || $1 where id = $2
`

type UpdateUserExperienceParams struct {
	Experience pgtype.JSONB
	UserID     persist.DBID
}

func (q *Queries) UpdateUserExperience(ctx context.Context, arg UpdateUserExperienceParams) error {
	_, err := q.db.Exec(ctx, updateUserExperience, arg.Experience, arg.UserID)
	return err
}

const updateUserPrimaryWallet = `-- name: UpdateUserPrimaryWallet :exec
update users set primary_wallet_id = $1 from wallets
    where users.id = $2 and wallets.id = $1
    and wallets.id = any(users.wallets) and wallets.deleted = false
`

type UpdateUserPrimaryWalletParams struct {
	WalletID persist.DBID
	UserID   persist.DBID
}

func (q *Queries) UpdateUserPrimaryWallet(ctx context.Context, arg UpdateUserPrimaryWalletParams) error {
	_, err := q.db.Exec(ctx, updateUserPrimaryWallet, arg.WalletID, arg.UserID)
	return err
}

const updateUserSocials = `-- name: UpdateUserSocials :exec
update pii.for_users set pii_socials = $1 where user_id = $2
`

type UpdateUserSocialsParams struct {
	Socials persist.Socials
	UserID  persist.DBID
}

func (q *Queries) UpdateUserSocials(ctx context.Context, arg UpdateUserSocialsParams) error {
	_, err := q.db.Exec(ctx, updateUserSocials, arg.Socials, arg.UserID)
	return err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :exec
UPDATE users SET email_verified = $2 WHERE id = $1
`

type UpdateUserVerificationStatusParams struct {
	ID            persist.DBID
	EmailVerified persist.EmailVerificationStatus
}

func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserVerificationStatus, arg.ID, arg.EmailVerified)
	return err
}

const upsertSocialOAuth = `-- name: UpsertSocialOAuth :exec
insert into pii.socials_auth (id, user_id, provider, access_token, refresh_token) values ($1, $2, $3, $4, $5) on conflict (user_id, provider) where deleted = false do update set access_token = $4, refresh_token = $5, last_updated = now()
`

type UpsertSocialOAuthParams struct {
	ID           persist.DBID
	UserID       persist.DBID
	Provider     persist.SocialProvider
	AccessToken  sql.NullString
	RefreshToken sql.NullString
}

func (q *Queries) UpsertSocialOAuth(ctx context.Context, arg UpsertSocialOAuthParams) error {
	_, err := q.db.Exec(ctx, upsertSocialOAuth,
		arg.ID,
		arg.UserID,
		arg.Provider,
		arg.AccessToken,
		arg.RefreshToken,
	)
	return err
}
