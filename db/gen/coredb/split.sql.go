// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: split.sql

package coredb

import (
	"context"
	"database/sql"

	"github.com/SplitFi/go-splitfi/service/persist"
)

const splitRepoCreate = `-- name: SplitRepoCreate :one
insert into splits (id, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership) values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) returning id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership
`

type SplitRepoCreateParams struct {
	SplitID        persist.DBID    `db:"split_id" json:"split_id"`
	Chain          persist.Chain   `db:"chain" json:"chain"`
	Address        persist.Address `db:"address" json:"address"`
	Name           string          `db:"name" json:"name"`
	Description    string          `db:"description" json:"description"`
	CreatorAddress persist.Address `db:"creator_address" json:"creator_address"`
	LogoUrl        sql.NullString  `db:"logo_url" json:"logo_url"`
	BannerUrl      sql.NullString  `db:"banner_url" json:"banner_url"`
	BadgeUrl       sql.NullString  `db:"badge_url" json:"badge_url"`
	TotalOwnership int32           `db:"total_ownership" json:"total_ownership"`
}

func (q *Queries) SplitRepoCreate(ctx context.Context, arg SplitRepoCreateParams) (Split, error) {
	row := q.db.QueryRow(ctx, splitRepoCreate,
		arg.SplitID,
		arg.Chain,
		arg.Address,
		arg.Name,
		arg.Description,
		arg.CreatorAddress,
		arg.LogoUrl,
		arg.BannerUrl,
		arg.BadgeUrl,
		arg.TotalOwnership,
	)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Deleted,
		&i.Chain,
		&i.Address,
		&i.Name,
		&i.Description,
		&i.CreatorAddress,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.BadgeUrl,
		&i.TotalOwnership,
	)
	return i, err
}

const splitRepoUpdate = `-- name: SplitRepoUpdate :execrows
update splits set last_updated = now() where splits.id = $1
`

func (q *Queries) SplitRepoUpdate(ctx context.Context, splitID persist.DBID) (int64, error) {
	result, err := q.db.Exec(ctx, splitRepoUpdate, splitID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
