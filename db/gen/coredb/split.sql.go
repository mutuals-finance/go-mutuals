// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: split.sql

package coredb

import (
	"context"
	"database/sql"

	"github.com/SplitFi/go-splitfi/service/persist"
)

const splitRepoCountAllAssets = `-- name: SplitRepoCountAllAssets :one
select count(*) from assets a join tokens t on a.token_id = t.id where a.owner_address = $1 and t.deleted = false
`

func (q *Queries) SplitRepoCountAllAssets(ctx context.Context, ownerAddress persist.Address) (int64, error) {
	row := q.db.QueryRow(ctx, splitRepoCountAllAssets, ownerAddress)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const splitRepoCreate = `-- name: SplitRepoCreate :one
insert into splits (id, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership) values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) returning id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership
`

type SplitRepoCreateParams struct {
	SplitID        persist.DBID    `db:"split_id" json:"split_id"`
	Chain          persist.Chain   `db:"chain" json:"chain"`
	Address        persist.Address `db:"address" json:"address"`
	Name           string          `db:"name" json:"name"`
	Description    string          `db:"description" json:"description"`
	CreatorAddress persist.Address `db:"creator_address" json:"creator_address"`
	LogoUrl        sql.NullString  `db:"logo_url" json:"logo_url"`
	BannerUrl      sql.NullString  `db:"banner_url" json:"banner_url"`
	BadgeUrl       sql.NullString  `db:"badge_url" json:"badge_url"`
	TotalOwnership int32           `db:"total_ownership" json:"total_ownership"`
}

func (q *Queries) SplitRepoCreate(ctx context.Context, arg SplitRepoCreateParams) (Split, error) {
	row := q.db.QueryRow(ctx, splitRepoCreate,
		arg.SplitID,
		arg.Chain,
		arg.Address,
		arg.Name,
		arg.Description,
		arg.CreatorAddress,
		arg.LogoUrl,
		arg.BannerUrl,
		arg.BadgeUrl,
		arg.TotalOwnership,
	)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.LastUpdated,
		&i.CreatedAt,
		&i.Deleted,
		&i.Chain,
		&i.Address,
		&i.Name,
		&i.Description,
		&i.CreatorAddress,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.BadgeUrl,
		&i.TotalOwnership,
	)
	return i, err
}

const splitRepoGetSplitAssets = `-- name: SplitRepoGetSplitAssets :many
SELECT a.id FROM splits s
    LEFT JOIN assets a ON a.owner_address = s.address
    LEFT JOIN tokens t ON t.id = a.token_id
    WHERE s.address = $1 AND s.chain = $2 AND s.deleted = false AND t.deleted = false
    ORDER BY a.balance
`

type SplitRepoGetSplitAssetsParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) SplitRepoGetSplitAssets(ctx context.Context, arg SplitRepoGetSplitAssetsParams) ([]persist.DBID, error) {
	rows, err := q.db.Query(ctx, splitRepoGetSplitAssets, arg.Address, arg.Chain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []persist.DBID
	for rows.Next() {
		var id persist.DBID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const splitRepoUpdate = `-- name: SplitRepoUpdate :execrows
update splits set last_updated = now() where splits.id = $1
`

func (q *Queries) SplitRepoUpdate(ctx context.Context, splitID persist.DBID) (int64, error) {
	result, err := q.db.Exec(ctx, splitRepoUpdate, splitID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
