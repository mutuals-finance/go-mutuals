// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: batch.go

package coredb

import (
	"context"
	"database/sql"
	"errors"
	"time"

	"github.com/SplitFi/go-splitfi/service/persist"
	"github.com/jackc/pgx/v4"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const getAssetByIdBatch = `-- name: GetAssetByIdBatch :batchone
select a.id, a.version, a.last_updated, a.created_at, a.chain, a.token_address, a.owner_address, a.balance, a.block_number, t.id, t.deleted, t.version, t.created_at, t.last_updated, t.name, t.symbol, t.logo, t.token_type, t.block_number, t.chain, t.contract_address
from assets a join tokens t on a.token_address = t.contract_address and a.chain = t.chain
where a.id = $1 and t.deleted = false
`

type GetAssetByIdBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetAssetByIdBatchRow struct {
	Asset Asset `db:"asset" json:"asset"`
	Token Token `db:"token" json:"token"`
}

func (q *Queries) GetAssetByIdBatch(ctx context.Context, id []persist.DBID) *GetAssetByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getAssetByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAssetByIdBatchBatchResults{br, len(id), false}
}

func (b *GetAssetByIdBatchBatchResults) QueryRow(f func(int, GetAssetByIdBatchRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i GetAssetByIdBatchRow
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.Asset.ID,
			&i.Asset.Version,
			&i.Asset.LastUpdated,
			&i.Asset.CreatedAt,
			&i.Asset.Chain,
			&i.Asset.TokenAddress,
			&i.Asset.OwnerAddress,
			&i.Asset.Balance,
			&i.Asset.BlockNumber,
			&i.Token.ID,
			&i.Token.Deleted,
			&i.Token.Version,
			&i.Token.CreatedAt,
			&i.Token.LastUpdated,
			&i.Token.Name,
			&i.Token.Symbol,
			&i.Token.Logo,
			&i.Token.TokenType,
			&i.Token.BlockNumber,
			&i.Token.Chain,
			&i.Token.ContractAddress,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetAssetByIdBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getAssetByIdentifiersBatch = `-- name: GetAssetByIdentifiersBatch :batchone
select a.id, a.version, a.last_updated, a.created_at, a.chain, token_address, owner_address, balance, a.block_number, t.id, deleted, t.version, t.created_at, t.last_updated, name, symbol, logo, token_type, t.block_number, t.chain, contract_address
from assets a join tokens t on a.token_address = t.contract_address and a.chain = t.chain
where a.owner_address = $1 and a.token_address = $2 and a.chain = $3 and t.deleted = false
`

type GetAssetByIdentifiersBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetAssetByIdentifiersBatchParams struct {
	OwnerAddress persist.Address `db:"owner_address" json:"owner_address"`
	TokenAddress persist.Address `db:"token_address" json:"token_address"`
	Chain        persist.Chain   `db:"chain" json:"chain"`
}

type GetAssetByIdentifiersBatchRow struct {
	ID              persist.DBID    `db:"id" json:"id"`
	Version         sql.NullInt32   `db:"version" json:"version"`
	LastUpdated     time.Time       `db:"last_updated" json:"last_updated"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	Chain           persist.Chain   `db:"chain" json:"chain"`
	TokenAddress    persist.Address `db:"token_address" json:"token_address"`
	OwnerAddress    persist.Address `db:"owner_address" json:"owner_address"`
	Balance         sql.NullInt32   `db:"balance" json:"balance"`
	BlockNumber     sql.NullInt64   `db:"block_number" json:"block_number"`
	ID_2            persist.DBID    `db:"id_2" json:"id_2"`
	Deleted         bool            `db:"deleted" json:"deleted"`
	Version_2       sql.NullInt32   `db:"version_2" json:"version_2"`
	CreatedAt_2     time.Time       `db:"created_at_2" json:"created_at_2"`
	LastUpdated_2   time.Time       `db:"last_updated_2" json:"last_updated_2"`
	Name            sql.NullString  `db:"name" json:"name"`
	Symbol          sql.NullString  `db:"symbol" json:"symbol"`
	Logo            sql.NullString  `db:"logo" json:"logo"`
	TokenType       sql.NullString  `db:"token_type" json:"token_type"`
	BlockNumber_2   sql.NullInt64   `db:"block_number_2" json:"block_number_2"`
	Chain_2         persist.Chain   `db:"chain_2" json:"chain_2"`
	ContractAddress persist.Address `db:"contract_address" json:"contract_address"`
}

func (q *Queries) GetAssetByIdentifiersBatch(ctx context.Context, arg []GetAssetByIdentifiersBatchParams) *GetAssetByIdentifiersBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OwnerAddress,
			a.TokenAddress,
			a.Chain,
		}
		batch.Queue(getAssetByIdentifiersBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAssetByIdentifiersBatchBatchResults{br, len(arg), false}
}

func (b *GetAssetByIdentifiersBatchBatchResults) QueryRow(f func(int, GetAssetByIdentifiersBatchRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i GetAssetByIdentifiersBatchRow
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Chain,
			&i.TokenAddress,
			&i.OwnerAddress,
			&i.Balance,
			&i.BlockNumber,
			&i.ID_2,
			&i.Deleted,
			&i.Version_2,
			&i.CreatedAt_2,
			&i.LastUpdated_2,
			&i.Name,
			&i.Symbol,
			&i.Logo,
			&i.TokenType,
			&i.BlockNumber_2,
			&i.Chain_2,
			&i.ContractAddress,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetAssetByIdentifiersBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getAssetsByOwnerAddressBatch = `-- name: GetAssetsByOwnerAddressBatch :batchmany
select a.id, a.version, a.last_updated, a.created_at, a.chain, a.token_address, a.owner_address, a.balance, a.block_number, t.id, t.deleted, t.version, t.created_at, t.last_updated, t.name, t.symbol, t.logo, t.token_type, t.block_number, t.chain, t.contract_address
from assets a join tokens t on a.token_address = t.contract_address and a.chain = t.chain
where a.owner_address = $1 and t.deleted = false
order by a.balance desc
limit $2
`

type GetAssetsByOwnerAddressBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetAssetsByOwnerAddressBatchParams struct {
	OwnerAddress persist.Address `db:"owner_address" json:"owner_address"`
	Limit        int32           `db:"limit" json:"limit"`
}

type GetAssetsByOwnerAddressBatchRow struct {
	Asset Asset `db:"asset" json:"asset"`
	Token Token `db:"token" json:"token"`
}

func (q *Queries) GetAssetsByOwnerAddressBatch(ctx context.Context, arg []GetAssetsByOwnerAddressBatchParams) *GetAssetsByOwnerAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OwnerAddress,
			a.Limit,
		}
		batch.Queue(getAssetsByOwnerAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAssetsByOwnerAddressBatchBatchResults{br, len(arg), false}
}

func (b *GetAssetsByOwnerAddressBatchBatchResults) Query(f func(int, []GetAssetsByOwnerAddressBatchRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []GetAssetsByOwnerAddressBatchRow
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i GetAssetsByOwnerAddressBatchRow
				if err := rows.Scan(
					&i.Asset.ID,
					&i.Asset.Version,
					&i.Asset.LastUpdated,
					&i.Asset.CreatedAt,
					&i.Asset.Chain,
					&i.Asset.TokenAddress,
					&i.Asset.OwnerAddress,
					&i.Asset.Balance,
					&i.Asset.BlockNumber,
					&i.Token.ID,
					&i.Token.Deleted,
					&i.Token.Version,
					&i.Token.CreatedAt,
					&i.Token.LastUpdated,
					&i.Token.Name,
					&i.Token.Symbol,
					&i.Token.Logo,
					&i.Token.TokenType,
					&i.Token.BlockNumber,
					&i.Token.Chain,
					&i.Token.ContractAddress,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetAssetsByOwnerAddressBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getAssetsByOwnerChainAddressBatch = `-- name: GetAssetsByOwnerChainAddressBatch :batchmany
select a.id, a.version, a.last_updated, a.created_at, a.chain, a.token_address, a.owner_address, a.balance, a.block_number, t.id, t.deleted, t.version, t.created_at, t.last_updated, t.name, t.symbol, t.logo, t.token_type, t.block_number, t.chain, t.contract_address
from assets a join tokens t on a.token_address = t.contract_address and a.chain = t.chain
where a.owner_address = $1 and a.chain = $2 and t.deleted = false
order by a.balance desc
limit $3
`

type GetAssetsByOwnerChainAddressBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetAssetsByOwnerChainAddressBatchParams struct {
	OwnerAddress persist.Address `db:"owner_address" json:"owner_address"`
	Chain        persist.Chain   `db:"chain" json:"chain"`
	Limit        int32           `db:"limit" json:"limit"`
}

type GetAssetsByOwnerChainAddressBatchRow struct {
	Asset Asset `db:"asset" json:"asset"`
	Token Token `db:"token" json:"token"`
}

func (q *Queries) GetAssetsByOwnerChainAddressBatch(ctx context.Context, arg []GetAssetsByOwnerChainAddressBatchParams) *GetAssetsByOwnerChainAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OwnerAddress,
			a.Chain,
			a.Limit,
		}
		batch.Queue(getAssetsByOwnerChainAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetAssetsByOwnerChainAddressBatchBatchResults{br, len(arg), false}
}

func (b *GetAssetsByOwnerChainAddressBatchBatchResults) Query(f func(int, []GetAssetsByOwnerChainAddressBatchRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []GetAssetsByOwnerChainAddressBatchRow
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i GetAssetsByOwnerChainAddressBatchRow
				if err := rows.Scan(
					&i.Asset.ID,
					&i.Asset.Version,
					&i.Asset.LastUpdated,
					&i.Asset.CreatedAt,
					&i.Asset.Chain,
					&i.Asset.TokenAddress,
					&i.Asset.OwnerAddress,
					&i.Asset.Balance,
					&i.Asset.BlockNumber,
					&i.Token.ID,
					&i.Token.Deleted,
					&i.Token.Version,
					&i.Token.CreatedAt,
					&i.Token.LastUpdated,
					&i.Token.Name,
					&i.Token.Symbol,
					&i.Token.Logo,
					&i.Token.TokenType,
					&i.Token.BlockNumber,
					&i.Token.Chain,
					&i.Token.ContractAddress,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetAssetsByOwnerChainAddressBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getNotificationByIDBatch = `-- name: GetNotificationByIDBatch :batchone
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE id = $1 AND deleted = false
`

type GetNotificationByIDBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetNotificationByIDBatch(ctx context.Context, id []persist.DBID) *GetNotificationByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getNotificationByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetNotificationByIDBatchBatchResults{br, len(id), false}
}

func (b *GetNotificationByIDBatchBatchResults) QueryRow(f func(int, Notification, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i Notification
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.OwnerID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Action,
			&i.Data,
			&i.EventIds,
			&i.SplitID,
			&i.Seen,
			&i.Amount,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetNotificationByIDBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getSplitByChainAddressBatch = `-- name: GetSplitByChainAddressBatch :batchone
SELECT id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership FROM splits WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetSplitByChainAddressBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetSplitByChainAddressBatchParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetSplitByChainAddressBatch(ctx context.Context, arg []GetSplitByChainAddressBatchParams) *GetSplitByChainAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Address,
			a.Chain,
		}
		batch.Queue(getSplitByChainAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetSplitByChainAddressBatchBatchResults{br, len(arg), false}
}

func (b *GetSplitByChainAddressBatchBatchResults) QueryRow(f func(int, Split, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i Split
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetSplitByChainAddressBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getSplitByIdBatch = `-- name: GetSplitByIdBatch :batchone
SELECT id, version, last_updated, created_at, deleted, chain, address, name, description, creator_address, logo_url, banner_url, badge_url, total_ownership FROM splits WHERE id = $1 AND deleted = false
`

type GetSplitByIdBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetSplitByIdBatch(ctx context.Context, id []persist.DBID) *GetSplitByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getSplitByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetSplitByIdBatchBatchResults{br, len(id), false}
}

func (b *GetSplitByIdBatchBatchResults) QueryRow(f func(int, Split, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i Split
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Deleted,
			&i.Chain,
			&i.Address,
			&i.Name,
			&i.Description,
			&i.CreatorAddress,
			&i.LogoUrl,
			&i.BannerUrl,
			&i.BadgeUrl,
			&i.TotalOwnership,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetSplitByIdBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getSplitsByRecipientAddressBatch = `-- name: GetSplitsByRecipientAddressBatch :batchmany
SELECT s.id, s.version, s.last_updated, s.created_at, s.deleted, s.chain, s.address, s.name, s.description, s.creator_address, s.logo_url, s.banner_url, s.badge_url, s.total_ownership FROM recipients r
                    JOIN splits s ON s.id = r.split_id
WHERE r.address = $1 AND s.deleted = false
`

type GetSplitsByRecipientAddressBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetSplitsByRecipientAddressBatch(ctx context.Context, address []persist.Address) *GetSplitsByRecipientAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range address {
		vals := []interface{}{
			a,
		}
		batch.Queue(getSplitsByRecipientAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetSplitsByRecipientAddressBatchBatchResults{br, len(address), false}
}

func (b *GetSplitsByRecipientAddressBatchBatchResults) Query(f func(int, []Split, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []Split
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i Split
				if err := rows.Scan(
					&i.ID,
					&i.Version,
					&i.LastUpdated,
					&i.CreatedAt,
					&i.Deleted,
					&i.Chain,
					&i.Address,
					&i.Name,
					&i.Description,
					&i.CreatorAddress,
					&i.LogoUrl,
					&i.BannerUrl,
					&i.BadgeUrl,
					&i.TotalOwnership,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetSplitsByRecipientAddressBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getSplitsByRecipientChainAddressBatch = `-- name: GetSplitsByRecipientChainAddressBatch :batchmany
SELECT s.id, s.version, s.last_updated, s.created_at, s.deleted, s.chain, s.address, s.name, s.description, s.creator_address, s.logo_url, s.banner_url, s.badge_url, s.total_ownership FROM recipients r
                    JOIN splits s ON s.id = r.split_id
WHERE r.address = $1 AND s.chain = $2 AND s.deleted = false
`

type GetSplitsByRecipientChainAddressBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetSplitsByRecipientChainAddressBatchParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetSplitsByRecipientChainAddressBatch(ctx context.Context, arg []GetSplitsByRecipientChainAddressBatchParams) *GetSplitsByRecipientChainAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Address,
			a.Chain,
		}
		batch.Queue(getSplitsByRecipientChainAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetSplitsByRecipientChainAddressBatchBatchResults{br, len(arg), false}
}

func (b *GetSplitsByRecipientChainAddressBatchBatchResults) Query(f func(int, []Split, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []Split
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i Split
				if err := rows.Scan(
					&i.ID,
					&i.Version,
					&i.LastUpdated,
					&i.CreatedAt,
					&i.Deleted,
					&i.Chain,
					&i.Address,
					&i.Name,
					&i.Description,
					&i.CreatorAddress,
					&i.LogoUrl,
					&i.BannerUrl,
					&i.BadgeUrl,
					&i.TotalOwnership,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetSplitsByRecipientChainAddressBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getTokenByChainAddressBatch = `-- name: GetTokenByChainAddressBatch :batchone
select id, deleted, version, created_at, last_updated, name, symbol, logo, token_type, block_number, chain, contract_address FROM tokens WHERE contract_address = $1 AND chain = $2 AND deleted = false
`

type GetTokenByChainAddressBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetTokenByChainAddressBatchParams struct {
	ContractAddress persist.Address `db:"contract_address" json:"contract_address"`
	Chain           persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetTokenByChainAddressBatch(ctx context.Context, arg []GetTokenByChainAddressBatchParams) *GetTokenByChainAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ContractAddress,
			a.Chain,
		}
		batch.Queue(getTokenByChainAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokenByChainAddressBatchBatchResults{br, len(arg), false}
}

func (b *GetTokenByChainAddressBatchBatchResults) QueryRow(f func(int, Token, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i Token
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Logo,
			&i.TokenType,
			&i.BlockNumber,
			&i.Chain,
			&i.ContractAddress,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetTokenByChainAddressBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getTokenByIdBatch = `-- name: GetTokenByIdBatch :batchone
SELECT id, deleted, version, created_at, last_updated, name, symbol, logo, token_type, block_number, chain, contract_address FROM tokens WHERE id = $1 AND deleted = false
`

type GetTokenByIdBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetTokenByIdBatch(ctx context.Context, id []persist.DBID) *GetTokenByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getTokenByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetTokenByIdBatchBatchResults{br, len(id), false}
}

func (b *GetTokenByIdBatchBatchResults) QueryRow(f func(int, Token, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i Token
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Name,
			&i.Symbol,
			&i.Logo,
			&i.TokenType,
			&i.BlockNumber,
			&i.Chain,
			&i.ContractAddress,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetTokenByIdBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getUserByChainAddressBatch = `-- name: GetUserByChainAddressBatch :batchone
select users.id, users.deleted, users.version, users.last_updated, users.created_at, users.username, users.username_idempotent, users.wallets, users.bio, users.traits, users.universal, users.notification_settings, users.email_verified, users.email_unsubscriptions, users.featured_split, users.primary_wallet_id, users.user_experiences
from users, wallets
where wallets.address = $1
  and array[wallets.id] <@ users.wallets
  and wallets.chain = $2
  and wallets.deleted = false
  and users.deleted = false
`

type GetUserByChainAddressBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetUserByChainAddressBatchParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetUserByChainAddressBatch(ctx context.Context, arg []GetUserByChainAddressBatchParams) *GetUserByChainAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Address,
			a.Chain,
		}
		batch.Queue(getUserByChainAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserByChainAddressBatchBatchResults{br, len(arg), false}
}

func (b *GetUserByChainAddressBatchBatchResults) QueryRow(f func(int, User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i User
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetUserByChainAddressBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getUserByIdBatch = `-- name: GetUserByIdBatch :batchone
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE id = $1 AND deleted = false
`

type GetUserByIdBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetUserByIdBatch(ctx context.Context, id []persist.DBID) *GetUserByIdBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUserByIdBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserByIdBatchBatchResults{br, len(id), false}
}

func (b *GetUserByIdBatchBatchResults) QueryRow(f func(int, User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i User
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetUserByIdBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getUserByUsernameBatch = `-- name: GetUserByUsernameBatch :batchone
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE username_idempotent = lower($1) AND deleted = false
`

type GetUserByUsernameBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetUserByUsernameBatch(ctx context.Context, lower []string) *GetUserByUsernameBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range lower {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUserByUsernameBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserByUsernameBatchBatchResults{br, len(lower), false}
}

func (b *GetUserByUsernameBatchBatchResults) QueryRow(f func(int, User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i User
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.Deleted,
			&i.Version,
			&i.LastUpdated,
			&i.CreatedAt,
			&i.Username,
			&i.UsernameIdempotent,
			&i.Wallets,
			&i.Bio,
			&i.Traits,
			&i.Universal,
			&i.NotificationSettings,
			&i.EmailVerified,
			&i.EmailUnsubscriptions,
			&i.FeaturedSplit,
			&i.PrimaryWalletID,
			&i.UserExperiences,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetUserByUsernameBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getUserNotificationsBatch = `-- name: GetUserNotificationsBatch :batchmany
SELECT id, deleted, owner_id, version, last_updated, created_at, action, data, event_ids, split_id, seen, amount FROM notifications WHERE owner_id = $1 AND deleted = false
                              AND (created_at, id) < ($2, $3)
                              AND (created_at, id) > ($4, $5)
ORDER BY CASE WHEN $6::bool THEN (created_at, id) END ASC,
         CASE WHEN NOT $6::bool THEN (created_at, id) END DESC
LIMIT $7
`

type GetUserNotificationsBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetUserNotificationsBatchParams struct {
	OwnerID       persist.DBID `db:"owner_id" json:"owner_id"`
	CurBeforeTime time.Time    `db:"cur_before_time" json:"cur_before_time"`
	CurBeforeID   persist.DBID `db:"cur_before_id" json:"cur_before_id"`
	CurAfterTime  time.Time    `db:"cur_after_time" json:"cur_after_time"`
	CurAfterID    persist.DBID `db:"cur_after_id" json:"cur_after_id"`
	PagingForward bool         `db:"paging_forward" json:"paging_forward"`
	Limit         int32        `db:"limit" json:"limit"`
}

func (q *Queries) GetUserNotificationsBatch(ctx context.Context, arg []GetUserNotificationsBatchParams) *GetUserNotificationsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.OwnerID,
			a.CurBeforeTime,
			a.CurBeforeID,
			a.CurAfterTime,
			a.CurAfterID,
			a.PagingForward,
			a.Limit,
		}
		batch.Queue(getUserNotificationsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUserNotificationsBatchBatchResults{br, len(arg), false}
}

func (b *GetUserNotificationsBatchBatchResults) Query(f func(int, []Notification, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []Notification
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i Notification
				if err := rows.Scan(
					&i.ID,
					&i.Deleted,
					&i.OwnerID,
					&i.Version,
					&i.LastUpdated,
					&i.CreatedAt,
					&i.Action,
					&i.Data,
					&i.EventIds,
					&i.SplitID,
					&i.Seen,
					&i.Amount,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetUserNotificationsBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getUsersByPositionPaginateBatch = `-- name: GetUsersByPositionPaginateBatch :batchmany
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_verified, u.email_unsubscriptions, u.featured_split, u.primary_wallet_id, u.user_experiences
from users u
         join unnest($1::varchar[]) with ordinality t(id, pos) using(id)
where not u.deleted and not u.universal and t.pos > $2::int and t.pos < $3::int
order by t.pos asc
`

type GetUsersByPositionPaginateBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetUsersByPositionPaginateBatchParams struct {
	UserIds      []string `db:"user_ids" json:"user_ids"`
	CurAfterPos  int32    `db:"cur_after_pos" json:"cur_after_pos"`
	CurBeforePos int32    `db:"cur_before_pos" json:"cur_before_pos"`
}

func (q *Queries) GetUsersByPositionPaginateBatch(ctx context.Context, arg []GetUsersByPositionPaginateBatchParams) *GetUsersByPositionPaginateBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.UserIds,
			a.CurAfterPos,
			a.CurBeforePos,
		}
		batch.Queue(getUsersByPositionPaginateBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUsersByPositionPaginateBatchBatchResults{br, len(arg), false}
}

func (b *GetUsersByPositionPaginateBatchBatchResults) Query(f func(int, []User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []User
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i User
				if err := rows.Scan(
					&i.ID,
					&i.Deleted,
					&i.Version,
					&i.LastUpdated,
					&i.CreatedAt,
					&i.Username,
					&i.UsernameIdempotent,
					&i.Wallets,
					&i.Bio,
					&i.Traits,
					&i.Universal,
					&i.NotificationSettings,
					&i.EmailVerified,
					&i.EmailUnsubscriptions,
					&i.FeaturedSplit,
					&i.PrimaryWalletID,
					&i.UserExperiences,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetUsersByPositionPaginateBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getUsersByPositionPersonalizedBatch = `-- name: GetUsersByPositionPersonalizedBatch :batchmany
select u.id, u.deleted, u.version, u.last_updated, u.created_at, u.username, u.username_idempotent, u.wallets, u.bio, u.traits, u.universal, u.notification_settings, u.email_verified, u.email_unsubscriptions, u.featured_split, u.primary_wallet_id, u.user_experiences
from users u
         join unnest($1::varchar[]) with ordinality t(id, pos) using(id)
where not u.deleted and not u.universal
order by t.pos
limit 100
`

type GetUsersByPositionPersonalizedBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetUsersByPositionPersonalizedBatch(ctx context.Context, userIds [][]string) *GetUsersByPositionPersonalizedBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range userIds {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUsersByPositionPersonalizedBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUsersByPositionPersonalizedBatchBatchResults{br, len(userIds), false}
}

func (b *GetUsersByPositionPersonalizedBatchBatchResults) Query(f func(int, []User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []User
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i User
				if err := rows.Scan(
					&i.ID,
					&i.Deleted,
					&i.Version,
					&i.LastUpdated,
					&i.CreatedAt,
					&i.Username,
					&i.UsernameIdempotent,
					&i.Wallets,
					&i.Bio,
					&i.Traits,
					&i.Universal,
					&i.NotificationSettings,
					&i.EmailVerified,
					&i.EmailUnsubscriptions,
					&i.FeaturedSplit,
					&i.PrimaryWalletID,
					&i.UserExperiences,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetUsersByPositionPersonalizedBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getUsersWithTraitBatch = `-- name: GetUsersWithTraitBatch :batchmany
SELECT id, deleted, version, last_updated, created_at, username, username_idempotent, wallets, bio, traits, universal, notification_settings, email_verified, email_unsubscriptions, featured_split, primary_wallet_id, user_experiences FROM users WHERE (traits->$1::string) IS NOT NULL AND deleted = false
`

type GetUsersWithTraitBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetUsersWithTraitBatch(ctx context.Context, dollar_1 []string) *GetUsersWithTraitBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range dollar_1 {
		vals := []interface{}{
			a,
		}
		batch.Queue(getUsersWithTraitBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetUsersWithTraitBatchBatchResults{br, len(dollar_1), false}
}

func (b *GetUsersWithTraitBatchBatchResults) Query(f func(int, []User, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []User
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i User
				if err := rows.Scan(
					&i.ID,
					&i.Deleted,
					&i.Version,
					&i.LastUpdated,
					&i.CreatedAt,
					&i.Username,
					&i.UsernameIdempotent,
					&i.Wallets,
					&i.Bio,
					&i.Traits,
					&i.Universal,
					&i.NotificationSettings,
					&i.EmailVerified,
					&i.EmailUnsubscriptions,
					&i.FeaturedSplit,
					&i.PrimaryWalletID,
					&i.UserExperiences,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetUsersWithTraitBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getWalletByChainAddressBatch = `-- name: GetWalletByChainAddressBatch :batchone
SELECT wallets.id, wallets.created_at, wallets.last_updated, wallets.deleted, wallets.version, wallets.address, wallets.wallet_type, wallets.chain FROM wallets WHERE address = $1 AND chain = $2 AND deleted = false
`

type GetWalletByChainAddressBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type GetWalletByChainAddressBatchParams struct {
	Address persist.Address `db:"address" json:"address"`
	Chain   persist.Chain   `db:"chain" json:"chain"`
}

func (q *Queries) GetWalletByChainAddressBatch(ctx context.Context, arg []GetWalletByChainAddressBatchParams) *GetWalletByChainAddressBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Address,
			a.Chain,
		}
		batch.Queue(getWalletByChainAddressBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetWalletByChainAddressBatchBatchResults{br, len(arg), false}
}

func (b *GetWalletByChainAddressBatchBatchResults) QueryRow(f func(int, Wallet, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i Wallet
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetWalletByChainAddressBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getWalletByIDBatch = `-- name: GetWalletByIDBatch :batchone
SELECT id, created_at, last_updated, deleted, version, address, wallet_type, chain FROM wallets WHERE id = $1 AND deleted = false
`

type GetWalletByIDBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetWalletByIDBatch(ctx context.Context, id []persist.DBID) *GetWalletByIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getWalletByIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetWalletByIDBatchBatchResults{br, len(id), false}
}

func (b *GetWalletByIDBatchBatchResults) QueryRow(f func(int, Wallet, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i Wallet
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.LastUpdated,
			&i.Deleted,
			&i.Version,
			&i.Address,
			&i.WalletType,
			&i.Chain,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *GetWalletByIDBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const getWalletsByUserIDBatch = `-- name: GetWalletsByUserIDBatch :batchmany
SELECT w.id, w.created_at, w.last_updated, w.deleted, w.version, w.address, w.wallet_type, w.chain FROM users u, unnest(u.wallets) WITH ORDINALITY AS a(wallet_id, wallet_ord)INNER JOIN wallets w on w.id = a.wallet_id WHERE u.id = $1 AND u.deleted = false AND w.deleted = false ORDER BY a.wallet_ord
`

type GetWalletsByUserIDBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) GetWalletsByUserIDBatch(ctx context.Context, id []persist.DBID) *GetWalletsByUserIDBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range id {
		vals := []interface{}{
			a,
		}
		batch.Queue(getWalletsByUserIDBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &GetWalletsByUserIDBatchBatchResults{br, len(id), false}
}

func (b *GetWalletsByUserIDBatchBatchResults) Query(f func(int, []Wallet, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []Wallet
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i Wallet
				if err := rows.Scan(
					&i.ID,
					&i.CreatedAt,
					&i.LastUpdated,
					&i.Deleted,
					&i.Version,
					&i.Address,
					&i.WalletType,
					&i.Chain,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *GetWalletsByUserIDBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
