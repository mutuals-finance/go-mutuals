// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package server

import (
	"context"
	"database/sql"
	"github.com/SplitFi/go-splitfi/db/gen/coredb"
	"github.com/SplitFi/go-splitfi/service/multichain"
	"github.com/SplitFi/go-splitfi/service/multichain/alchemy"
	"github.com/SplitFi/go-splitfi/service/multichain/eth"
	"github.com/SplitFi/go-splitfi/service/persist"
	"github.com/SplitFi/go-splitfi/service/persist/postgres"
	"github.com/SplitFi/go-splitfi/service/redis"
	"github.com/SplitFi/go-splitfi/service/rpc"
	"github.com/SplitFi/go-splitfi/service/task"
	"github.com/SplitFi/go-splitfi/util"
	"github.com/google/wire"
	"github.com/jackc/pgx/v4/pgxpool"
	"net/http"
)

// Injectors from inject.go:

// NewMultichainProvider is a wire injector that sets up a multichain provider instance
func NewMultichainProvider(ctx context.Context, envFunc func()) (*multichain.Provider, func()) {
	serverEnvInit := setEnv(envFunc)
	db, cleanup := newPqClient(serverEnvInit)
	pool, cleanup2 := newPgxClient(serverEnvInit)
	repositories := postgres.NewRepositories(db, pool)
	queries := newQueries(pool)
	cache := newCommunitiesCache()
	client := task.NewClient(ctx)
	httpClient := _wireClientValue
	serverTokenMetadataCache := newTokenMetadataCache()
	serverEthProviderList := ethProviderSet(serverEnvInit, client, httpClient, serverTokenMetadataCache)
	serverOptimismProviderList := optimismProviderSet(httpClient, serverTokenMetadataCache)
	serverPolygonProviderList := polygonProviderSet(httpClient, serverTokenMetadataCache)
	serverArbitrumProviderList := arbitrumProviderSet(httpClient, serverTokenMetadataCache)
	v := newMultichainSet(serverEthProviderList, serverOptimismProviderList, serverPolygonProviderList, serverArbitrumProviderList)
	provider := &multichain.Provider{
		Repos:   repositories,
		Queries: queries,
		Cache:   cache,
		Chains:  v,
	}
	return provider, func() {
		cleanup2()
		cleanup()
	}
}

var (
	_wireClientValue = &http.Client{Timeout: 0}
)

// ethProviderSet is a wire injector that creates the set of Ethereum providers
func ethProviderSet(serverEnvInit envInit, client *task.Client, httpClient *http.Client, serverTokenMetadataCache *tokenMetadataCache) ethProviderList {
	ethclientClient := rpc.NewEthClient()
	provider := eth.NewProvider(httpClient, ethclientClient, client)
	syncFailureFallbackProvider := ethFallbackProvider(httpClient, serverTokenMetadataCache)
	serverEthProviderList := ethProvidersConfig(provider, syncFailureFallbackProvider)
	return serverEthProviderList
}

// ethProvidersConfig is a wire injector that binds multichain interfaces to their concrete Ethereum implementations
func ethProvidersConfig(indexerProvider *eth.Provider, fallbackProvider multichain.SyncFailureFallbackProvider) ethProviderList {
	serverEthProviderList := ethRequirements(indexerProvider, indexerProvider, fallbackProvider, fallbackProvider, fallbackProvider, indexerProvider, indexerProvider)
	return serverEthProviderList
}

// optimismProviderSet is a wire injector that creates the set of Optimism providers
func optimismProviderSet(client *http.Client, serverTokenMetadataCache *tokenMetadataCache) optimismProviderList {
	chain := _wireChainValue
	provider := newAlchemyProvider(client, chain, serverTokenMetadataCache)
	serverOptimismProviderList := optimismProvidersConfig(provider)
	return serverOptimismProviderList
}

var (
	_wireChainValue = persist.ChainOptimism
)

// optimismProvidersConfig is a wire injector that binds multichain interfaces to their concrete Optimism implementations
func optimismProvidersConfig(alchemyProvider *alchemy.Provider) optimismProviderList {
	serverOptimismProviderList := optimismRequirements(alchemyProvider, alchemyProvider, alchemyProvider, alchemyProvider)
	return serverOptimismProviderList
}

// arbitrumProviderSet is a wire injector that creates the set of Arbitrum providers
func arbitrumProviderSet(client *http.Client, serverTokenMetadataCache *tokenMetadataCache) arbitrumProviderList {
	chain := _wirePersistChainValue
	provider := newAlchemyProvider(client, chain, serverTokenMetadataCache)
	serverArbitrumProviderList := arbitrumProvidersConfig(provider)
	return serverArbitrumProviderList
}

var (
	_wirePersistChainValue = persist.ChainArbitrum
)

// arbitrumProvidersConfig is a wire injector that binds multichain interfaces to their concrete Arbitrum implementations
func arbitrumProvidersConfig(alchemyProvider *alchemy.Provider) arbitrumProviderList {
	serverArbitrumProviderList := arbitrumRequirements(alchemyProvider, alchemyProvider, alchemyProvider, alchemyProvider, alchemyProvider)
	return serverArbitrumProviderList
}

// polygonProviderSet is a wire injector that creates the set of polygon providers
func polygonProviderSet(client *http.Client, serverTokenMetadataCache *tokenMetadataCache) polygonProviderList {
	chain := _wireChainValue2
	provider := newAlchemyProvider(client, chain, serverTokenMetadataCache)
	serverPolygonProviderList := polygonProvidersConfig(provider)
	return serverPolygonProviderList
}

var (
	_wireChainValue2 = persist.ChainPolygon
)

// polygonProvidersConfig is a wire injector that binds multichain interfaces to their concrete Polygon implementations
func polygonProvidersConfig(alchemyProvider *alchemy.Provider) polygonProviderList {
	serverPolygonProviderList := polygonRequirements(alchemyProvider, alchemyProvider, alchemyProvider, alchemyProvider)
	return serverPolygonProviderList
}

func ethFallbackProvider(httpClient *http.Client, cache *tokenMetadataCache) multichain.SyncFailureFallbackProvider {
	chain := _wireChainValue3
	provider := newAlchemyProvider(httpClient, chain, cache)
	syncFailureFallbackProvider := multichain.SyncFailureFallbackProvider{
		Primary: provider,
	}
	return syncFailureFallbackProvider
}

var (
	_wireChainValue3 = persist.ChainETH
)

// inject.go:

// envInit is a type returned after setting up the environment
// Adding envInit as a dependency to a provider will ensure that the environment is set up prior
// to calling the provider
type envInit struct{}

type ethProviderList []any

type optimismProviderList []any

type polygonProviderList []any

type arbitrumProviderList []any

type tokenMetadataCache redis.Cache

// dbConnSet is a wire provider set for initializing a postgres connection
var dbConnSet = wire.NewSet(
	newPqClient,
	newPgxClient,
	newQueries,
)

func setEnv(f func()) envInit {
	f()
	return envInit{}
}

func newPqClient(e envInit) (*sql.DB, func()) {
	pq := postgres.MustCreateClient()
	return pq, func() { pq.Close() }
}

func newPgxClient(envInit) (*pgxpool.Pool, func()) {
	pgx := postgres.NewPgxClient()
	return pgx, func() { pgx.Close() }
}

func newQueries(p *pgxpool.Pool) *coredb.Queries {
	return coredb.New(p)
}

// ethRequirements is the set of provider interfaces required for Ethereum
func ethRequirements(
	nr multichain.NameResolver,
	v multichain.Verifier,
	tof multichain.TokensOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	tmf multichain.TokenMetadataFetcher,
	tdf multichain.TokenDescriptorsFetcher,
) ethProviderList {
	return ethProviderList{nr, v, tof, toc, tiof, tmf, tdf}
}

// optimismRequirements is the set of provider interfaces required for Optimism
func optimismRequirements(
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tmf multichain.TokenMetadataFetcher,
) optimismProviderList {
	return optimismProviderList{tof, toc, tiof, tmf}
}

// arbitrumRequirements is the set of provider interfaces required for Arbitrum
func arbitrumRequirements(
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tmf multichain.TokenMetadataFetcher,
	tdf multichain.TokenDescriptorsFetcher,
) arbitrumProviderList {
	return arbitrumProviderList{tof, toc, tiof, tmf, tdf}
}

// polygonRequirements is the set of provider interfaces required for Polygon
func polygonRequirements(
	tof multichain.TokensOwnerFetcher,
	tiof multichain.TokensIncrementalOwnerFetcher,
	toc multichain.TokensContractFetcher,
	tmf multichain.TokenMetadataFetcher,
) polygonProviderList {
	return polygonProviderList{tof, tiof, toc, tmf}
}

// dedupe removes duplicate providers based on provider ID
func dedupe(providers []any) []any {
	seen := map[string]bool{}
	deduped := []any{}
	for _, p := range providers {
		if id := p.(multichain.Configurer).GetBlockchainInfo().ProviderID; !seen[id] {
			seen[id] = true
			deduped = append(deduped, p)
		}
	}
	return deduped
}

// newMultichain is a wire provider that creates a multichain provider
func newMultichainSet(
	ethProviders ethProviderList,
	optimismProviders optimismProviderList,
	polygonProviders polygonProviderList,
	arbitrumProviders arbitrumProviderList,
) map[persist.Chain][]any {
	chainToProviders := map[persist.Chain][]any{}
	chainToProviders[persist.ChainETH] = dedupe(ethProviders)
	chainToProviders[persist.ChainOptimism] = dedupe(optimismProviders)
	chainToProviders[persist.ChainPolygon] = dedupe(polygonProviders)
	chainToProviders[persist.ChainArbitrum] = dedupe(arbitrumProviders)
	return chainToProviders
}

func newAlchemyProvider(httpClient *http.Client, chain persist.Chain, cache *tokenMetadataCache) *alchemy.Provider {
	return alchemy.NewProvider(chain, httpClient)
}

func newCommunitiesCache() *redis.Cache {
	return redis.NewCache(redis.CommunitiesDB)
}

func newTokenMetadataCache() *tokenMetadataCache {
	cache := redis.NewCache(redis.TokenProcessingThrottleDB)
	return util.ToPointer(tokenMetadataCache(*cache))
}
