// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package multichain

import (
	"context"
	"github.com/SplitFi/go-splitfi/db/gen/coredb"
	"github.com/SplitFi/go-splitfi/service/eth"
	"github.com/SplitFi/go-splitfi/service/persist"
	"github.com/SplitFi/go-splitfi/service/persist/postgres"
	"github.com/SplitFi/go-splitfi/service/task"
	"github.com/ethereum/go-ethereum/ethclient"
	"net/http"
)

// Injectors from inject.go:

func NewMultichainProvider(contextContext context.Context, repositories *postgres.Repositories, queries *coredb.Queries, client *ethclient.Client, taskClient *task.Client) *Provider {
	httpClient := _wireClientValue
	ethereumProvider := ethInjector(contextContext, httpClient, client)
	optimismProvider := optimismInjector(contextContext, httpClient, client)
	arbitrumProvider := arbitrumInjector(contextContext, httpClient, client)
	baseProvider := baseInjector(contextContext, httpClient, client)
	polygonProvider := polygonInjector(contextContext, httpClient, client)
	chainProvider := &ChainProvider{
		Ethereum: ethereumProvider,
		Optimism: optimismProvider,
		Arbitrum: arbitrumProvider,
		Base:     baseProvider,
		Polygon:  polygonProvider,
	}
	provider := multichainProviderInjector(contextContext, repositories, queries, chainProvider)
	return provider
}

var (
	_wireClientValue = http.DefaultClient
)

func multichainProviderInjector(ctx context.Context, repos *postgres.Repositories, q *coredb.Queries, chainProvider *ChainProvider) *Provider {
	providerLookup := newProviderLookup(chainProvider)
	provider := &Provider{
		Repos:   repos,
		Queries: q,
		Chains:  providerLookup,
	}
	return provider
}

func ethInjector(contextContext context.Context, client *http.Client, ethclientClient *ethclient.Client) *EthereumProvider {
	verifier := ethVerifierInjector(ethclientClient)
	ethereumProvider := ethProviderInjector(contextContext, verifier)
	return ethereumProvider
}

func ethVerifierInjector(ethClient *ethclient.Client) *eth.Verifier {
	verifier := &eth.Verifier{
		Client: ethClient,
	}
	return verifier
}

func ethProviderInjector(ctx context.Context, verifier *eth.Verifier) *EthereumProvider {
	ethereumProvider := &EthereumProvider{
		Verifier: verifier,
	}
	return ethereumProvider
}

func optimismInjector(contextContext context.Context, client *http.Client, ethclientClient *ethclient.Client) *OptimismProvider {
	optimismProvider := optimismProviderInjector()
	return optimismProvider
}

func optimismProviderInjector() *OptimismProvider {
	optimismProvider := &OptimismProvider{}
	return optimismProvider
}

func arbitrumInjector(contextContext context.Context, client *http.Client, ethclientClient *ethclient.Client) *ArbitrumProvider {
	arbitrumProvider := arbitrumProviderInjector()
	return arbitrumProvider
}

func arbitrumProviderInjector() *ArbitrumProvider {
	arbitrumProvider := &ArbitrumProvider{}
	return arbitrumProvider
}

func baseInjector(contextContext context.Context, client *http.Client, ethclientClient *ethclient.Client) *BaseProvider {
	baseProvider := baseProvidersInjector(ethclientClient)
	return baseProvider
}

func baseProvidersInjector(ethClient *ethclient.Client) *BaseProvider {
	baseProvider := &BaseProvider{}
	return baseProvider
}

func polygonInjector(contextContext context.Context, client *http.Client, ethclientClient *ethclient.Client) *PolygonProvider {
	polygonProvider := polygonProvidersInjector(ethclientClient)
	return polygonProvider
}

func polygonProvidersInjector(ethClient *ethclient.Client) *PolygonProvider {
	polygonProvider := &PolygonProvider{}
	return polygonProvider
}

// inject.go:

// New chains must be added here
func newProviderLookup(p *ChainProvider) ProviderLookup {
	return ProviderLookup{persist.ChainETH: p.Ethereum, persist.ChainOptimism: p.Optimism, persist.ChainArbitrum: p.Arbitrum, persist.ChainBase: p.Base, persist.ChainPolygon: p.Polygon}
}
