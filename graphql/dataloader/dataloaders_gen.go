// Code generated by github.com/SplitFi/go-splitfi/cmd/dataloaders, DO NOT EDIT.

package dataloader

import (
	"context"
	"time"

	"github.com/SplitFi/go-splitfi/cmd/dataloaders/generator"

	"github.com/SplitFi/go-splitfi/service/persist"

	"github.com/SplitFi/go-splitfi/db/gen/coredb"
)

type autoCacheWithKey[TKey any, TResult any] interface {
	getKeyForResult(TResult) TKey
}

type autoCacheWithKeys[TKey any, TResult any] interface {
	getKeysForResult(TResult) []TKey
}

type notFoundErrorProvider[TKey any] interface {
	getNotFoundError(TKey) error
}

type PreFetchHook func(context.Context, string) context.Context
type PostFetchHook func(context.Context, string)

// GetNotificationByIDBatch batches and caches requests
type GetNotificationByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Notification]
}

// newGetNotificationByIDBatch creates a new GetNotificationByIDBatch with the given settings, functions, and options
func newGetNotificationByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetNotificationByIDBatch, []persist.DBID) ([]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetNotificationByIDBatch {
	d := &GetNotificationByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetNotificationByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetNotificationByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetNotificationByIDBatch) getKeyForResult(result coredb.Notification) persist.DBID {
	return result.ID
}

// GetSplitByChainAddressBatch batches and caches requests
type GetSplitByChainAddressBatch struct {
	generator.Dataloader[coredb.GetSplitByChainAddressBatchParams, coredb.Split]
}

// newGetSplitByChainAddressBatch creates a new GetSplitByChainAddressBatch with the given settings, functions, and options
func newGetSplitByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSplitByChainAddressBatch, []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSplitByChainAddressBatch {
	d := &GetSplitByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSplitByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSplitByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetSplitByIdBatch batches and caches requests
type GetSplitByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Split]
}

// newGetSplitByIdBatch creates a new GetSplitByIdBatch with the given settings, functions, and options
func newGetSplitByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSplitByIdBatch, []persist.DBID) ([]coredb.Split, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSplitByIdBatch {
	d := &GetSplitByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Split, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSplitByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSplitByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetSplitByIdBatch) getKeyForResult(result coredb.Split) persist.DBID {
	return result.ID
}

// GetSplitsByUserIDBatch batches and caches requests
type GetSplitsByUserIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Split]
}

// newGetSplitsByUserIDBatch creates a new GetSplitsByUserIDBatch with the given settings, functions, and options
func newGetSplitsByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSplitsByUserIDBatch, []persist.DBID) ([][]coredb.Split, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSplitsByUserIDBatch {
	d := &GetSplitsByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Split, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSplitsByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSplitsByUserIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserByChainAddressBatch batches and caches requests
type GetUserByChainAddressBatch struct {
	generator.Dataloader[coredb.GetUserByChainAddressBatchParams, coredb.User]
}

// newGetUserByChainAddressBatch creates a new GetUserByChainAddressBatch with the given settings, functions, and options
func newGetUserByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByChainAddressBatch, []coredb.GetUserByChainAddressBatchParams) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByChainAddressBatch {
	d := &GetUserByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserByChainAddressBatchParams) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserByIdBatch batches and caches requests
type GetUserByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.User]
}

// newGetUserByIdBatch creates a new GetUserByIdBatch with the given settings, functions, and options
func newGetUserByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByIdBatch, []persist.DBID) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByIdBatch {
	d := &GetUserByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetUserByIdBatch) getKeyForResult(result coredb.User) persist.DBID {
	return result.ID
}

// GetUserByUsernameBatch batches and caches requests
type GetUserByUsernameBatch struct {
	generator.Dataloader[string, coredb.User]
}

// newGetUserByUsernameBatch creates a new GetUserByUsernameBatch with the given settings, functions, and options
func newGetUserByUsernameBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByUsernameBatch, []string) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByUsernameBatch {
	d := &GetUserByUsernameBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByUsernameBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByUsernameBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserNotificationsBatch batches and caches requests
type GetUserNotificationsBatch struct {
	generator.Dataloader[coredb.GetUserNotificationsBatchParams, []coredb.Notification]
}

// newGetUserNotificationsBatch creates a new GetUserNotificationsBatch with the given settings, functions, and options
func newGetUserNotificationsBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserNotificationsBatch, []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserNotificationsBatch {
	d := &GetUserNotificationsBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserNotificationsBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserNotificationsBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersByPositionPaginateBatch batches and caches requests
type GetUsersByPositionPaginateBatch struct {
	generator.Dataloader[coredb.GetUsersByPositionPaginateBatchParams, []coredb.User]
}

// newGetUsersByPositionPaginateBatch creates a new GetUsersByPositionPaginateBatch with the given settings, functions, and options
func newGetUsersByPositionPaginateBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersByPositionPaginateBatch, []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersByPositionPaginateBatch {
	d := &GetUsersByPositionPaginateBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersByPositionPaginateBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersByPositionPaginateBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersByPositionPersonalizedBatch batches and caches requests
type GetUsersByPositionPersonalizedBatch struct {
	generator.Dataloader[[]string, []coredb.User]
}

// newGetUsersByPositionPersonalizedBatch creates a new GetUsersByPositionPersonalizedBatch with the given settings, functions, and options
func newGetUsersByPositionPersonalizedBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersByPositionPersonalizedBatch, [][]string) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersByPositionPersonalizedBatch {
	d := &GetUsersByPositionPersonalizedBatch{}

	fetchWithHooks := func(ctx context.Context, keys [][]string) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersByPositionPersonalizedBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersByPositionPersonalizedBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersWithTraitBatch batches and caches requests
type GetUsersWithTraitBatch struct {
	generator.Dataloader[string, []coredb.User]
}

// newGetUsersWithTraitBatch creates a new GetUsersWithTraitBatch with the given settings, functions, and options
func newGetUsersWithTraitBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersWithTraitBatch, []string) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersWithTraitBatch {
	d := &GetUsersWithTraitBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetWalletByChainAddressBatch batches and caches requests
type GetWalletByChainAddressBatch struct {
	generator.Dataloader[coredb.GetWalletByChainAddressBatchParams, coredb.Wallet]
}

// newGetWalletByChainAddressBatch creates a new GetWalletByChainAddressBatch with the given settings, functions, and options
func newGetWalletByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletByChainAddressBatch, []coredb.GetWalletByChainAddressBatchParams) ([]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletByChainAddressBatch {
	d := &GetWalletByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetWalletByChainAddressBatchParams) ([]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetWalletByIDBatch batches and caches requests
type GetWalletByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Wallet]
}

// newGetWalletByIDBatch creates a new GetWalletByIDBatch with the given settings, functions, and options
func newGetWalletByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletByIDBatch, []persist.DBID) ([]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletByIDBatch {
	d := &GetWalletByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetWalletByIDBatch) getKeyForResult(result coredb.Wallet) persist.DBID {
	return result.ID
}

// GetWalletsByUserIDBatch batches and caches requests
type GetWalletsByUserIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Wallet]
}

// newGetWalletsByUserIDBatch creates a new GetWalletsByUserIDBatch with the given settings, functions, and options
func newGetWalletsByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletsByUserIDBatch, []persist.DBID) ([][]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletsByUserIDBatch {
	d := &GetWalletsByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}
