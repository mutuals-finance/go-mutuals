// Code generated by dataloaders, DO NOT EDIT.

package dataloader

import (
	"context"
	"time"

	"github.com/SplitFi/go-splitfi/cmd/dataloaders/generator"

	"github.com/SplitFi/go-splitfi/service/persist"

	"github.com/SplitFi/go-splitfi/db/gen/coredb"
)

type autoCacheWithKey[TKey any, TResult any] interface {
	getKeyForResult(TResult) TKey
}

type autoCacheWithKeys[TKey any, TResult any] interface {
	getKeysForResult(TResult) []TKey
}

type notFoundErrorProvider[TKey any] interface {
	getNotFoundError(TKey) error
}

type PreFetchHook func(context.Context, string) context.Context
type PostFetchHook func(context.Context, string)

// GetNotificationByIDBatch batches and caches requests
type GetNotificationByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Notification]
}

// newGetNotificationByIDBatch creates a new GetNotificationByIDBatch with the given settings, functions, and options
func newGetNotificationByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetNotificationByIDBatch, []persist.DBID) ([]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetNotificationByIDBatch {
	d := &GetNotificationByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetNotificationByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetNotificationByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetNotificationByIDBatch) getKeyForResult(result coredb.Notification) persist.DBID {
	return result.ID
}

// GetTokenByIdBatch batches and caches requests
type GetTokenByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Token]
}

// newGetTokenByIdBatch creates a new GetTokenByIdBatch with the given settings, functions, and options
func newGetTokenByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByIdBatch, []persist.DBID) ([]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByIdBatch {
	d := &GetTokenByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetTokenByIdBatch) getKeyForResult(result coredb.Token) persist.DBID {
	return result.ID
}

// GetUserByIdBatch batches and caches requests
type GetUserByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.User]
}

// newGetUserByIdBatch creates a new GetUserByIdBatch with the given settings, functions, and options
func newGetUserByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByIdBatch, []persist.DBID) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByIdBatch {
	d := &GetUserByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetUserByIdBatch) getKeyForResult(result coredb.User) persist.DBID {
	return result.ID
}

// GetUserByUsernameBatch batches and caches requests
type GetUserByUsernameBatch struct {
	generator.Dataloader[string, coredb.User]
}

// newGetUserByUsernameBatch creates a new GetUserByUsernameBatch with the given settings, functions, and options
func newGetUserByUsernameBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByUsernameBatch, []string) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByUsernameBatch {
	d := &GetUserByUsernameBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByUsernameBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByUsernameBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserNotificationsBatch batches and caches requests
type GetUserNotificationsBatch struct {
	generator.Dataloader[coredb.GetUserNotificationsBatchParams, []coredb.Notification]
}

// newGetUserNotificationsBatch creates a new GetUserNotificationsBatch with the given settings, functions, and options
func newGetUserNotificationsBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserNotificationsBatch, []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserNotificationsBatch {
	d := &GetUserNotificationsBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserNotificationsBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserNotificationsBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersWithTraitBatch batches and caches requests
type GetUsersWithTraitBatch struct {
	generator.Dataloader[string, []coredb.User]
}

// newGetUsersWithTraitBatch creates a new GetUsersWithTraitBatch with the given settings, functions, and options
func newGetUsersWithTraitBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersWithTraitBatch, []string) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersWithTraitBatch {
	d := &GetUsersWithTraitBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetWalletByIDBatch batches and caches requests
type GetWalletByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Wallet]
}

// newGetWalletByIDBatch creates a new GetWalletByIDBatch with the given settings, functions, and options
func newGetWalletByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletByIDBatch, []persist.DBID) ([]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletByIDBatch {
	d := &GetWalletByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetWalletByIDBatch) getKeyForResult(result coredb.Wallet) persist.DBID {
	return result.ID
}

// GetWalletsByUserIDBatch batches and caches requests
type GetWalletsByUserIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Wallet]
}

// newGetWalletsByUserIDBatch creates a new GetWalletsByUserIDBatch with the given settings, functions, and options
func newGetWalletsByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletsByUserIDBatch, []persist.DBID) ([][]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletsByUserIDBatch {
	d := &GetWalletsByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}
