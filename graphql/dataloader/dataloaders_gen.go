// Code generated by github.com/SplitFi/go-splitfi/cmd/dataloaders, DO NOT EDIT.

package dataloader

import (
	"context"
	"time"

	"github.com/SplitFi/go-splitfi/cmd/dataloaders/generator"

	"github.com/SplitFi/go-splitfi/service/persist"

	"github.com/SplitFi/go-splitfi/db/gen/coredb"
)

type autoCacheWithKey[TKey any, TResult any] interface {
	getKeyForResult(TResult) TKey
}

type autoCacheWithKeys[TKey any, TResult any] interface {
	getKeysForResult(TResult) []TKey
}

type notFoundErrorProvider[TKey any] interface {
	getNotFoundError(TKey) error
}

type PreFetchHook func(context.Context, string) context.Context
type PostFetchHook func(context.Context, string)

// GetAssetByIdBatch batches and caches requests
type GetAssetByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.GetAssetByIdBatchRow]
}

// newGetAssetByIdBatch creates a new GetAssetByIdBatch with the given settings, functions, and options
func newGetAssetByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetAssetByIdBatch, []persist.DBID) ([]coredb.GetAssetByIdBatchRow, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetAssetByIdBatch {
	d := &GetAssetByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.GetAssetByIdBatchRow, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetAssetByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetAssetByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetNotificationByIDBatch batches and caches requests
type GetNotificationByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Notification]
}

// newGetNotificationByIDBatch creates a new GetNotificationByIDBatch with the given settings, functions, and options
func newGetNotificationByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetNotificationByIDBatch, []persist.DBID) ([]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetNotificationByIDBatch {
	d := &GetNotificationByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetNotificationByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetNotificationByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetNotificationByIDBatch) getKeyForResult(result coredb.Notification) persist.DBID {
	return result.ID
}

// GetSplitByChainAddressBatch batches and caches requests
type GetSplitByChainAddressBatch struct {
	generator.Dataloader[coredb.GetSplitByChainAddressBatchParams, coredb.Split]
}

// newGetSplitByChainAddressBatch creates a new GetSplitByChainAddressBatch with the given settings, functions, and options
func newGetSplitByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSplitByChainAddressBatch, []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSplitByChainAddressBatch {
	d := &GetSplitByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSplitByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSplitByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetSplitByIdBatch batches and caches requests
type GetSplitByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Split]
}

// newGetSplitByIdBatch creates a new GetSplitByIdBatch with the given settings, functions, and options
func newGetSplitByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSplitByIdBatch, []persist.DBID) ([]coredb.Split, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSplitByIdBatch {
	d := &GetSplitByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Split, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSplitByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSplitByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetSplitByIdBatch) getKeyForResult(result coredb.Split) persist.DBID {
	return result.ID
}

// GetSplitsByRecipientAddressBatch batches and caches requests
type GetSplitsByRecipientAddressBatch struct {
	generator.Dataloader[persist.Address, []coredb.Split]
}

// newGetSplitsByRecipientAddressBatch creates a new GetSplitsByRecipientAddressBatch with the given settings, functions, and options
func newGetSplitsByRecipientAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSplitsByRecipientAddressBatch, []persist.Address) ([][]coredb.Split, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSplitsByRecipientAddressBatch {
	d := &GetSplitsByRecipientAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.Address) ([][]coredb.Split, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSplitsByRecipientAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSplitsByRecipientAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetSplitsByRecipientChainAddressBatch batches and caches requests
type GetSplitsByRecipientChainAddressBatch struct {
	generator.Dataloader[coredb.GetSplitsByRecipientChainAddressBatchParams, []coredb.Split]
}

// newGetSplitsByRecipientChainAddressBatch creates a new GetSplitsByRecipientChainAddressBatch with the given settings, functions, and options
func newGetSplitsByRecipientChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetSplitsByRecipientChainAddressBatch, []coredb.GetSplitsByRecipientChainAddressBatchParams) ([][]coredb.Split, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetSplitsByRecipientChainAddressBatch {
	d := &GetSplitsByRecipientChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetSplitsByRecipientChainAddressBatchParams) ([][]coredb.Split, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetSplitsByRecipientChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetSplitsByRecipientChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokenByChainAddressBatch batches and caches requests
type GetTokenByChainAddressBatch struct {
	generator.Dataloader[coredb.GetTokenByChainAddressBatchParams, coredb.Token]
}

// newGetTokenByChainAddressBatch creates a new GetTokenByChainAddressBatch with the given settings, functions, and options
func newGetTokenByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByChainAddressBatch, []coredb.GetTokenByChainAddressBatchParams) ([]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByChainAddressBatch {
	d := &GetTokenByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokenByChainAddressBatchParams) ([]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokenByIdBatch batches and caches requests
type GetTokenByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.Token]
}

// newGetTokenByIdBatch creates a new GetTokenByIdBatch with the given settings, functions, and options
func newGetTokenByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokenByIdBatch, []persist.DBID) ([]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokenByIdBatch {
	d := &GetTokenByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokenByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokenByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetTokenByIdBatch) getKeyForResult(result coredb.Token) persist.DBID {
	return result.ID
}

// GetTokensByChainAddressBatch batches and caches requests
type GetTokensByChainAddressBatch struct {
	generator.Dataloader[coredb.GetTokensByChainAddressBatchParams, []coredb.Token]
}

// newGetTokensByChainAddressBatch creates a new GetTokensByChainAddressBatch with the given settings, functions, and options
func newGetTokensByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByChainAddressBatch, []coredb.GetTokensByChainAddressBatchParams) ([][]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByChainAddressBatch {
	d := &GetTokensByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetTokensByChainAddressBatchParams) ([][]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserByChainAddressBatch batches and caches requests
type GetUserByChainAddressBatch struct {
	generator.Dataloader[coredb.GetUserByChainAddressBatchParams, coredb.User]
}

// newGetUserByChainAddressBatch creates a new GetUserByChainAddressBatch with the given settings, functions, and options
func newGetUserByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByChainAddressBatch, []coredb.GetUserByChainAddressBatchParams) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByChainAddressBatch {
	d := &GetUserByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserByChainAddressBatchParams) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserByIdBatch batches and caches requests
type GetUserByIdBatch struct {
	generator.Dataloader[persist.DBID, coredb.User]
}

// newGetUserByIdBatch creates a new GetUserByIdBatch with the given settings, functions, and options
func newGetUserByIdBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByIdBatch, []persist.DBID) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByIdBatch {
	d := &GetUserByIdBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByIdBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByIdBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetUserByIdBatch) getKeyForResult(result coredb.User) persist.DBID {
	return result.ID
}

// GetUserByUsernameBatch batches and caches requests
type GetUserByUsernameBatch struct {
	generator.Dataloader[string, coredb.User]
}

// newGetUserByUsernameBatch creates a new GetUserByUsernameBatch with the given settings, functions, and options
func newGetUserByUsernameBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserByUsernameBatch, []string) ([]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserByUsernameBatch {
	d := &GetUserByUsernameBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserByUsernameBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserByUsernameBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUserNotificationsBatch batches and caches requests
type GetUserNotificationsBatch struct {
	generator.Dataloader[coredb.GetUserNotificationsBatchParams, []coredb.Notification]
}

// newGetUserNotificationsBatch creates a new GetUserNotificationsBatch with the given settings, functions, and options
func newGetUserNotificationsBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUserNotificationsBatch, []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUserNotificationsBatch {
	d := &GetUserNotificationsBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUserNotificationsBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUserNotificationsBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersByPositionPaginateBatch batches and caches requests
type GetUsersByPositionPaginateBatch struct {
	generator.Dataloader[coredb.GetUsersByPositionPaginateBatchParams, []coredb.User]
}

// newGetUsersByPositionPaginateBatch creates a new GetUsersByPositionPaginateBatch with the given settings, functions, and options
func newGetUsersByPositionPaginateBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersByPositionPaginateBatch, []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersByPositionPaginateBatch {
	d := &GetUsersByPositionPaginateBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersByPositionPaginateBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersByPositionPaginateBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersByPositionPersonalizedBatch batches and caches requests
type GetUsersByPositionPersonalizedBatch struct {
	generator.Dataloader[[]string, []coredb.User]
}

// newGetUsersByPositionPersonalizedBatch creates a new GetUsersByPositionPersonalizedBatch with the given settings, functions, and options
func newGetUsersByPositionPersonalizedBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersByPositionPersonalizedBatch, [][]string) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersByPositionPersonalizedBatch {
	d := &GetUsersByPositionPersonalizedBatch{}

	fetchWithHooks := func(ctx context.Context, keys [][]string) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersByPositionPersonalizedBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersByPositionPersonalizedBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloaderWithNonComparableKey(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetUsersWithTraitBatch batches and caches requests
type GetUsersWithTraitBatch struct {
	generator.Dataloader[string, []coredb.User]
}

// newGetUsersWithTraitBatch creates a new GetUsersWithTraitBatch with the given settings, functions, and options
func newGetUsersWithTraitBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetUsersWithTraitBatch, []string) ([][]coredb.User, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetUsersWithTraitBatch {
	d := &GetUsersWithTraitBatch{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([][]coredb.User, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetUsersWithTraitBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetWalletByChainAddressBatch batches and caches requests
type GetWalletByChainAddressBatch struct {
	generator.Dataloader[coredb.GetWalletByChainAddressBatchParams, coredb.Wallet]
}

// newGetWalletByChainAddressBatch creates a new GetWalletByChainAddressBatch with the given settings, functions, and options
func newGetWalletByChainAddressBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletByChainAddressBatch, []coredb.GetWalletByChainAddressBatchParams) ([]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletByChainAddressBatch {
	d := &GetWalletByChainAddressBatch{}

	fetchWithHooks := func(ctx context.Context, keys []coredb.GetWalletByChainAddressBatchParams) ([]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletByChainAddressBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletByChainAddressBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetWalletByIDBatch batches and caches requests
type GetWalletByIDBatch struct {
	generator.Dataloader[persist.DBID, coredb.Wallet]
}

// newGetWalletByIDBatch creates a new GetWalletByIDBatch with the given settings, functions, and options
func newGetWalletByIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletByIDBatch, []persist.DBID) ([]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletByIDBatch {
	d := &GetWalletByIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletByIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletByIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

func (*GetWalletByIDBatch) getKeyForResult(result coredb.Wallet) persist.DBID {
	return result.ID
}

// GetWalletsByUserIDBatch batches and caches requests
type GetWalletsByUserIDBatch struct {
	generator.Dataloader[persist.DBID, []coredb.Wallet]
}

// newGetWalletsByUserIDBatch creates a new GetWalletsByUserIDBatch with the given settings, functions, and options
func newGetWalletsByUserIDBatch(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetWalletsByUserIDBatch, []persist.DBID) ([][]coredb.Wallet, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetWalletsByUserIDBatch {
	d := &GetWalletsByUserIDBatch{}

	fetchWithHooks := func(ctx context.Context, keys []persist.DBID) ([][]coredb.Wallet, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetWalletsByUserIDBatch")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}

// GetTokensByIDs batches and caches requests
type GetTokensByIDs struct {
	generator.Dataloader[string, coredb.Token]
}

// newGetTokensByIDs creates a new GetTokensByIDs with the given settings, functions, and options
func newGetTokensByIDs(
	ctx context.Context,
	maxBatchSize int,
	batchTimeout time.Duration,
	cacheResults bool,
	publishResults bool,
	fetch func(context.Context, *GetTokensByIDs, []string) ([]coredb.Token, []error),
	preFetchHook PreFetchHook,
	postFetchHook PostFetchHook,
) *GetTokensByIDs {
	d := &GetTokensByIDs{}

	fetchWithHooks := func(ctx context.Context, keys []string) ([]coredb.Token, []error) {
		// Allow the preFetchHook to modify and return a new context
		if preFetchHook != nil {
			ctx = preFetchHook(ctx, "GetTokensByIDs")
		}

		results, errors := fetch(ctx, d, keys)

		if postFetchHook != nil {
			postFetchHook(ctx, "GetTokensByIDs")
		}

		return results, errors
	}

	d.Dataloader = *generator.NewDataloader(ctx, maxBatchSize, batchTimeout, cacheResults, publishResults, fetchWithHooks)
	return d
}
