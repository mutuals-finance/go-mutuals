// Code generated by github.com/SplitFi/go-splitfi/cmd/dataloaders, DO NOT EDIT.

package dataloader

import (
	"context"
	"time"

	"github.com/jackc/pgx/v4"

	"github.com/SplitFi/go-splitfi/service/persist"

	"github.com/SplitFi/go-splitfi/db/gen/coredb"
)

type Loaders struct {
	GetAssetByIdBatch                     *GetAssetByIdBatch
	GetAssetByIdentifiersBatch            *GetAssetByIdentifiersBatch
	GetAssetsByOwnerAddressBatch          *GetAssetsByOwnerAddressBatch
	GetAssetsByOwnerChainAddressBatch     *GetAssetsByOwnerChainAddressBatch
	GetNotificationByIDBatch              *GetNotificationByIDBatch
	GetSplitByChainAddressBatch           *GetSplitByChainAddressBatch
	GetSplitByIdBatch                     *GetSplitByIdBatch
	GetSplitsByRecipientAddressBatch      *GetSplitsByRecipientAddressBatch
	GetSplitsByRecipientChainAddressBatch *GetSplitsByRecipientChainAddressBatch
	GetTokenByChainAddressBatch           *GetTokenByChainAddressBatch
	GetTokenByIdBatch                     *GetTokenByIdBatch
	GetUserByAddressBatch                 *GetUserByAddressBatch
	GetUserByIdBatch                      *GetUserByIdBatch
	GetUserByUsernameBatch                *GetUserByUsernameBatch
	GetUserNotificationsBatch             *GetUserNotificationsBatch
	GetUsersWithTraitBatch                *GetUsersWithTraitBatch
	GetWalletByChainAddressBatch          *GetWalletByChainAddressBatch
	GetWalletByIDBatch                    *GetWalletByIDBatch
	GetWalletsByUserIDBatch               *GetWalletsByUserIDBatch
	GetTokensByIDs                        *GetTokensByIDs
}

func NewLoaders(ctx context.Context, q *coredb.Queries, disableCaching bool, preFetchHook PreFetchHook, postFetchHook PostFetchHook) *Loaders {
	loaders := &Loaders{}

	loaders.GetAssetByIdBatch = newGetAssetByIdBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetAssetByIdBatch(q), preFetchHook, postFetchHook)
	loaders.GetAssetByIdentifiersBatch = newGetAssetByIdentifiersBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetAssetByIdentifiersBatch(q), preFetchHook, postFetchHook)
	loaders.GetAssetsByOwnerAddressBatch = newGetAssetsByOwnerAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetAssetsByOwnerAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetAssetsByOwnerChainAddressBatch = newGetAssetsByOwnerChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetAssetsByOwnerChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetNotificationByIDBatch = newGetNotificationByIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetNotificationByIDBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitByChainAddressBatch = newGetSplitByChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitByChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitByIdBatch = newGetSplitByIdBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitByIdBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitsByRecipientAddressBatch = newGetSplitsByRecipientAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitsByRecipientAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitsByRecipientChainAddressBatch = newGetSplitsByRecipientChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitsByRecipientChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetTokenByChainAddressBatch = newGetTokenByChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetTokenByChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetTokenByIdBatch = newGetTokenByIdBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetTokenByIdBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserByAddressBatch = newGetUserByAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserByIdBatch = newGetUserByIdBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByIdBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserByUsernameBatch = newGetUserByUsernameBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByUsernameBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserNotificationsBatch = newGetUserNotificationsBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserNotificationsBatch(q), preFetchHook, postFetchHook)
	loaders.GetUsersWithTraitBatch = newGetUsersWithTraitBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUsersWithTraitBatch(q), preFetchHook, postFetchHook)
	loaders.GetWalletByChainAddressBatch = newGetWalletByChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetWalletByChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetWalletByIDBatch = newGetWalletByIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetWalletByIDBatch(q), preFetchHook, postFetchHook)
	loaders.GetWalletsByUserIDBatch = newGetWalletsByUserIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetWalletsByUserIDBatch(q), preFetchHook, postFetchHook)
	loaders.GetTokensByIDs = newGetTokensByIDs(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetTokensByIDs(q), preFetchHook, postFetchHook)

	loaders.GetUserNotificationsBatch.RegisterResultSubscriber(func(result []coredb.Notification) {
		for _, entry := range result {
			loaders.GetNotificationByIDBatch.Prime(loaders.GetNotificationByIDBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetSplitByChainAddressBatch.RegisterResultSubscriber(func(result coredb.Split) {
		loaders.GetSplitByIdBatch.Prime(loaders.GetSplitByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetSplitsByRecipientAddressBatch.RegisterResultSubscriber(func(result []coredb.Split) {
		for _, entry := range result {
			loaders.GetSplitByIdBatch.Prime(loaders.GetSplitByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetSplitsByRecipientChainAddressBatch.RegisterResultSubscriber(func(result []coredb.Split) {
		for _, entry := range result {
			loaders.GetSplitByIdBatch.Prime(loaders.GetSplitByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetAssetByIdBatch.RegisterResultSubscriber(func(result coredb.GetAssetByIdBatchRow) {
		loaders.GetTokenByChainAddressBatch.Prime(loaders.GetTokenByChainAddressBatch.getKeyForResult(result.Token), result.Token)
	})
	loaders.GetAssetsByOwnerAddressBatch.RegisterResultSubscriber(func(result []coredb.GetAssetsByOwnerAddressBatchRow) {
		for _, entry := range result {
			loaders.GetTokenByChainAddressBatch.Prime(loaders.GetTokenByChainAddressBatch.getKeyForResult(entry.Token), entry.Token)
		}
	})
	loaders.GetAssetsByOwnerChainAddressBatch.RegisterResultSubscriber(func(result []coredb.GetAssetsByOwnerChainAddressBatchRow) {
		for _, entry := range result {
			loaders.GetTokenByChainAddressBatch.Prime(loaders.GetTokenByChainAddressBatch.getKeyForResult(entry.Token), entry.Token)
		}
	})
	loaders.GetTokenByIdBatch.RegisterResultSubscriber(func(result coredb.Token) {
		loaders.GetTokenByChainAddressBatch.Prime(loaders.GetTokenByChainAddressBatch.getKeyForResult(result), result)
	})
	loaders.GetTokensByIDs.RegisterResultSubscriber(func(result coredb.Token) {
		loaders.GetTokenByChainAddressBatch.Prime(loaders.GetTokenByChainAddressBatch.getKeyForResult(result), result)
	})
	loaders.GetAssetByIdBatch.RegisterResultSubscriber(func(result coredb.GetAssetByIdBatchRow) {
		loaders.GetTokenByIdBatch.Prime(loaders.GetTokenByIdBatch.getKeyForResult(result.Token), result.Token)
	})
	loaders.GetAssetsByOwnerAddressBatch.RegisterResultSubscriber(func(result []coredb.GetAssetsByOwnerAddressBatchRow) {
		for _, entry := range result {
			loaders.GetTokenByIdBatch.Prime(loaders.GetTokenByIdBatch.getKeyForResult(entry.Token), entry.Token)
		}
	})
	loaders.GetAssetsByOwnerChainAddressBatch.RegisterResultSubscriber(func(result []coredb.GetAssetsByOwnerChainAddressBatchRow) {
		for _, entry := range result {
			loaders.GetTokenByIdBatch.Prime(loaders.GetTokenByIdBatch.getKeyForResult(entry.Token), entry.Token)
		}
	})
	loaders.GetTokenByChainAddressBatch.RegisterResultSubscriber(func(result coredb.Token) {
		loaders.GetTokenByIdBatch.Prime(loaders.GetTokenByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetTokensByIDs.RegisterResultSubscriber(func(result coredb.Token) {
		loaders.GetTokenByIdBatch.Prime(loaders.GetTokenByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetUserByAddressBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetUserByUsernameBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetUsersWithTraitBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUserByAddressBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(result), result)
	})
	loaders.GetUserByIdBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(result), result)
	})
	loaders.GetUsersWithTraitBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetWalletByChainAddressBatch.RegisterResultSubscriber(func(result coredb.Wallet) {
		loaders.GetWalletByIDBatch.Prime(loaders.GetWalletByIDBatch.getKeyForResult(result), result)
	})
	loaders.GetWalletsByUserIDBatch.RegisterResultSubscriber(func(result []coredb.Wallet) {
		for _, entry := range result {
			loaders.GetWalletByIDBatch.Prime(loaders.GetWalletByIDBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetAssetByIdBatch.RegisterResultSubscriber(func(result coredb.GetAssetByIdBatchRow) {
		loaders.GetTokensByIDs.Prime(loaders.GetTokensByIDs.getKeyForResult(result.Token), result.Token)
	})
	loaders.GetAssetsByOwnerAddressBatch.RegisterResultSubscriber(func(result []coredb.GetAssetsByOwnerAddressBatchRow) {
		for _, entry := range result {
			loaders.GetTokensByIDs.Prime(loaders.GetTokensByIDs.getKeyForResult(entry.Token), entry.Token)
		}
	})
	loaders.GetAssetsByOwnerChainAddressBatch.RegisterResultSubscriber(func(result []coredb.GetAssetsByOwnerChainAddressBatchRow) {
		for _, entry := range result {
			loaders.GetTokensByIDs.Prime(loaders.GetTokensByIDs.getKeyForResult(entry.Token), entry.Token)
		}
	})
	loaders.GetTokenByChainAddressBatch.RegisterResultSubscriber(func(result coredb.Token) {
		loaders.GetTokensByIDs.Prime(loaders.GetTokensByIDs.getKeyForResult(result), result)
	})
	loaders.GetTokenByIdBatch.RegisterResultSubscriber(func(result coredb.Token) {
		loaders.GetTokensByIDs.Prime(loaders.GetTokensByIDs.getKeyForResult(result), result)
	})

	return loaders
}

func loadGetAssetByIdBatch(q *coredb.Queries) func(context.Context, *GetAssetByIdBatch, []persist.DBID) ([]coredb.GetAssetByIdBatchRow, []error) {
	return func(ctx context.Context, d *GetAssetByIdBatch, params []persist.DBID) ([]coredb.GetAssetByIdBatchRow, []error) {
		results := make([]coredb.GetAssetByIdBatchRow, len(params))
		errors := make([]error, len(params))

		b := q.GetAssetByIdBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.GetAssetByIdBatchRow, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetAssetByIdentifiersBatch(q *coredb.Queries) func(context.Context, *GetAssetByIdentifiersBatch, []coredb.GetAssetByIdentifiersBatchParams) ([]coredb.GetAssetByIdentifiersBatchRow, []error) {
	return func(ctx context.Context, d *GetAssetByIdentifiersBatch, params []coredb.GetAssetByIdentifiersBatchParams) ([]coredb.GetAssetByIdentifiersBatchRow, []error) {
		results := make([]coredb.GetAssetByIdentifiersBatchRow, len(params))
		errors := make([]error, len(params))

		b := q.GetAssetByIdentifiersBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.GetAssetByIdentifiersBatchRow, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetAssetsByOwnerAddressBatch(q *coredb.Queries) func(context.Context, *GetAssetsByOwnerAddressBatch, []coredb.GetAssetsByOwnerAddressBatchParams) ([][]coredb.GetAssetsByOwnerAddressBatchRow, []error) {
	return func(ctx context.Context, d *GetAssetsByOwnerAddressBatch, params []coredb.GetAssetsByOwnerAddressBatchParams) ([][]coredb.GetAssetsByOwnerAddressBatchRow, []error) {
		results := make([][]coredb.GetAssetsByOwnerAddressBatchRow, len(params))
		errors := make([]error, len(params))

		b := q.GetAssetsByOwnerAddressBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.GetAssetsByOwnerAddressBatchRow, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetAssetsByOwnerChainAddressBatch(q *coredb.Queries) func(context.Context, *GetAssetsByOwnerChainAddressBatch, []coredb.GetAssetsByOwnerChainAddressBatchParams) ([][]coredb.GetAssetsByOwnerChainAddressBatchRow, []error) {
	return func(ctx context.Context, d *GetAssetsByOwnerChainAddressBatch, params []coredb.GetAssetsByOwnerChainAddressBatchParams) ([][]coredb.GetAssetsByOwnerChainAddressBatchRow, []error) {
		results := make([][]coredb.GetAssetsByOwnerChainAddressBatchRow, len(params))
		errors := make([]error, len(params))

		b := q.GetAssetsByOwnerChainAddressBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.GetAssetsByOwnerChainAddressBatchRow, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetNotificationByIDBatch(q *coredb.Queries) func(context.Context, *GetNotificationByIDBatch, []persist.DBID) ([]coredb.Notification, []error) {
	return func(ctx context.Context, d *GetNotificationByIDBatch, params []persist.DBID) ([]coredb.Notification, []error) {
		results := make([]coredb.Notification, len(params))
		errors := make([]error, len(params))

		b := q.GetNotificationByIDBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Notification, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitByChainAddressBatch(q *coredb.Queries) func(context.Context, *GetSplitByChainAddressBatch, []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitByChainAddressBatch, params []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error) {
		results := make([]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitByChainAddressBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Split, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitByIdBatch(q *coredb.Queries) func(context.Context, *GetSplitByIdBatch, []persist.DBID) ([]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitByIdBatch, params []persist.DBID) ([]coredb.Split, []error) {
		results := make([]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitByIdBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Split, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitsByRecipientAddressBatch(q *coredb.Queries) func(context.Context, *GetSplitsByRecipientAddressBatch, []persist.Address) ([][]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitsByRecipientAddressBatch, params []persist.Address) ([][]coredb.Split, []error) {
		results := make([][]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitsByRecipientAddressBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Split, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetSplitsByRecipientChainAddressBatch(q *coredb.Queries) func(context.Context, *GetSplitsByRecipientChainAddressBatch, []coredb.GetSplitsByRecipientChainAddressBatchParams) ([][]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitsByRecipientChainAddressBatch, params []coredb.GetSplitsByRecipientChainAddressBatchParams) ([][]coredb.Split, []error) {
		results := make([][]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitsByRecipientChainAddressBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Split, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetTokenByChainAddressBatch(q *coredb.Queries) func(context.Context, *GetTokenByChainAddressBatch, []coredb.GetTokenByChainAddressBatchParams) ([]coredb.Token, []error) {
	return func(ctx context.Context, d *GetTokenByChainAddressBatch, params []coredb.GetTokenByChainAddressBatchParams) ([]coredb.Token, []error) {
		results := make([]coredb.Token, len(params))
		errors := make([]error, len(params))

		b := q.GetTokenByChainAddressBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Token, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetTokenByIdBatch(q *coredb.Queries) func(context.Context, *GetTokenByIdBatch, []persist.DBID) ([]coredb.Token, []error) {
	return func(ctx context.Context, d *GetTokenByIdBatch, params []persist.DBID) ([]coredb.Token, []error) {
		results := make([]coredb.Token, len(params))
		errors := make([]error, len(params))

		b := q.GetTokenByIdBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Token, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserByAddressBatch(q *coredb.Queries) func(context.Context, *GetUserByAddressBatch, []coredb.GetUserByAddressBatchParams) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByAddressBatch, params []coredb.GetUserByAddressBatchParams) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByAddressBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserByIdBatch(q *coredb.Queries) func(context.Context, *GetUserByIdBatch, []persist.DBID) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByIdBatch, params []persist.DBID) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByIdBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserByUsernameBatch(q *coredb.Queries) func(context.Context, *GetUserByUsernameBatch, []string) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByUsernameBatch, params []string) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByUsernameBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserNotificationsBatch(q *coredb.Queries) func(context.Context, *GetUserNotificationsBatch, []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
	return func(ctx context.Context, d *GetUserNotificationsBatch, params []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
		results := make([][]coredb.Notification, len(params))
		errors := make([]error, len(params))

		b := q.GetUserNotificationsBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Notification, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetUsersWithTraitBatch(q *coredb.Queries) func(context.Context, *GetUsersWithTraitBatch, []string) ([][]coredb.User, []error) {
	return func(ctx context.Context, d *GetUsersWithTraitBatch, params []string) ([][]coredb.User, []error) {
		results := make([][]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUsersWithTraitBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.User, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetWalletByChainAddressBatch(q *coredb.Queries) func(context.Context, *GetWalletByChainAddressBatch, []coredb.GetWalletByChainAddressBatchParams) ([]coredb.Wallet, []error) {
	return func(ctx context.Context, d *GetWalletByChainAddressBatch, params []coredb.GetWalletByChainAddressBatchParams) ([]coredb.Wallet, []error) {
		results := make([]coredb.Wallet, len(params))
		errors := make([]error, len(params))

		b := q.GetWalletByChainAddressBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Wallet, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetWalletByIDBatch(q *coredb.Queries) func(context.Context, *GetWalletByIDBatch, []persist.DBID) ([]coredb.Wallet, []error) {
	return func(ctx context.Context, d *GetWalletByIDBatch, params []persist.DBID) ([]coredb.Wallet, []error) {
		results := make([]coredb.Wallet, len(params))
		errors := make([]error, len(params))

		b := q.GetWalletByIDBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Wallet, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetWalletsByUserIDBatch(q *coredb.Queries) func(context.Context, *GetWalletsByUserIDBatch, []persist.DBID) ([][]coredb.Wallet, []error) {
	return func(ctx context.Context, d *GetWalletsByUserIDBatch, params []persist.DBID) ([][]coredb.Wallet, []error) {
		results := make([][]coredb.Wallet, len(params))
		errors := make([]error, len(params))

		b := q.GetWalletsByUserIDBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Wallet, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetTokensByIDs(q *coredb.Queries) func(context.Context, *GetTokensByIDs, []string) ([]coredb.Token, []error) {
	return func(ctx context.Context, d *GetTokensByIDs, params []string) ([]coredb.Token, []error) {
		queryResults, err := q.GetTokensByIDs(ctx, params)

		results := make([]coredb.Token, len(params))
		errors := make([]error, len(params))

		if err != nil {
			for i := range errors {
				errors[i] = err
			}

			return results, errors
		}

		hasResults := make([]bool, len(params))

		for _, result := range queryResults {
			results[result.BatchKeyIndex-1] = result.Token
			hasResults[result.BatchKeyIndex-1] = true
		}

		for i, hasResult := range hasResults {
			if !hasResult {
				errors[i] = d.getNotFoundError(params[i])
			}
		}

		return results, errors
	}
}
