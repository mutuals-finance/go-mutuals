// Code generated by github.com/SplitFi/go-splitfi/cmd/dataloaders, DO NOT EDIT.

package dataloader

import (
	"context"
	"time"

	"github.com/jackc/pgx/v4"

	"github.com/SplitFi/go-splitfi/service/persist"

	"github.com/SplitFi/go-splitfi/db/gen/coredb"
)

type Loaders struct {
	GetNotificationByIDBatch              *GetNotificationByIDBatch
	GetSplitByChainAddressBatch           *GetSplitByChainAddressBatch
	GetSplitByIdBatch                     *GetSplitByIdBatch
	GetSplitsByRecipientAddressBatch      *GetSplitsByRecipientAddressBatch
	GetSplitsByRecipientChainAddressBatch *GetSplitsByRecipientChainAddressBatch
	GetUserByChainAddressBatch            *GetUserByChainAddressBatch
	GetUserByIdBatch                      *GetUserByIdBatch
	GetUserByUsernameBatch                *GetUserByUsernameBatch
	GetUserNotificationsBatch             *GetUserNotificationsBatch
	GetUsersByPositionPaginateBatch       *GetUsersByPositionPaginateBatch
	GetUsersByPositionPersonalizedBatch   *GetUsersByPositionPersonalizedBatch
	GetUsersWithTraitBatch                *GetUsersWithTraitBatch
	GetWalletByChainAddressBatch          *GetWalletByChainAddressBatch
	GetWalletByIDBatch                    *GetWalletByIDBatch
	GetWalletsByUserIDBatch               *GetWalletsByUserIDBatch
}

func NewLoaders(ctx context.Context, q *coredb.Queries, disableCaching bool, preFetchHook PreFetchHook, postFetchHook PostFetchHook) *Loaders {
	loaders := &Loaders{}

	loaders.GetNotificationByIDBatch = newGetNotificationByIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetNotificationByIDBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitByChainAddressBatch = newGetSplitByChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitByChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitByIdBatch = newGetSplitByIdBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitByIdBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitsByRecipientAddressBatch = newGetSplitsByRecipientAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitsByRecipientAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitsByRecipientChainAddressBatch = newGetSplitsByRecipientChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitsByRecipientChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserByChainAddressBatch = newGetUserByChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserByIdBatch = newGetUserByIdBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByIdBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserByUsernameBatch = newGetUserByUsernameBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByUsernameBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserNotificationsBatch = newGetUserNotificationsBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserNotificationsBatch(q), preFetchHook, postFetchHook)
	loaders.GetUsersByPositionPaginateBatch = newGetUsersByPositionPaginateBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUsersByPositionPaginateBatch(q), preFetchHook, postFetchHook)
	loaders.GetUsersByPositionPersonalizedBatch = newGetUsersByPositionPersonalizedBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUsersByPositionPersonalizedBatch(q), preFetchHook, postFetchHook)
	loaders.GetUsersWithTraitBatch = newGetUsersWithTraitBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUsersWithTraitBatch(q), preFetchHook, postFetchHook)
	loaders.GetWalletByChainAddressBatch = newGetWalletByChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetWalletByChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetWalletByIDBatch = newGetWalletByIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetWalletByIDBatch(q), preFetchHook, postFetchHook)
	loaders.GetWalletsByUserIDBatch = newGetWalletsByUserIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetWalletsByUserIDBatch(q), preFetchHook, postFetchHook)

	loaders.GetUserNotificationsBatch.RegisterResultSubscriber(func(result []coredb.Notification) {
		for _, entry := range result {
			loaders.GetNotificationByIDBatch.Prime(loaders.GetNotificationByIDBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetSplitByChainAddressBatch.RegisterResultSubscriber(func(result coredb.Split) {
		loaders.GetSplitByIdBatch.Prime(loaders.GetSplitByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetSplitsByRecipientAddressBatch.RegisterResultSubscriber(func(result []coredb.Split) {
		for _, entry := range result {
			loaders.GetSplitByIdBatch.Prime(loaders.GetSplitByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetSplitsByRecipientChainAddressBatch.RegisterResultSubscriber(func(result []coredb.Split) {
		for _, entry := range result {
			loaders.GetSplitByIdBatch.Prime(loaders.GetSplitByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUserByChainAddressBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetUserByUsernameBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetUsersByPositionPaginateBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUsersByPositionPersonalizedBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUsersWithTraitBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUserByChainAddressBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(result), result)
	})
	loaders.GetUserByIdBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(result), result)
	})
	loaders.GetUsersByPositionPaginateBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUsersByPositionPersonalizedBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUsersWithTraitBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetWalletByChainAddressBatch.RegisterResultSubscriber(func(result coredb.Wallet) {
		loaders.GetWalletByIDBatch.Prime(loaders.GetWalletByIDBatch.getKeyForResult(result), result)
	})
	loaders.GetWalletsByUserIDBatch.RegisterResultSubscriber(func(result []coredb.Wallet) {
		for _, entry := range result {
			loaders.GetWalletByIDBatch.Prime(loaders.GetWalletByIDBatch.getKeyForResult(entry), entry)
		}
	})

	return loaders
}

func loadGetNotificationByIDBatch(q *coredb.Queries) func(context.Context, *GetNotificationByIDBatch, []persist.DBID) ([]coredb.Notification, []error) {
	return func(ctx context.Context, d *GetNotificationByIDBatch, params []persist.DBID) ([]coredb.Notification, []error) {
		results := make([]coredb.Notification, len(params))
		errors := make([]error, len(params))

		b := q.GetNotificationByIDBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Notification, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitByChainAddressBatch(q *coredb.Queries) func(context.Context, *GetSplitByChainAddressBatch, []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitByChainAddressBatch, params []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error) {
		results := make([]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitByChainAddressBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Split, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitByIdBatch(q *coredb.Queries) func(context.Context, *GetSplitByIdBatch, []persist.DBID) ([]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitByIdBatch, params []persist.DBID) ([]coredb.Split, []error) {
		results := make([]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitByIdBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Split, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitsByRecipientAddressBatch(q *coredb.Queries) func(context.Context, *GetSplitsByRecipientAddressBatch, []persist.Address) ([][]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitsByRecipientAddressBatch, params []persist.Address) ([][]coredb.Split, []error) {
		results := make([][]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitsByRecipientAddressBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Split, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetSplitsByRecipientChainAddressBatch(q *coredb.Queries) func(context.Context, *GetSplitsByRecipientChainAddressBatch, []coredb.GetSplitsByRecipientChainAddressBatchParams) ([][]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitsByRecipientChainAddressBatch, params []coredb.GetSplitsByRecipientChainAddressBatchParams) ([][]coredb.Split, []error) {
		results := make([][]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitsByRecipientChainAddressBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Split, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetUserByChainAddressBatch(q *coredb.Queries) func(context.Context, *GetUserByChainAddressBatch, []coredb.GetUserByChainAddressBatchParams) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByChainAddressBatch, params []coredb.GetUserByChainAddressBatchParams) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByChainAddressBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserByIdBatch(q *coredb.Queries) func(context.Context, *GetUserByIdBatch, []persist.DBID) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByIdBatch, params []persist.DBID) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByIdBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserByUsernameBatch(q *coredb.Queries) func(context.Context, *GetUserByUsernameBatch, []string) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByUsernameBatch, params []string) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByUsernameBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserNotificationsBatch(q *coredb.Queries) func(context.Context, *GetUserNotificationsBatch, []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
	return func(ctx context.Context, d *GetUserNotificationsBatch, params []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
		results := make([][]coredb.Notification, len(params))
		errors := make([]error, len(params))

		b := q.GetUserNotificationsBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Notification, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetUsersByPositionPaginateBatch(q *coredb.Queries) func(context.Context, *GetUsersByPositionPaginateBatch, []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error) {
	return func(ctx context.Context, d *GetUsersByPositionPaginateBatch, params []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error) {
		results := make([][]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUsersByPositionPaginateBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.User, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetUsersByPositionPersonalizedBatch(q *coredb.Queries) func(context.Context, *GetUsersByPositionPersonalizedBatch, [][]string) ([][]coredb.User, []error) {
	return func(ctx context.Context, d *GetUsersByPositionPersonalizedBatch, params [][]string) ([][]coredb.User, []error) {
		results := make([][]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUsersByPositionPersonalizedBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.User, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetUsersWithTraitBatch(q *coredb.Queries) func(context.Context, *GetUsersWithTraitBatch, []string) ([][]coredb.User, []error) {
	return func(ctx context.Context, d *GetUsersWithTraitBatch, params []string) ([][]coredb.User, []error) {
		results := make([][]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUsersWithTraitBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.User, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetWalletByChainAddressBatch(q *coredb.Queries) func(context.Context, *GetWalletByChainAddressBatch, []coredb.GetWalletByChainAddressBatchParams) ([]coredb.Wallet, []error) {
	return func(ctx context.Context, d *GetWalletByChainAddressBatch, params []coredb.GetWalletByChainAddressBatchParams) ([]coredb.Wallet, []error) {
		results := make([]coredb.Wallet, len(params))
		errors := make([]error, len(params))

		b := q.GetWalletByChainAddressBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Wallet, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetWalletByIDBatch(q *coredb.Queries) func(context.Context, *GetWalletByIDBatch, []persist.DBID) ([]coredb.Wallet, []error) {
	return func(ctx context.Context, d *GetWalletByIDBatch, params []persist.DBID) ([]coredb.Wallet, []error) {
		results := make([]coredb.Wallet, len(params))
		errors := make([]error, len(params))

		b := q.GetWalletByIDBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Wallet, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetWalletsByUserIDBatch(q *coredb.Queries) func(context.Context, *GetWalletsByUserIDBatch, []persist.DBID) ([][]coredb.Wallet, []error) {
	return func(ctx context.Context, d *GetWalletsByUserIDBatch, params []persist.DBID) ([][]coredb.Wallet, []error) {
		results := make([][]coredb.Wallet, len(params))
		errors := make([]error, len(params))

		b := q.GetWalletsByUserIDBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Wallet, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}
