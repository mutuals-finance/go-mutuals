// Code generated by github.com/SplitFi/go-splitfi/cmd/dataloaders, DO NOT EDIT.

package dataloader

import (
	"context"
	"time"

	"github.com/jackc/pgx/v4"

	"github.com/SplitFi/go-splitfi/service/persist"

	"github.com/SplitFi/go-splitfi/db/gen/coredb"
)

type Loaders struct {
	GetNotificationByIDBatch            *GetNotificationByIDBatch
	GetSplitByChainAddressBatch         *GetSplitByChainAddressBatch
	GetSplitByIdBatch                   *GetSplitByIdBatch
	GetSplitsByUserIDBatch              *GetSplitsByUserIDBatch
	GetUserByAddressAndL1Batch          *GetUserByAddressAndL1Batch
	GetUserByIdBatch                    *GetUserByIdBatch
	GetUserByUsernameBatch              *GetUserByUsernameBatch
	GetUserNotificationsBatch           *GetUserNotificationsBatch
	GetUsersByPositionPaginateBatch     *GetUsersByPositionPaginateBatch
	GetUsersByPositionPersonalizedBatch *GetUsersByPositionPersonalizedBatch
	GetWalletByIDBatch                  *GetWalletByIDBatch
	GetWalletsByUserIDBatch             *GetWalletsByUserIDBatch
}

func NewLoaders(ctx context.Context, q *coredb.Queries, disableCaching bool, preFetchHook PreFetchHook, postFetchHook PostFetchHook) *Loaders {
	loaders := &Loaders{}

	loaders.GetNotificationByIDBatch = newGetNotificationByIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetNotificationByIDBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitByChainAddressBatch = newGetSplitByChainAddressBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitByChainAddressBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitByIdBatch = newGetSplitByIdBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitByIdBatch(q), preFetchHook, postFetchHook)
	loaders.GetSplitsByUserIDBatch = newGetSplitsByUserIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetSplitsByUserIDBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserByAddressAndL1Batch = newGetUserByAddressAndL1Batch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByAddressAndL1Batch(q), preFetchHook, postFetchHook)
	loaders.GetUserByIdBatch = newGetUserByIdBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByIdBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserByUsernameBatch = newGetUserByUsernameBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserByUsernameBatch(q), preFetchHook, postFetchHook)
	loaders.GetUserNotificationsBatch = newGetUserNotificationsBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUserNotificationsBatch(q), preFetchHook, postFetchHook)
	loaders.GetUsersByPositionPaginateBatch = newGetUsersByPositionPaginateBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUsersByPositionPaginateBatch(q), preFetchHook, postFetchHook)
	loaders.GetUsersByPositionPersonalizedBatch = newGetUsersByPositionPersonalizedBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetUsersByPositionPersonalizedBatch(q), preFetchHook, postFetchHook)
	loaders.GetWalletByIDBatch = newGetWalletByIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetWalletByIDBatch(q), preFetchHook, postFetchHook)
	loaders.GetWalletsByUserIDBatch = newGetWalletsByUserIDBatch(ctx, 100, time.Duration(2000000), !disableCaching, true, loadGetWalletsByUserIDBatch(q), preFetchHook, postFetchHook)

	loaders.GetUserNotificationsBatch.RegisterResultSubscriber(func(result []coredb.Notification) {
		for _, entry := range result {
			loaders.GetNotificationByIDBatch.Prime(loaders.GetNotificationByIDBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetSplitByChainAddressBatch.RegisterResultSubscriber(func(result coredb.Split) {
		loaders.GetSplitByIdBatch.Prime(loaders.GetSplitByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetSplitsByUserIDBatch.RegisterResultSubscriber(func(result []coredb.Split) {
		for _, entry := range result {
			loaders.GetSplitByIdBatch.Prime(loaders.GetSplitByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUserByAddressAndL1Batch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetUserByUsernameBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(result), result)
	})
	loaders.GetUsersByPositionPaginateBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUsersByPositionPersonalizedBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByIdBatch.Prime(loaders.GetUserByIdBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUserByAddressAndL1Batch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(result), result)
	})
	loaders.GetUserByIdBatch.RegisterResultSubscriber(func(result coredb.User) {
		loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(result), result)
	})
	loaders.GetUsersByPositionPaginateBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetUsersByPositionPersonalizedBatch.RegisterResultSubscriber(func(result []coredb.User) {
		for _, entry := range result {
			loaders.GetUserByUsernameBatch.Prime(loaders.GetUserByUsernameBatch.getKeyForResult(entry), entry)
		}
	})
	loaders.GetWalletsByUserIDBatch.RegisterResultSubscriber(func(result []coredb.Wallet) {
		for _, entry := range result {
			loaders.GetWalletByIDBatch.Prime(loaders.GetWalletByIDBatch.getKeyForResult(entry), entry)
		}
	})

	return loaders
}

func loadGetNotificationByIDBatch(q *coredb.Queries) func(context.Context, *GetNotificationByIDBatch, []persist.DBID) ([]coredb.Notification, []error) {
	return func(ctx context.Context, d *GetNotificationByIDBatch, params []persist.DBID) ([]coredb.Notification, []error) {
		results := make([]coredb.Notification, len(params))
		errors := make([]error, len(params))

		b := q.GetNotificationByIDBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Notification, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitByChainAddressBatch(q *coredb.Queries) func(context.Context, *GetSplitByChainAddressBatch, []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitByChainAddressBatch, params []coredb.GetSplitByChainAddressBatchParams) ([]coredb.Split, []error) {
		results := make([]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitByChainAddressBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Split, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitByIdBatch(q *coredb.Queries) func(context.Context, *GetSplitByIdBatch, []persist.DBID) ([]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitByIdBatch, params []persist.DBID) ([]coredb.Split, []error) {
		results := make([]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitByIdBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Split, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetSplitsByUserIDBatch(q *coredb.Queries) func(context.Context, *GetSplitsByUserIDBatch, []persist.DBID) ([][]coredb.Split, []error) {
	return func(ctx context.Context, d *GetSplitsByUserIDBatch, params []persist.DBID) ([][]coredb.Split, []error) {
		results := make([][]coredb.Split, len(params))
		errors := make([]error, len(params))

		b := q.GetSplitsByUserIDBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Split, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetUserByAddressAndL1Batch(q *coredb.Queries) func(context.Context, *GetUserByAddressAndL1Batch, []coredb.GetUserByAddressAndL1BatchParams) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByAddressAndL1Batch, params []coredb.GetUserByAddressAndL1BatchParams) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByAddressAndL1Batch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserByIdBatch(q *coredb.Queries) func(context.Context, *GetUserByIdBatch, []persist.DBID) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByIdBatch, params []persist.DBID) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByIdBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserByUsernameBatch(q *coredb.Queries) func(context.Context, *GetUserByUsernameBatch, []string) ([]coredb.User, []error) {
	return func(ctx context.Context, d *GetUserByUsernameBatch, params []string) ([]coredb.User, []error) {
		results := make([]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUserByUsernameBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.User, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetUserNotificationsBatch(q *coredb.Queries) func(context.Context, *GetUserNotificationsBatch, []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
	return func(ctx context.Context, d *GetUserNotificationsBatch, params []coredb.GetUserNotificationsBatchParams) ([][]coredb.Notification, []error) {
		results := make([][]coredb.Notification, len(params))
		errors := make([]error, len(params))

		b := q.GetUserNotificationsBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Notification, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetUsersByPositionPaginateBatch(q *coredb.Queries) func(context.Context, *GetUsersByPositionPaginateBatch, []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error) {
	return func(ctx context.Context, d *GetUsersByPositionPaginateBatch, params []coredb.GetUsersByPositionPaginateBatchParams) ([][]coredb.User, []error) {
		results := make([][]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUsersByPositionPaginateBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.User, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetUsersByPositionPersonalizedBatch(q *coredb.Queries) func(context.Context, *GetUsersByPositionPersonalizedBatch, [][]string) ([][]coredb.User, []error) {
	return func(ctx context.Context, d *GetUsersByPositionPersonalizedBatch, params [][]string) ([][]coredb.User, []error) {
		results := make([][]coredb.User, len(params))
		errors := make([]error, len(params))

		b := q.GetUsersByPositionPersonalizedBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.User, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}

func loadGetWalletByIDBatch(q *coredb.Queries) func(context.Context, *GetWalletByIDBatch, []persist.DBID) ([]coredb.Wallet, []error) {
	return func(ctx context.Context, d *GetWalletByIDBatch, params []persist.DBID) ([]coredb.Wallet, []error) {
		results := make([]coredb.Wallet, len(params))
		errors := make([]error, len(params))

		b := q.GetWalletByIDBatch(ctx, params)
		defer b.Close()

		b.QueryRow(func(i int, r coredb.Wallet, err error) {
			results[i], errors[i] = r, err
			if errors[i] == pgx.ErrNoRows {
				errors[i] = d.getNotFoundError(params[i])
			}
		})

		return results, errors
	}
}

func loadGetWalletsByUserIDBatch(q *coredb.Queries) func(context.Context, *GetWalletsByUserIDBatch, []persist.DBID) ([][]coredb.Wallet, []error) {
	return func(ctx context.Context, d *GetWalletsByUserIDBatch, params []persist.DBID) ([][]coredb.Wallet, []error) {
		results := make([][]coredb.Wallet, len(params))
		errors := make([]error, len(params))

		b := q.GetWalletsByUserIDBatch(ctx, params)
		defer b.Close()

		b.Query(func(i int, r []coredb.Wallet, err error) {
			results[i], errors[i] = r, err
		})

		return results, errors
	}
}
