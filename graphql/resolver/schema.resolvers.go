package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"

	"github.com/SplitFi/go-splitfi/graphql/generated"
	"github.com/SplitFi/go-splitfi/graphql/model"
	"github.com/SplitFi/go-splitfi/publicapi"
	"github.com/SplitFi/go-splitfi/service/auth"
	"github.com/SplitFi/go-splitfi/service/emails"
	"github.com/SplitFi/go-splitfi/service/mediamapper"
	"github.com/SplitFi/go-splitfi/service/persist"
)

// Token is the resolver for the token field.
func (r *assetResolver) Token(ctx context.Context, obj *model.Asset) (*model.Token, error) {
	panic(fmt.Errorf("not implemented: Token - token"))
}

// AddUserWallet is the resolver for the addUserWallet field.
func (r *mutationResolver) AddUserWallet(ctx context.Context, chainAddress persist.ChainAddress, authMechanism model.AuthMechanism) (model.AddUserWalletPayloadOrError, error) {
	api := publicapi.For(ctx)

	authenticator, err := r.authMechanismToAuthenticator(ctx, authMechanism)
	if err != nil {
		return nil, err
	}

	err = api.User.AddWalletToUser(ctx, chainAddress, authenticator)
	if err != nil {
		return nil, err
	}

	output := &model.AddUserWalletPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// RemoveUserWallets is the resolver for the removeUserWallets field.
func (r *mutationResolver) RemoveUserWallets(ctx context.Context, walletIds []persist.DBID) (model.RemoveUserWalletsPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.User.RemoveWalletsFromUser(ctx, walletIds)
	if err != nil {
		return nil, err
	}

	output := &model.RemoveUserWalletsPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// UpdateUserInfo is the resolver for the updateUserInfo field.
func (r *mutationResolver) UpdateUserInfo(ctx context.Context, input model.UpdateUserInfoInput) (model.UpdateUserInfoPayloadOrError, error) {
	api := publicapi.For(ctx)

	err := api.User.UpdateUserInfo(ctx, input.Username, input.Bio)
	if err != nil {
		return nil, err
	}

	output := &model.UpdateUserInfoPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// RegisterUserPushToken is the resolver for the registerUserPushToken field.
func (r *mutationResolver) RegisterUserPushToken(ctx context.Context, pushToken string) (model.RegisterUserPushTokenPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: RegisterUserPushToken - registerUserPushToken"))
}

// UnregisterUserPushToken is the resolver for the unregisterUserPushToken field.
func (r *mutationResolver) UnregisterUserPushToken(ctx context.Context, pushToken string) (model.UnregisterUserPushTokenPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: UnregisterUserPushToken - unregisterUserPushToken"))
}

// GetAuthNonce is the resolver for the getAuthNonce field.
func (r *mutationResolver) GetAuthNonce(ctx context.Context) (model.GetAuthNoncePayloadOrError, error) {
	nonce, message, err := publicapi.For(ctx).Auth.GetAuthNonce(ctx)
	if err != nil {
		return nil, err
	}

	output := &model.AuthNonce{
		Nonce:   &nonce,
		Message: &message,
	}

	return output, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, authMechanism model.AuthMechanism, input model.CreateUserInput) (model.CreateUserPayloadOrError, error) {
	authenticator, err := r.authMechanismToAuthenticator(ctx, authMechanism)
	if err != nil {
		return nil, err
	}

	userName := ""
	if input.Username != nil {
		userName = *input.Username
	}

	bioStr := ""
	if input.Bio != nil {
		bioStr = *input.Bio
	}

	var email *persist.Email
	if input.Email != nil {
		it := persist.Email(*input.Email)
		email = &it
	}

	userID, err := publicapi.For(ctx).User.CreateUser(ctx, authenticator, userName, email, bioStr)
	if err != nil {
		return nil, err
	}

	output := &model.CreateUserPayload{
		UserID: &userID,
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// UpdateEmail is the resolver for the updateEmail field.
func (r *mutationResolver) UpdateEmail(ctx context.Context, input model.UpdateEmailInput) (model.UpdateEmailPayloadOrError, error) {
	var authenticator *auth.Authenticator

	if input.AuthMechanism != nil {
		a, err := r.authMechanismToAuthenticator(ctx, *input.AuthMechanism)
		if err != nil {
			return nil, err
		}
		authenticator = &a
	}

	return updateUserEmail(ctx, input.Email, authenticator)
}

// ResendVerificationEmail is the resolver for the resendVerificationEmail field.
func (r *mutationResolver) ResendVerificationEmail(ctx context.Context) (model.ResendVerificationEmailPayloadOrError, error) {
	return resendEmailVerification(ctx)
}

// UpdateEmailNotificationSettings is the resolver for the updateEmailNotificationSettings field.
func (r *mutationResolver) UpdateEmailNotificationSettings(ctx context.Context, input model.UpdateEmailNotificationSettingsInput) (model.UpdateEmailNotificationSettingsPayloadOrError, error) {
	return updateUserEmailNotificationSettings(ctx, input)
}

// UnsubscribeFromEmailType is the resolver for the unsubscribeFromEmailType field.
func (r *mutationResolver) UnsubscribeFromEmailType(ctx context.Context, input model.UnsubscribeFromEmailTypeInput) (model.UnsubscribeFromEmailTypePayloadOrError, error) {
	return unsubscribeFromEmailType(ctx, input)
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, authMechanism model.AuthMechanism) (model.LoginPayloadOrError, error) {
	authenticator, err := r.authMechanismToAuthenticator(ctx, authMechanism)
	if err != nil {
		return nil, err
	}

	userId, err := publicapi.For(ctx).Auth.Login(ctx, authenticator)
	if err != nil {
		return nil, err
	}

	output := &model.LoginPayload{
		UserID: &userId,
		Viewer: resolveViewer(ctx),
	}
	return output, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, pushTokenToUnregister *string) (*model.LogoutPayload, error) {
	publicapi.For(ctx).Auth.Logout(ctx)

	output := &model.LogoutPayload{
		Viewer: resolveViewer(ctx),
	}

	return output, nil
}

// ViewSplit is the resolver for the viewSplit field.
func (r *mutationResolver) ViewSplit(ctx context.Context, splitID persist.DBID) (model.ViewSplitPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: ViewSplit - viewSplit"))
}

// UpdateSplit is the resolver for the updateSplit field.
func (r *mutationResolver) UpdateSplit(ctx context.Context, input model.UpdateSplitInput) (model.UpdateSplitPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: UpdateSplit - updateSplit"))
}

// PublishSplit is the resolver for the publishSplit field.
func (r *mutationResolver) PublishSplit(ctx context.Context, input model.PublishSplitInput) (model.PublishSplitPayloadOrError, error) {
	err := publicapi.For(ctx).Split.PublishSplit(ctx, input)
	if err != nil {
		return nil, err
	}

	gal, err := resolveSplitBySplitID(ctx, input.SplitID)
	if err != nil {
		return nil, err
	}

	return &model.PublishSplitPayload{
		Split: gal,
	}, nil
}

// CreateSplit is the resolver for the createSplit field.
func (r *mutationResolver) CreateSplit(ctx context.Context, input model.CreateSplitInput) (model.CreateSplitPayloadOrError, error) {
	split, err := publicapi.For(ctx).Split.CreateSplit(ctx, input.Name, input.Description, input.Logo)
	if err != nil {
		return nil, err
	}

	output := &model.CreateSplitPayload{
		Split: splitToModel(ctx, split),
	}

	return output, nil
}

// UpdateSplitHidden is the resolver for the updateSplitHidden field.
func (r *mutationResolver) UpdateSplitHidden(ctx context.Context, input model.UpdateSplitHiddenInput) (model.UpdateSplitHiddenPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: UpdateSplitHidden - updateSplitHidden"))
}

// DeleteSplit is the resolver for the deleteSplit field.
func (r *mutationResolver) DeleteSplit(ctx context.Context, splitID persist.DBID) (model.DeleteSplitPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: DeleteSplit - deleteSplit"))
}

// UpdateSplitOrder is the resolver for the updateSplitOrder field.
func (r *mutationResolver) UpdateSplitOrder(ctx context.Context, input model.UpdateSplitOrderInput) (model.UpdateSplitOrderPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: UpdateSplitOrder - updateSplitOrder"))
}

// UpdateSplitInfo is the resolver for the updateSplitInfo field.
func (r *mutationResolver) UpdateSplitInfo(ctx context.Context, input model.UpdateSplitInfoInput) (model.UpdateSplitInfoPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: UpdateSplitInfo - updateSplitInfo"))
}

// ClearAllNotifications is the resolver for the clearAllNotifications field.
func (r *mutationResolver) ClearAllNotifications(ctx context.Context) (*model.ClearAllNotificationsPayload, error) {
	notifications, err := publicapi.For(ctx).Notifications.ClearUserNotifications(ctx)
	if err != nil {
		return nil, err
	}

	models := make([]model.Notification, len(notifications))
	for i, n := range notifications {
		model, err := notificationToModel(n)
		if err != nil {
			return nil, err
		}
		models[i] = model
	}

	output := &model.ClearAllNotificationsPayload{
		Notifications: models,
	}
	return output, nil
}

// UpdateNotificationSettings is the resolver for the updateNotificationSettings field.
func (r *mutationResolver) UpdateNotificationSettings(ctx context.Context, settings *model.NotificationSettingsInput) (*model.NotificationSettings, error) {
	//TODO
	err := publicapi.For(ctx).User.UpdateUserNotificationSettings(ctx, persist.UserNotificationSettings{})
	if err != nil {
		return nil, err
	}
	return resolveViewerNotificationSettings(ctx)
}

// PreverifyEmail is the resolver for the preverifyEmail field.
func (r *mutationResolver) PreverifyEmail(ctx context.Context, input model.PreverifyEmailInput) (model.PreverifyEmailPayloadOrError, error) {
	// todo we could have the frontend send the source? right now I don't see any other sources of verification other than signing up
	result, err := emails.PreverifyEmail(ctx, input.Email, "signup")
	if err != nil {
		return nil, err
	}

	var modelResult model.PreverifyEmailResult

	switch result.Result {
	case emails.PreverifyEmailResultValid:
		modelResult = model.PreverifyEmailResultValid
	case emails.PreverifyEmailResultInvalid:
		modelResult = model.PreverifyEmailResultInvalid
	case emails.PreverifyEmailResultRisky:
		modelResult = model.PreverifyEmailResultRisky
	default:
		return nil, fmt.Errorf("unknown preverify result: %d", result.Result)
	}

	return model.PreverifyEmailPayload{
		Email:  input.Email,
		Result: modelResult,
	}, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, input model.VerifyEmailInput) (model.VerifyEmailPayloadOrError, error) {
	return verifyEmail(ctx, input.Token)
}

// VerifyEmailMagicLink is the resolver for the verifyEmailMagicLink field.
func (r *mutationResolver) VerifyEmailMagicLink(ctx context.Context, input model.VerifyEmailMagicLinkInput) (model.VerifyEmailMagicLinkPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: VerifyEmailMagicLink - verifyEmailMagicLink"))
}

// OptInForRoles is the resolver for the optInForRoles field.
func (r *mutationResolver) OptInForRoles(ctx context.Context, roles []persist.Role) (model.OptInForRolesPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: OptInForRoles - optInForRoles"))
}

// OptOutForRoles is the resolver for the optOutForRoles field.
func (r *mutationResolver) OptOutForRoles(ctx context.Context, roles []persist.Role) (model.OptOutForRolesPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: OptOutForRoles - optOutForRoles"))
}

// AddRolesToUser is the resolver for the addRolesToUser field.
func (r *mutationResolver) AddRolesToUser(ctx context.Context, username string, roles []*persist.Role) (model.AddRolesToUserPayloadOrError, error) {
	user, err := publicapi.For(ctx).Admin.AddRolesToUser(ctx, username, roles)

	if err != nil {
		return nil, err
	}

	return userToModel(ctx, *user), nil
}

// AddWalletToUserUnchecked is the resolver for the addWalletToUserUnchecked field.
func (r *mutationResolver) AddWalletToUserUnchecked(ctx context.Context, input model.AdminAddWalletInput) (model.AdminAddWalletPayloadOrError, error) {
	err := publicapi.For(ctx).Admin.AddWalletToUserUnchecked(ctx, input.Username, *input.ChainAddress, input.WalletType)
	if err != nil {
		return nil, err
	}

	user, err := publicapi.For(ctx).User.GetUserByUsername(ctx, input.Username)
	if err != nil {
		return nil, err
	}

	return model.AdminAddWalletPayload{User: userToModel(ctx, *user)}, nil
}

// RevokeRolesFromUser is the resolver for the revokeRolesFromUser field.
func (r *mutationResolver) RevokeRolesFromUser(ctx context.Context, username string, roles []*persist.Role) (model.RevokeRolesFromUserPayloadOrError, error) {
	user, err := publicapi.For(ctx).Admin.RemoveRolesFromUser(ctx, username, roles)

	if err != nil {
		return nil, err
	}

	return userToModel(ctx, *user), nil
}

// UploadPersistedQueries is the resolver for the uploadPersistedQueries field.
func (r *mutationResolver) UploadPersistedQueries(ctx context.Context, input *model.UploadPersistedQueriesInput) (model.UploadPersistedQueriesPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: UploadPersistedQueries - uploadPersistedQueries"))
}

// UpdatePrimaryWallet is the resolver for the updatePrimaryWallet field.
func (r *mutationResolver) UpdatePrimaryWallet(ctx context.Context, walletID persist.DBID) (model.UpdatePrimaryWalletPayloadOrError, error) {
	err := publicapi.For(ctx).User.UpdateUserPrimaryWallet(ctx, walletID)
	if err != nil {
		return nil, err
	}
	return model.UpdatePrimaryWalletPayload{
		Viewer: resolveViewer(ctx),
	}, nil
}

// UpdateUserExperience is the resolver for the updateUserExperience field.
func (r *mutationResolver) UpdateUserExperience(ctx context.Context, input model.UpdateUserExperienceInput) (model.UpdateUserExperiencePayloadOrError, error) {
	err := publicapi.For(ctx).User.UpdateUserExperience(ctx, input.ExperienceType, input.Experienced)
	if err != nil {
		return nil, err
	}
	return model.UpdateUserExperiencePayload{
		Viewer: resolveViewer(ctx),
	}, nil
}

// Blurhash is the resolver for the blurhash field.
func (r *previewURLSetResolver) Blurhash(ctx context.Context, obj *model.PreviewURLSet) (*string, error) {
	mm := mediamapper.For(ctx)

	return mm.GetBlurhash(*obj.Raw), nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id model.GqlID) (model.Node, error) {
	return nodeFetcher.GetNodeByGqlID(ctx, id)
}

// Viewer is the resolver for the viewer field.
func (r *queryResolver) Viewer(ctx context.Context) (model.ViewerOrError, error) {
	return resolveViewer(ctx), nil
}

// UserByUsername is the resolver for the userByUsername field.
func (r *queryResolver) UserByUsername(ctx context.Context, username string) (model.UserByUsernameOrError, error) {
	return resolveSplitFiUserByUsername(ctx, username)
}

// UserByID is the resolver for the userById field.
func (r *queryResolver) UserByID(ctx context.Context, id persist.DBID) (model.UserByIDOrError, error) {
	return resolveSplitFiUserByUserID(ctx, id)
}

// UserByAddress is the resolver for the userByAddress field.
func (r *queryResolver) UserByAddress(ctx context.Context, chainAddress persist.ChainAddress) (model.UserByAddressOrError, error) {
	return resolveSplitFiUserByAddress(ctx, chainAddress)
}

// UsersWithTrait is the resolver for the usersWithTrait field.
func (r *queryResolver) UsersWithTrait(ctx context.Context, trait string) ([]*model.SplitFiUser, error) {
	panic(fmt.Errorf("not implemented: UsersWithTrait - usersWithTrait"))
}

// SplitByID is the resolver for the splitById field.
func (r *queryResolver) SplitByID(ctx context.Context, id persist.DBID) (model.SplitByIDPayloadOrError, error) {
	split, err := resolveSplitBySplitID(ctx, id)

	if err != nil {
		return nil, err
	}

	return split, nil
}

// ViewerSplitByID is the resolver for the viewerSplitById field.
func (r *queryResolver) ViewerSplitByID(ctx context.Context, id persist.DBID) (model.ViewerSplitByIDPayloadOrError, error) {
	split, err := resolveViewerSplitBySplitID(ctx, id)

	if err != nil {
		return nil, err
	}

	return split, nil
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, query string, limit *int, usernameWeight *float64, bioWeight *float64) (model.SearchUsersPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: SearchUsers - searchUsers"))
}

// SearchSplits is the resolver for the searchSplits field.
func (r *queryResolver) SearchSplits(ctx context.Context, query string, limit *int, nameWeight *float64, descriptionWeight *float64) (model.SearchSplitsPayloadOrError, error) {
	panic(fmt.Errorf("not implemented: SearchSplits - searchSplits"))
}

// UsersByRole is the resolver for the usersByRole field.
func (r *queryResolver) UsersByRole(ctx context.Context, role persist.Role, before *string, after *string, first *int, last *int) (*model.UsersConnection, error) {
	users, pageInfo, err := publicapi.For(ctx).User.PaginateUsersWithRole(ctx, role, before, after, first, last)
	if err != nil {
		return nil, err
	}

	return &model.UsersConnection{
		Edges:    usersToEdges(ctx, users),
		PageInfo: pageInfoToModel(ctx, pageInfo),
	}, nil
}

// Split is the resolver for the split field.
func (r *recipientResolver) Split(ctx context.Context, obj *model.Recipient) (*model.Split, error) {
	panic(fmt.Errorf("not implemented: Split - split"))
}

// Assets is the resolver for the assets field.
func (r *splitResolver) Assets(ctx context.Context, obj *model.Split, limit *int) ([]*model.Asset, error) {
	panic(fmt.Errorf("not implemented: Assets - assets"))
}

// Shares is the resolver for the shares field.
func (r *splitResolver) Shares(ctx context.Context, obj *model.Split, limit *int) ([]*model.Recipient, error) {
	panic(fmt.Errorf("not implemented: Shares - shares"))
}

// Roles is the resolver for the roles field.
func (r *splitFiUserResolver) Roles(ctx context.Context, obj *model.SplitFiUser) ([]*persist.Role, error) {
	dbRoles, err := publicapi.For(ctx).User.GetUserRolesByUserID(ctx, obj.Dbid)
	if err != nil {
		return nil, err
	}

	roles := make([]*persist.Role, len(dbRoles))
	for i, role := range dbRoles {
		r := role
		roles[i] = &r
	}

	return roles, nil
}

// Wallets is the resolver for the wallets field.
func (r *splitFiUserResolver) Wallets(ctx context.Context, obj *model.SplitFiUser) ([]*model.Wallet, error) {
	return resolveWalletsByUserID(ctx, obj.Dbid)
}

// PrimaryWallet is the resolver for the primaryWallet field.
func (r *splitFiUserResolver) PrimaryWallet(ctx context.Context, obj *model.SplitFiUser) (*model.Wallet, error) {
	return resolvePrimaryWalletByUserID(ctx, obj.HelperSplitFiUserData.UserID)
}

// Splits is the resolver for the splits field.
func (r *splitFiUserResolver) Splits(ctx context.Context, obj *model.SplitFiUser) ([]*model.Split, error) {
	panic(fmt.Errorf("not implemented: Splits - splits"))
}

// SplitsByChain is the resolver for the splitsByChain field.
func (r *splitFiUserResolver) SplitsByChain(ctx context.Context, obj *model.SplitFiUser, chain persist.Chain) (*model.ChainSplits, error) {
	panic(fmt.Errorf("not implemented: SplitsByChain - splitsByChain"))
}

// NewNotification is the resolver for the newNotification field.
func (r *subscriptionResolver) NewNotification(ctx context.Context) (<-chan model.Notification, error) {
	return resolveNewNotificationSubscription(ctx), nil
}

// NotificationUpdated is the resolver for the notificationUpdated field.
func (r *subscriptionResolver) NotificationUpdated(ctx context.Context) (<-chan model.Notification, error) {
	return resolveUpdatedNotificationSubscription(ctx), nil
}

// EmailNotificationSettings is the resolver for the emailNotificationSettings field.
func (r *userEmailResolver) EmailNotificationSettings(ctx context.Context, obj *model.UserEmail) (*model.EmailNotificationSettings, error) {
	panic(fmt.Errorf("not implemented: EmailNotificationSettings - emailNotificationSettings"))
}

// User is the resolver for the user field.
func (r *viewerResolver) User(ctx context.Context, obj *model.Viewer) (*model.SplitFiUser, error) {
	userID := publicapi.For(ctx).User.GetLoggedInUserId(ctx)
	return resolveSplitFiUserByUserID(ctx, userID)
}

// ViewerSplits is the resolver for the viewerSplits field.
func (r *viewerResolver) ViewerSplits(ctx context.Context, obj *model.Viewer) ([]*model.ViewerSplit, error) {
	userID := publicapi.For(ctx).User.GetLoggedInUserId(ctx)

	splits, err := resolveSplitsByUserID(ctx, userID)

	if err != nil {
		return nil, err
	}

	output := make([]*model.ViewerSplit, len(splits))
	for i, split := range splits {
		output[i] = &model.ViewerSplit{
			Split: split,
		}
	}

	return output, nil
}

// Email is the resolver for the email field.
func (r *viewerResolver) Email(ctx context.Context, obj *model.Viewer) (*model.UserEmail, error) {
	return resolveViewerEmail(ctx), nil
}

// Notifications is the resolver for the notifications field.
func (r *viewerResolver) Notifications(ctx context.Context, obj *model.Viewer, before *string, after *string, first *int, last *int) (*model.NotificationsConnection, error) {
	return resolveViewerNotifications(ctx, before, after, first, last)
}

// NotificationSettings is the resolver for the notificationSettings field.
func (r *viewerResolver) NotificationSettings(ctx context.Context, obj *model.Viewer) (*model.NotificationSettings, error) {
	return resolveViewerNotificationSettings(ctx)
}

// UserExperiences is the resolver for the userExperiences field.
func (r *viewerResolver) UserExperiences(ctx context.Context, obj *model.Viewer) ([]*model.UserExperience, error) {
	return resolveViewerExperiencesByUserID(ctx, obj.UserId)
}

// Splits is the resolver for the splits field.
func (r *walletResolver) Splits(ctx context.Context, obj *model.Wallet) ([]*model.Split, error) {
	panic(fmt.Errorf("not implemented: Splits - splits"))
}

// Address is the resolver for the address field.
func (r *chainAddressInputResolver) Address(ctx context.Context, obj *persist.ChainAddress, data persist.Address) error {
	return obj.GQLSetAddressFromResolver(data)
}

// Chain is the resolver for the chain field.
func (r *chainAddressInputResolver) Chain(ctx context.Context, obj *persist.ChainAddress, data persist.Chain) error {
	return obj.GQLSetChainFromResolver(data)
}

// PubKey is the resolver for the pubKey field.
func (r *chainPubKeyInputResolver) PubKey(ctx context.Context, obj *persist.ChainPubKey, data persist.PubKey) error {
	return obj.GQLSetPubKeyFromResolver(data)
}

// Chain is the resolver for the chain field.
func (r *chainPubKeyInputResolver) Chain(ctx context.Context, obj *persist.ChainPubKey, data persist.Chain) error {
	return obj.GQLSetChainFromResolver(data)
}

// Asset returns generated.AssetResolver implementation.
func (r *Resolver) Asset() generated.AssetResolver { return &assetResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// PreviewURLSet returns generated.PreviewURLSetResolver implementation.
func (r *Resolver) PreviewURLSet() generated.PreviewURLSetResolver { return &previewURLSetResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Recipient returns generated.RecipientResolver implementation.
func (r *Resolver) Recipient() generated.RecipientResolver { return &recipientResolver{r} }

// Split returns generated.SplitResolver implementation.
func (r *Resolver) Split() generated.SplitResolver { return &splitResolver{r} }

// SplitFiUser returns generated.SplitFiUserResolver implementation.
func (r *Resolver) SplitFiUser() generated.SplitFiUserResolver { return &splitFiUserResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// UserEmail returns generated.UserEmailResolver implementation.
func (r *Resolver) UserEmail() generated.UserEmailResolver { return &userEmailResolver{r} }

// Viewer returns generated.ViewerResolver implementation.
func (r *Resolver) Viewer() generated.ViewerResolver { return &viewerResolver{r} }

// Wallet returns generated.WalletResolver implementation.
func (r *Resolver) Wallet() generated.WalletResolver { return &walletResolver{r} }

// ChainAddressInput returns generated.ChainAddressInputResolver implementation.
func (r *Resolver) ChainAddressInput() generated.ChainAddressInputResolver {
	return &chainAddressInputResolver{r}
}

// ChainPubKeyInput returns generated.ChainPubKeyInputResolver implementation.
func (r *Resolver) ChainPubKeyInput() generated.ChainPubKeyInputResolver {
	return &chainPubKeyInputResolver{r}
}

type assetResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type previewURLSetResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type recipientResolver struct{ *Resolver }
type splitResolver struct{ *Resolver }
type splitFiUserResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userEmailResolver struct{ *Resolver }
type viewerResolver struct{ *Resolver }
type walletResolver struct{ *Resolver }
type chainAddressInputResolver struct{ *Resolver }
type chainPubKeyInputResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
type setSpamPreferencePayloadResolver struct{ *Resolver }
