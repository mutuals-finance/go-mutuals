"""
Any field decorated with the @experimental directive should not be used in production.
It will not conform to our rules around breaking changes.
"""
directive @experimental on FIELD_DEFINITION

# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
  forceResolver: Boolean
  name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Add @authRequired to any field that requires a user to be logged in. NOTE: Any field tagged with
# @authRequired MUST return a union type that includes ErrNotAuthorized.
#
# If we need more control over auth in the future, this directive can be updated to take
# arguments that specify the level of access required.
directive @authRequired on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Add @basicAuth to any field that should be secured by a basic auth token. For example, some fields
# should only be usable by Retool, so they'd use @basicAuth(allowed: [Retool]). Other fields might be
# accessible by both Retool and Monitoring, so they'd use @basicAuth(allowed: [Retool, Monitoring]).
directive @basicAuth(allowed: [BasicAuthType!]!) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @frontendBuildAuth on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Use @scrub on any input field that should be omitted from request logging (e.g. passwords or
# other sensitive data)
directive @scrub on INPUT_FIELD_DEFINITION

# Use @restrictEnvironment to choose which values of the ENV environment variable the annotated field/object
# should be usable in (case-insensitive). Example: @restrictEnvironment(allowed:["local", "development"]) would
# allow a field in "local" and "development" environments but not in "production"
directive @restrictEnvironment(
  allowed: [String!]!
) on INPUT_FIELD_DEFINITION | INPUT_OBJECT | FIELD_DEFINITION | OBJECT

# All types that implement Node must have a unique GqlID set in their "id" field. For types with
# a "dbid" field, it's assumed that we can synthesize a unique ID from the type name and the dbid,
# so those types will automatically have an ID function generated for them (which gqlgen will find
# and bind to). Types without a dbid field, or types that need multiple inputs to create a unique ID
# that can be used to refetch the node in the future, must use the @goGqlId directive to explicitly
# state the fields that will be used to generate the ID. If a named field exists on the object and is
# a string-based type, that field will be used as part of the ID automatically. Otherwise, a manual
# getter method will need to be implemented to retrieve that component of the GqlID.
directive @goGqlId(fields: [String!]!) on OBJECT

# Injects a "Helper<TypeName>Data" struct embed into a generated type. Useful for adding backend-only
# helper data necessary to resolve queries, while keeping that data out of the schema and invisible
# to clients.
directive @goEmbedHelper on OBJECT

scalar Time
scalar Address
scalar PubKey
scalar DBID
scalar Email

enum BasicAuthType {
  Retool
  Monitoring
}

interface Node {
  id: ID!
}

type DeletedNode implements Node {
  id: ID!
  dbid: DBID!
}

interface Error {
  message: String!
}

type SplitFiUser implements Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  username: String
  bio: String
  traits: String
  universal: Boolean
  roles: [Role] @goField(forceResolver: true)

  wallets: [Wallet] @goField(forceResolver: true)
  primaryWallet: Wallet @goField(forceResolver: true)
  # Returns all splits owned by this user. Useful for retrieving all tokens without any duplicates,
  # as opposed to retrieving user -> wallets -> splits, which would contain duplicates for any token
  # that appears in more than one of the user's wallets.
  splits: [Split] @goField(forceResolver: true)
  splitsByChain(chain: Chain!): ChainSplits @goField(forceResolver: true)
  isAuthenticatedUser: Boolean
}

type Wallet implements Node {
  id: ID!
  dbid: DBID!
  chainAddress: ChainAddress
  chain: Chain
  walletType: WalletType
  splits: [Split] @goField(forceResolver: true)
}

type ChainAddress {
  address: Address
  chain: Chain
}

type ChainPubKey {
  pubKey: PubKey
  chain: Chain
}

type ChainTokens {
  chain: Chain
  tokens: [Token]
}

type ChainSplits {
  chain: Chain
  splits: [Split]
}

input ChainAddressInput {
  address: Address! @goField(forceResolver: true)
  chain: Chain! @goField(forceResolver: true)
}

input ChainPubKeyInput {
  pubKey: PubKey! @goField(forceResolver: true)
  chain: Chain! @goField(forceResolver: true)
}

union SplitFiUserOrWallet = SplitFiUser | Wallet

union SplitFiUserOrAddress = SplitFiUser | ChainAddress

union MediaSubtype =
    ImageMedia
  | GIFMedia
  | VideoMedia
  | AudioMedia
  | TextMedia
  | PdfMedia
  | HtmlMedia
  | JsonMedia
  | GltfMedia
  | UnknownMedia
  | InvalidMedia

type PreviewURLSet {
  raw: String
  thumbnail: String
  small: String
  medium: String
  large: String
  srcSet: String
  liveRender: String
  blurhash: String @experimental @goField(forceResolver: true)
}

type VideoURLSet {
  raw: String
  small: String
  medium: String
  large: String
}

type MediaDimensions {
  width: Int
  height: Int
  aspectRatio: Float
}

interface Media {
  # Various sizes of preview images for the media
  previewURLs: PreviewURLSet

  # The original source URL for the media (may be IPFS, etc)
  mediaURL: String

  # The type of media, as determined by the backend. May be redundant given the approach we're using here
  # (media subtypes implementing the Media interface)
  mediaType: String

  # All Media types will also have something like contentRenderURL or contentRenderURLs,
  # which are the URL(s) that should actually be used for rendering the media's content

  # The dimensions of the media, if known
  dimensions: MediaDimensions
}

type ImageMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type GIFMedia implements Media {
  previewURLs: PreviewURLSet
  staticPreviewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type VideoMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURLs: VideoURLSet
  dimensions: MediaDimensions
}

type AudioMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type TextMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type PdfMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type HtmlMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type JsonMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type GltfMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type UnknownMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type InvalidMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

enum TokenType {
  ERC721
  ERC1155
  ERC20
}

enum Chain {
  Ethereum
  Arbitrum
  Polygon
  Optimism
}

enum WalletType {
  EOA
  GnosisSafe
}

type Token implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  creationTime: Time
  lastUpdated: Time
  tokenType: TokenType
  chain: Chain
  name: String
  symbol: String
  decimals: Int
  logo: String
  totalSupply: Int
  contractAddress: Int
  blockNumber: String # source is uint64
  isSpam: Boolean
}

type Asset implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  ownerAddress: ChainAddress
  balance: Int
  token: Token @goField(forceResolver: true)
}

type Recipient implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  creationTime: Time
  lastUpdated: Time
  address: Address
  split: Split @goField(forceResolver: true)
  ownership: Int
}

type Split implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  name: String
  description: String
  chain: Chain
  logoURL: String
  bannerURL: String
  badgeURL: String
  assets(limit: Int): [Asset] @goField(forceResolver: true)
  shares(limit: Int): [Recipient] @goField(forceResolver: true)
}

# We have this extra type in case we need to stick authed data
# in here one day.
type ViewerSplit {
  split: Split
}

type NotificationEdge {
  node: Notification
  cursor: String
}

type NotificationsConnection @goEmbedHelper {
  edges: [NotificationEdge]
  unseenCount: Int
  pageInfo: PageInfo
}

type Viewer implements Node @goGqlId(fields: ["userId"]) @goEmbedHelper {
  id: ID!
  user: SplitFiUser @goField(forceResolver: true)
  viewerSplits: [ViewerSplit] @goField(forceResolver: true)

  email: UserEmail @goField(forceResolver: true)
  """
  Returns a list of notifications in reverse chronological order.
  Seen notifications come after unseen notifications
  """
  notifications(before: String, after: String, first: Int, last: Int): NotificationsConnection
    @goField(forceResolver: true)

  notificationSettings: NotificationSettings @goField(forceResolver: true)

  userExperiences: [UserExperience!] @goField(forceResolver: true)
}

type NotificationSettings {
  someoneFollowedYou: Boolean
  someoneViewedYourSplit: Boolean
}

input NotificationSettingsInput {
  someoneFollowedYou: Boolean
  someoneViewedYourSplit: Boolean
}

enum EmailVerificationStatus {
  Unverified
  Verified
  Failed
  Admin
}

enum EmailUnsubscriptionType {
  All
  Notifications
}

type UserEmail {
  email: Email
  verificationStatus: EmailVerificationStatus
  emailNotificationSettings: EmailNotificationSettings @goField(forceResolver: true)
}

type EmailNotificationSettings {
  unsubscribedFromAll: Boolean!
  unsubscribedFromNotifications: Boolean!
}

input UpdateEmailNotificationSettingsInput {
  unsubscribedFromAll: Boolean!
  unsubscribedFromNotifications: Boolean!
}

input UnsubscribeFromEmailTypeInput {
  type: EmailUnsubscriptionType!
  token: String! @scrub
}

enum UserExperienceType {
  EmailUpsell
  MaintenanceFeb2023
  TwitterConnectionOnboardingUpsell
  UpsellMintMemento4
}

type UserExperience {
  type: UserExperienceType!
  experienced: Boolean!
}

union UserByUsernameOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union UserByIdOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union UserByAddressOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union ViewerOrError = Viewer | ErrNotAuthorized

type ErrCollectionNotFound implements Error {
  message: String!
}

union TokenByIdOrError = Token | ErrTokenNotFound

type ErrTokenNotFound implements Error {
  message: String!
}

# Actions a user can take on a resource
enum Action {
  UserCreated
}

type PageInfo {
  total: Int
  size: Int!
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type UserEdge {
  node: SplitFiUser
  cursor: String
}

type UsersConnection {
  edges: [UserEdge]
  pageInfo: PageInfo!
}

enum Role {
  ADMIN
  BETA_TESTER
  EARLY_ACCESS
}

type ErrSplitNotFound implements Error {
  message: String!
}

union SplitByIdPayloadOrError = Split | ErrSplitNotFound
union ViewerSplitByIdPayloadOrError = ViewerSplit | ErrSplitNotFound

enum ReportWindow {
  LAST_5_DAYS
  LAST_7_DAYS
  ALL_TIME
}

type UserSearchResult {
  user: SplitFiUser
}

type SearchUsersPayload {
  results: [UserSearchResult!]
}

union SearchUsersPayloadOrError = SearchUsersPayload | ErrInvalidInput

type SplitSearchResult {
  split: Split
}

type SearchSplitsPayload {
  results: [SplitSearchResult!]
}

union SearchSplitsPayloadOrError = SearchSplitsPayload | ErrInvalidInput

type Query {
  node(id: ID!): Node
  viewer: ViewerOrError @authRequired
  userByUsername(username: String!): UserByUsernameOrError
  userById(id: DBID!): UserByIdOrError
  userByAddress(chainAddress: ChainAddressInput!): UserByAddressOrError
  usersWithTrait(trait: String!): [SplitFiUser]
  splitById(id: DBID!): SplitByIdPayloadOrError
  viewerSplitById(id: DBID!): ViewerSplitByIdPayloadOrError
  """
  Search for users with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. usernameWeight defaults to 0.4 and
  bioWeight defaults to 0.2, meaning that a search result matching a username is considered
  twice as relevant as a search result matching a bio.
  """
  searchUsers(
    query: String!
    limit: Int
    usernameWeight: Float
    bioWeight: Float
  ): SearchUsersPayloadOrError
  """
  Search for splits with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. nameWeight defaults to 0.4 and
  descriptionWeight defaults to 0.2, meaning that a search result matching a split name is
  considered twice as relevant as a search result matching a split description.
  """
  searchSplits(
    query: String!
    limit: Int
    nameWeight: Float
    descriptionWeight: Float
  ): SearchSplitsPayloadOrError

  # Retool Specific
  usersByRole(role: Role!, before: String, after: String, first: Int, last: Int): UsersConnection
    @basicAuth(allowed: [Retool])
}

union AddUserWalletPayloadOrError =
    AddUserWalletPayload
  | ErrAuthenticationFailed
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrAddressOwnedByUser

type AddUserWalletPayload {
  viewer: Viewer
}

union RemoveUserWalletsPayloadOrError =
    RemoveUserWalletsPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type RemoveUserWalletsPayload {
  viewer: Viewer
}

input UpdateUserInfoInput {
  username: String!
  bio: String!
}

union UpdateUserInfoPayloadOrError =
    UpdateUserInfoPayload
  | ErrNotAuthorized
  | ErrUsernameNotAvailable
  | ErrInvalidInput

type UpdateUserInfoPayload {
  viewer: Viewer
}

union RegisterUserPushTokenPayloadOrError =
  RegisterUserPushTokenPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrPushTokenBelongsToAnotherUser

type RegisterUserPushTokenPayload {
  viewer: Viewer
}

union UnregisterUserPushTokenPayloadOrError =
  UnregisterUserPushTokenPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrPushTokenBelongsToAnotherUser

type UnregisterUserPushTokenPayload {
  viewer: Viewer
}

type AuthNonce {
  nonce: String
  message: String
}

union GetAuthNoncePayloadOrError = AuthNonce

type ErrAuthenticationFailed implements Error {
  message: String!
}

type ErrUserAlreadyExists implements Error {
  message: String!
}

type ErrUsernameNotAvailable implements Error {
  message: String!
}

type ErrAddressOwnedByUser implements Error {
  message: String!
}

type ErrUserNotFound implements Error {
  message: String!
}

type ErrCommunityNotFound implements Error {
  message: String!
}

union AuthorizationError =
  ErrNoCookie
  | ErrInvalidToken
  | ErrSessionInvalidated
  | ErrDoesNotOwnRequiredToken

type ErrNotAuthorized implements Error {
  message: String!
  cause: AuthorizationError!
}

type ErrInvalidInput implements Error {
  message: String!
  parameters: [String!]!
  reasons: [String!]!
}

type ErrNoCookie implements Error {
  message: String!
}

type ErrInvalidToken implements Error {
  message: String!
}

type ErrSessionInvalidated implements Error {
  message: String!
}

type ErrDoesNotOwnRequiredToken implements Error {
  message: String!
}

type ErrSyncFailed implements Error {
  message: String!
}

type ErrPushTokenBelongsToAnotherUser implements Error {
  message: String!
}

input AuthMechanism {
  eoa: EoaAuth
  gnosisSafe: GnosisSafeAuth
  debug: DebugAuth
  magicLink: MagicLinkAuth
  oneTimeLoginToken: OneTimeLoginTokenAuth
  privy: PrivyAuth
}

input EoaAuth {
  chainPubKey: ChainPubKeyInput!
  nonce: String!
  message: String!
  signature: String! @scrub
}

# DebugAuth is a debug-only authentication mechanism for testing and debugging.
# It creates an authenticator that will return the supplied userId and chainAddresses as if they had been
# successfully authenticated. For existing users, the asUsername parameter may be supplied as a convenience
# method to look up and return their userId and chainAddresses.
input DebugAuth @restrictEnvironment(allowed: ["local", "development", "sandbox"]) {
  # Convenience method to authenticate as an existing user.
  # Cannot be used in conjunction with the userId and chainAddresses parameters.
  asUsername: String

  # The userId that will be returned from the resulting authenticator.
  # May be omitted or blank to indicate that there is no user associated with the supplied chainAddresses.
  # Cannot be used in conjunction with the asUsername parameter.
  userId: DBID

  # The chainAddresses that will be returned from the resulting authenticator.
  # Cannot be used in conjunction with the asUsername parameter.
  chainAddresses: [ChainAddressInput!]

  # A password required to use debug tools. Typically empty in local environments.
  debugToolsPassword: String
}

input GnosisSafeAuth {
  address: Address!
  nonce: String!
  message: String!
}

input MagicLinkAuth {
  token: String!
}

input PrivyAuth {
  token: String!
}

input OneTimeLoginTokenAuth {
  token: String!
}

union LoginPayloadOrError =
    LoginPayload
  | ErrUserNotFound
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredToken

type LoginPayload {
  # TODO: Remove userId in favor of viewer
  userId: DBID
  viewer: Viewer
}

type LogoutPayload {
  viewer: Viewer
}
input CreateUserInput {
  username: String!
  bio: String
  email: Email
  splitName: String
  splitDescription: String
  splitPosition: String
}

union CreateUserPayloadOrError =
    CreateUserPayload
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredToken
  | ErrUserAlreadyExists
  | ErrUsernameNotAvailable
  | ErrInvalidInput

type CreateUserPayload {
  userId: DBID
  splitId: DBID
  # TODO: Remove userId and splitId in favor of viewer
  viewer: Viewer
}

interface Notification implements Node {
  id: ID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
}

interface GroupedNotification implements Notification & Node {
  id: ID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  count: Int
}

type GroupNotificationUserEdge {
  node: SplitFiUser
  cursor: String
}

type GroupNotificationUsersConnection @goEmbedHelper {
  edges: [GroupNotificationUserEdge]
  pageInfo: PageInfo
}

type ClearAllNotificationsPayload {
  notifications: [Notification]
}

type ViewSplitPayload {
  split: Split
}

union ViewSplitPayloadOrError = ViewSplitPayload | ErrAuthenticationFailed

input VerifyEmailInput {
  token: String! @scrub
}

type VerifyEmailPayload {
  email: Email!
}

union VerifyEmailPayloadOrError = VerifyEmailPayload | ErrInvalidInput

input PreverifyEmailInput {
  email: Email! @scrub
}

enum PreverifyEmailResult {
  Invalid
  Risky
  Valid
}

type PreverifyEmailPayload {
  email: Email!
  result: PreverifyEmailResult!
}

union PreverifyEmailPayloadOrError = PreverifyEmailPayload | ErrInvalidInput

input VerifyEmailMagicLinkInput {
  email: Email! @scrub
}

type VerifyEmailMagicLinkPayload {
  canSend: Boolean!
}

union VerifyEmailMagicLinkPayloadOrError = VerifyEmailMagicLinkPayload | ErrInvalidInput

input UpdateEmailInput {
  email: Email! @scrub
  """
  authMechanism is an optional parameter that can verify a user's email address in lieu of sending
  a verification email to the user. If not provided, a verification email will be sent.
  """
  authMechanism: AuthMechanism
}

type UpdateEmailPayload {
  viewer: Viewer
}

union UpdateEmailPayloadOrError = UpdateEmailPayload | ErrInvalidInput

type ResendVerificationEmailPayload {
  viewer: Viewer
}

union ResendVerificationEmailPayloadOrError = ResendVerificationEmailPayload | ErrInvalidInput

type UpdateEmailNotificationSettingsPayload {
  viewer: Viewer
}

union UpdateEmailNotificationSettingsPayloadOrError =
  UpdateEmailNotificationSettingsPayload
  | ErrInvalidInput

type UnsubscribeFromEmailTypePayload {
  viewer: Viewer
}

union UnsubscribeFromEmailTypePayloadOrError = UnsubscribeFromEmailTypePayload | ErrInvalidInput

union AddRolesToUserPayloadOrError = SplitFiUser | ErrNotAuthorized
union RevokeRolesFromUserPayloadOrError = SplitFiUser | ErrNotAuthorized

type OptInForRolesPayload {
  user: SplitFiUser
}

type OptOutForRolesPayload {
  user: SplitFiUser
}

union OptInForRolesPayloadOrError = OptInForRolesPayload | ErrNotAuthorized | ErrInvalidInput
union OptOutForRolesPayloadOrError = OptOutForRolesPayload | ErrNotAuthorized | ErrInvalidInput

input UploadPersistedQueriesInput {
  persistedQueries: String
}

union UploadPersistedQueriesPayloadOrError = UploadPersistedQueriesPayload | ErrNotAuthorized

type UploadPersistedQueriesPayload {
  message: String
}

input SplitShareInput {
  splitId: DBID!
  recipientAddress: Address!
  ownership: Int!
}

input SplitPositionInput {
  splitId: DBID!
  position: String!
}

input UpdateSplitOrderInput {
  positions: [SplitPositionInput!]!
}

input UpdateSplitHiddenInput {
  id: DBID!
  hidden: Boolean!
}

input UpdateSplitInfoInput {
  id: DBID!
  name: String
  description: String
}

input CreateSplitInput {
  name: String
  description: String
  logo: String
}

type CreateSplitPayload {
  split: Split
}

union CreateSplitPayloadOrError = CreateSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdateSplitInfoPayload {
  split: Split
}

union UpdateSplitInfoPayloadOrError =
    UpdateSplitInfoPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type UpdateSplitHiddenPayload {
  split: Split
}

union UpdateSplitHiddenPayloadOrError =
    UpdateSplitHiddenPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type DeleteSplitPayload {
  deletedId: DeletedNode
}

union DeleteSplitPayloadOrError = DeleteSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdateSplitOrderPayload {
  viewer: Viewer
}

union UpdateSplitOrderPayloadOrError =
    UpdateSplitOrderPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input UpdateSplitInput {
  splitId: DBID!

  name: String
  description: String

  # leaving caption around for a bit for backwards compatibility
  caption: String

  deletedCollections: [DBID!]

  order: [DBID!]

  # generated on the frontend
  # will be String! in the future, not required for temp backwards compatibility
  editId: String
}

type UpdateSplitPayload {
  split: Split
}

union UpdateSplitPayloadOrError = UpdateSplitPayload | ErrInvalidInput | ErrNotAuthorized

input PublishSplitInput {
  splitId: DBID!
  editId: String!
  caption: String
}

type PublishSplitPayload {
  split: Split
}

union PublishSplitPayloadOrError = PublishSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdatePrimaryWalletPayload {
  viewer: Viewer
}

union UpdatePrimaryWalletPayloadOrError =
    UpdatePrimaryWalletPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input AdminAddWalletInput {
  username: String!
  chainAddress: ChainAddressInput!
  walletType: WalletType!
}

type AdminAddWalletPayload {
  user: SplitFiUser
}

union AdminAddWalletPayloadOrError =
    AdminAddWalletPayload
  | ErrUserNotFound
  | ErrAddressOwnedByUser
  | ErrNotAuthorized

input UpdateUserExperienceInput {
  experienceType: UserExperienceType!
  experienced: Boolean!
}

type UpdateUserExperiencePayload {
  viewer: Viewer
}

union UpdateUserExperiencePayloadOrError =
    UpdateUserExperiencePayload
  | ErrInvalidInput
  | ErrNotAuthorized

type Mutation {
  # User Mutations
  addUserWallet(
    chainAddress: ChainAddressInput!
    authMechanism: AuthMechanism!
  ): AddUserWalletPayloadOrError @authRequired
  removeUserWallets(walletIds: [DBID!]!): RemoveUserWalletsPayloadOrError @authRequired
  updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayloadOrError @authRequired
  registerUserPushToken(pushToken: String!): RegisterUserPushTokenPayloadOrError @authRequired
  unregisterUserPushToken(pushToken: String!): UnregisterUserPushTokenPayloadOrError @authRequired

  getAuthNonce: GetAuthNoncePayloadOrError

  createUser(authMechanism: AuthMechanism!, input: CreateUserInput!): CreateUserPayloadOrError
  updateEmail(input: UpdateEmailInput!): UpdateEmailPayloadOrError @authRequired
  resendVerificationEmail: ResendVerificationEmailPayloadOrError @authRequired
  updateEmailNotificationSettings(
    input: UpdateEmailNotificationSettingsInput!
  ): UpdateEmailNotificationSettingsPayloadOrError @authRequired
  unsubscribeFromEmailType(
    input: UnsubscribeFromEmailTypeInput!
  ): UnsubscribeFromEmailTypePayloadOrError
  login(authMechanism: AuthMechanism!): LoginPayloadOrError
  logout(pushTokenToUnregister: String): LogoutPayload

  viewSplit(splitId: DBID!): ViewSplitPayloadOrError

  updateSplit(input: UpdateSplitInput!): UpdateSplitPayloadOrError @authRequired
  publishSplit(input: PublishSplitInput!): PublishSplitPayloadOrError @authRequired

  createSplit(input: CreateSplitInput!): CreateSplitPayloadOrError @authRequired
  updateSplitHidden(input: UpdateSplitHiddenInput!): UpdateSplitHiddenPayloadOrError
    @authRequired
  deleteSplit(splitId: DBID!): DeleteSplitPayloadOrError @authRequired
  updateSplitOrder(input: UpdateSplitOrderInput!): UpdateSplitOrderPayloadOrError
    @authRequired
  updateSplitInfo(input: UpdateSplitInfoInput!): UpdateSplitInfoPayloadOrError @authRequired

  clearAllNotifications: ClearAllNotificationsPayload @authRequired

  updateNotificationSettings(settings: NotificationSettingsInput): NotificationSettings

  preverifyEmail(input: PreverifyEmailInput!): PreverifyEmailPayloadOrError
  verifyEmail(input: VerifyEmailInput!): VerifyEmailPayloadOrError
  verifyEmailMagicLink(input: VerifyEmailMagicLinkInput!): VerifyEmailMagicLinkPayloadOrError

  optInForRoles(roles: [Role!]!): OptInForRolesPayloadOrError @authRequired
  optOutForRoles(roles: [Role!]!): OptOutForRolesPayloadOrError @authRequired

  # Retool Specific Mutations
  addRolesToUser(username: String!, roles: [Role]): AddRolesToUserPayloadOrError @basicAuth(allowed: [Retool])
  addWalletToUserUnchecked(input: AdminAddWalletInput!): AdminAddWalletPayloadOrError @basicAuth(allowed: [Retool])
  revokeRolesFromUser(username: String!, roles: [Role]): RevokeRolesFromUserPayloadOrError
    @basicAuth(allowed: [Retool])

  # SplitFi Frontend Deploy Persisted Queries
  uploadPersistedQueries(input: UploadPersistedQueriesInput): UploadPersistedQueriesPayloadOrError
    @frontendBuildAuth

  updatePrimaryWallet(walletID: DBID!): UpdatePrimaryWalletPayloadOrError @authRequired

  updateUserExperience(input: UpdateUserExperienceInput!): UpdateUserExperiencePayloadOrError
    @authRequired
}

type Subscription {
  newNotification: Notification
  notificationUpdated: Notification
}
