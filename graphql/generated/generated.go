// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	"github.com/SplitFi/go-splitfi/graphql/model"
	"github.com/SplitFi/go-splitfi/service/auth/basicauth"
	"github.com/SplitFi/go-splitfi/service/persist"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Asset() AssetResolver
	Mutation() MutationResolver
	PreviewURLSet() PreviewURLSetResolver
	Query() QueryResolver
	Recipient() RecipientResolver
	Split() SplitResolver
	SplitFiUser() SplitFiUserResolver
	Subscription() SubscriptionResolver
	UserEmail() UserEmailResolver
	Viewer() ViewerResolver
	Wallet() WalletResolver
	ChainAddressInput() ChainAddressInputResolver
	ChainPubKeyInput() ChainPubKeyInputResolver
}

type DirectiveRoot struct {
	AuthRequired        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	BasicAuth           func(ctx context.Context, obj interface{}, next graphql.Resolver, allowed []basicauth.AuthTokenType) (res interface{}, err error)
	Experimental        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	FrontendBuildAuth   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	RestrictEnvironment func(ctx context.Context, obj interface{}, next graphql.Resolver, allowed []string) (res interface{}, err error)
}

type ComplexityRoot struct {
	AddUserWalletPayload struct {
		Viewer func(childComplexity int) int
	}

	AdminAddWalletPayload struct {
		User func(childComplexity int) int
	}

	Asset struct {
		Balance      func(childComplexity int) int
		Dbid         func(childComplexity int) int
		ID           func(childComplexity int) int
		OwnerAddress func(childComplexity int) int
		Token        func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	AudioMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	AuthNonce struct {
		Message func(childComplexity int) int
		Nonce   func(childComplexity int) int
	}

	ChainAddress struct {
		Address func(childComplexity int) int
		Chain   func(childComplexity int) int
	}

	ChainPubKey struct {
		Chain  func(childComplexity int) int
		PubKey func(childComplexity int) int
	}

	ChainSplits struct {
		Chain  func(childComplexity int) int
		Splits func(childComplexity int) int
	}

	ChainTokens struct {
		Chain  func(childComplexity int) int
		Tokens func(childComplexity int) int
	}

	ClearAllNotificationsPayload struct {
		Notifications func(childComplexity int) int
	}

	CreateSplitPayload struct {
		Split func(childComplexity int) int
	}

	CreateUserPayload struct {
		SplitID func(childComplexity int) int
		UserID  func(childComplexity int) int
		Viewer  func(childComplexity int) int
	}

	DeleteSplitPayload struct {
		DeletedID func(childComplexity int) int
	}

	DeletedNode struct {
		Dbid func(childComplexity int) int
		ID   func(childComplexity int) int
	}

	EmailNotificationSettings struct {
		UnsubscribedFromAll           func(childComplexity int) int
		UnsubscribedFromNotifications func(childComplexity int) int
	}

	ErrAddressOwnedByUser struct {
		Message func(childComplexity int) int
	}

	ErrAuthenticationFailed struct {
		Message func(childComplexity int) int
	}

	ErrCommunityNotFound struct {
		Message func(childComplexity int) int
	}

	ErrDoesNotOwnRequiredToken struct {
		Message func(childComplexity int) int
	}

	ErrInvalidInput struct {
		Message    func(childComplexity int) int
		Parameters func(childComplexity int) int
		Reasons    func(childComplexity int) int
	}

	ErrInvalidToken struct {
		Message func(childComplexity int) int
	}

	ErrNoCookie struct {
		Message func(childComplexity int) int
	}

	ErrNotAuthorized struct {
		Cause   func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ErrPushTokenBelongsToAnotherUser struct {
		Message func(childComplexity int) int
	}

	ErrSessionInvalidated struct {
		Message func(childComplexity int) int
	}

	ErrSplitNotFound struct {
		Message func(childComplexity int) int
	}

	ErrSyncFailed struct {
		Message func(childComplexity int) int
	}

	ErrTokenNotFound struct {
		Message func(childComplexity int) int
	}

	ErrUserAlreadyExists struct {
		Message func(childComplexity int) int
	}

	ErrUserNotFound struct {
		Message func(childComplexity int) int
	}

	ErrUsernameNotAvailable struct {
		Message func(childComplexity int) int
	}

	GIFMedia struct {
		ContentRenderURL  func(childComplexity int) int
		Dimensions        func(childComplexity int) int
		MediaType         func(childComplexity int) int
		MediaURL          func(childComplexity int) int
		PreviewURLs       func(childComplexity int) int
		StaticPreviewURLs func(childComplexity int) int
	}

	GltfMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	GroupNotificationUserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GroupNotificationUsersConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	HtmlMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	ImageMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	InvalidMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	JsonMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	LoginPayload struct {
		UserID func(childComplexity int) int
		Viewer func(childComplexity int) int
	}

	LogoutPayload struct {
		Viewer func(childComplexity int) int
	}

	MediaDimensions struct {
		AspectRatio func(childComplexity int) int
		Height      func(childComplexity int) int
		Width       func(childComplexity int) int
	}

	Mutation struct {
		AddRolesToUser                  func(childComplexity int, username string, roles []*persist.Role) int
		AddUserWallet                   func(childComplexity int, chainAddress persist.ChainAddress, authMechanism model.AuthMechanism) int
		AddWalletToUserUnchecked        func(childComplexity int, input model.AdminAddWalletInput) int
		ClearAllNotifications           func(childComplexity int) int
		CreateSplit                     func(childComplexity int, input model.CreateSplitInput) int
		CreateUser                      func(childComplexity int, authMechanism model.AuthMechanism, input model.CreateUserInput) int
		DeleteSplit                     func(childComplexity int, splitID persist.DBID) int
		GetAuthNonce                    func(childComplexity int) int
		Login                           func(childComplexity int, authMechanism model.AuthMechanism) int
		Logout                          func(childComplexity int, pushTokenToUnregister *string) int
		OptInForRoles                   func(childComplexity int, roles []persist.Role) int
		OptOutForRoles                  func(childComplexity int, roles []persist.Role) int
		PreverifyEmail                  func(childComplexity int, input model.PreverifyEmailInput) int
		PublishSplit                    func(childComplexity int, input model.PublishSplitInput) int
		RegisterUserPushToken           func(childComplexity int, pushToken string) int
		RemoveUserWallets               func(childComplexity int, walletIds []persist.DBID) int
		ResendVerificationEmail         func(childComplexity int) int
		RevokeRolesFromUser             func(childComplexity int, username string, roles []*persist.Role) int
		UnregisterUserPushToken         func(childComplexity int, pushToken string) int
		UnsubscribeFromEmailType        func(childComplexity int, input model.UnsubscribeFromEmailTypeInput) int
		UpdateEmail                     func(childComplexity int, input model.UpdateEmailInput) int
		UpdateEmailNotificationSettings func(childComplexity int, input model.UpdateEmailNotificationSettingsInput) int
		UpdateNotificationSettings      func(childComplexity int, settings *model.NotificationSettingsInput) int
		UpdatePrimaryWallet             func(childComplexity int, walletID persist.DBID) int
		UpdateSplit                     func(childComplexity int, input model.UpdateSplitInput) int
		UpdateSplitHidden               func(childComplexity int, input model.UpdateSplitHiddenInput) int
		UpdateSplitInfo                 func(childComplexity int, input model.UpdateSplitInfoInput) int
		UpdateSplitOrder                func(childComplexity int, input model.UpdateSplitOrderInput) int
		UpdateUserExperience            func(childComplexity int, input model.UpdateUserExperienceInput) int
		UpdateUserInfo                  func(childComplexity int, input model.UpdateUserInfoInput) int
		UploadPersistedQueries          func(childComplexity int, input *model.UploadPersistedQueriesInput) int
		VerifyEmail                     func(childComplexity int, input model.VerifyEmailInput) int
		VerifyEmailMagicLink            func(childComplexity int, input model.VerifyEmailMagicLinkInput) int
		ViewSplit                       func(childComplexity int, splitID persist.DBID) int
	}

	NotificationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	NotificationSettings struct {
		SomeoneFollowedYou     func(childComplexity int) int
		SomeoneViewedYourSplit func(childComplexity int) int
	}

	NotificationsConnection struct {
		Edges       func(childComplexity int) int
		PageInfo    func(childComplexity int) int
		UnseenCount func(childComplexity int) int
	}

	OptInForRolesPayload struct {
		User func(childComplexity int) int
	}

	OptOutForRolesPayload struct {
		User func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		Size            func(childComplexity int) int
		StartCursor     func(childComplexity int) int
		Total           func(childComplexity int) int
	}

	PdfMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	PreverifyEmailPayload struct {
		Email  func(childComplexity int) int
		Result func(childComplexity int) int
	}

	PreviewURLSet struct {
		Blurhash   func(childComplexity int) int
		Large      func(childComplexity int) int
		LiveRender func(childComplexity int) int
		Medium     func(childComplexity int) int
		Raw        func(childComplexity int) int
		Small      func(childComplexity int) int
		SrcSet     func(childComplexity int) int
		Thumbnail  func(childComplexity int) int
	}

	PublishSplitPayload struct {
		Split func(childComplexity int) int
	}

	Query struct {
		Node               func(childComplexity int, id model.GqlID) int
		SearchSplits       func(childComplexity int, query string, limit *int, nameWeight *float64, descriptionWeight *float64) int
		SearchUsers        func(childComplexity int, query string, limit *int, usernameWeight *float64, bioWeight *float64) int
		SplitByID          func(childComplexity int, id persist.DBID) int
		UserByAddress      func(childComplexity int, chainAddress persist.ChainAddress) int
		UserByID           func(childComplexity int, id persist.DBID) int
		UserByUsername     func(childComplexity int, username string) int
		UsersByRole        func(childComplexity int, role persist.Role, before *string, after *string, first *int, last *int) int
		UsersWithTrait     func(childComplexity int, trait string) int
		Viewer             func(childComplexity int) int
		ViewerSplitByID    func(childComplexity int, id persist.DBID) int
		__resolve__service func(childComplexity int) int
	}

	Recipient struct {
		Address      func(childComplexity int) int
		CreationTime func(childComplexity int) int
		Dbid         func(childComplexity int) int
		ID           func(childComplexity int) int
		LastUpdated  func(childComplexity int) int
		Ownership    func(childComplexity int) int
		Split        func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	RegisterUserPushTokenPayload struct {
		Viewer func(childComplexity int) int
	}

	RemoveUserWalletsPayload struct {
		Viewer func(childComplexity int) int
	}

	ResendVerificationEmailPayload struct {
		Viewer func(childComplexity int) int
	}

	SearchSplitsPayload struct {
		Results func(childComplexity int) int
	}

	SearchUsersPayload struct {
		Results func(childComplexity int) int
	}

	Split struct {
		Assets      func(childComplexity int, limit *int) int
		BadgeURL    func(childComplexity int) int
		BannerURL   func(childComplexity int) int
		Chain       func(childComplexity int) int
		Dbid        func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		LogoURL     func(childComplexity int) int
		Name        func(childComplexity int) int
		Shares      func(childComplexity int, limit *int) int
		Version     func(childComplexity int) int
	}

	SplitFiUser struct {
		Bio                 func(childComplexity int) int
		Dbid                func(childComplexity int) int
		ID                  func(childComplexity int) int
		IsAuthenticatedUser func(childComplexity int) int
		PrimaryWallet       func(childComplexity int) int
		Roles               func(childComplexity int) int
		Splits              func(childComplexity int) int
		SplitsByChain       func(childComplexity int, chain persist.Chain) int
		Traits              func(childComplexity int) int
		Universal           func(childComplexity int) int
		Username            func(childComplexity int) int
		Wallets             func(childComplexity int) int
	}

	SplitSearchResult struct {
		Split func(childComplexity int) int
	}

	Subscription struct {
		NewNotification     func(childComplexity int) int
		NotificationUpdated func(childComplexity int) int
	}

	TextMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	Token struct {
		BlockNumber     func(childComplexity int) int
		Chain           func(childComplexity int) int
		ContractAddress func(childComplexity int) int
		CreationTime    func(childComplexity int) int
		Dbid            func(childComplexity int) int
		Decimals        func(childComplexity int) int
		ID              func(childComplexity int) int
		IsSpam          func(childComplexity int) int
		LastUpdated     func(childComplexity int) int
		Logo            func(childComplexity int) int
		Name            func(childComplexity int) int
		Symbol          func(childComplexity int) int
		TokenType       func(childComplexity int) int
		TotalSupply     func(childComplexity int) int
		Version         func(childComplexity int) int
	}

	UnknownMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	UnregisterUserPushTokenPayload struct {
		Viewer func(childComplexity int) int
	}

	UnsubscribeFromEmailTypePayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateEmailNotificationSettingsPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateEmailPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdatePrimaryWalletPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateSplitHiddenPayload struct {
		Split func(childComplexity int) int
	}

	UpdateSplitInfoPayload struct {
		Split func(childComplexity int) int
	}

	UpdateSplitOrderPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateSplitPayload struct {
		Split func(childComplexity int) int
	}

	UpdateUserExperiencePayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateUserInfoPayload struct {
		Viewer func(childComplexity int) int
	}

	UploadPersistedQueriesPayload struct {
		Message func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserEmail struct {
		Email                     func(childComplexity int) int
		EmailNotificationSettings func(childComplexity int) int
		VerificationStatus        func(childComplexity int) int
	}

	UserExperience struct {
		Experienced func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	UserSearchResult struct {
		User func(childComplexity int) int
	}

	UsersConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	VerifyEmailMagicLinkPayload struct {
		CanSend func(childComplexity int) int
	}

	VerifyEmailPayload struct {
		Email func(childComplexity int) int
	}

	VideoMedia struct {
		ContentRenderURLs func(childComplexity int) int
		Dimensions        func(childComplexity int) int
		MediaType         func(childComplexity int) int
		MediaURL          func(childComplexity int) int
		PreviewURLs       func(childComplexity int) int
	}

	VideoURLSet struct {
		Large  func(childComplexity int) int
		Medium func(childComplexity int) int
		Raw    func(childComplexity int) int
		Small  func(childComplexity int) int
	}

	ViewSplitPayload struct {
		Split func(childComplexity int) int
	}

	Viewer struct {
		Email                func(childComplexity int) int
		ID                   func(childComplexity int) int
		NotificationSettings func(childComplexity int) int
		Notifications        func(childComplexity int, before *string, after *string, first *int, last *int) int
		User                 func(childComplexity int) int
		UserExperiences      func(childComplexity int) int
		ViewerSplits         func(childComplexity int) int
	}

	ViewerSplit struct {
		Split func(childComplexity int) int
	}

	Wallet struct {
		Chain        func(childComplexity int) int
		ChainAddress func(childComplexity int) int
		Dbid         func(childComplexity int) int
		ID           func(childComplexity int) int
		Splits       func(childComplexity int) int
		WalletType   func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type AssetResolver interface {
	Token(ctx context.Context, obj *model.Asset) (*model.Token, error)
}
type MutationResolver interface {
	AddUserWallet(ctx context.Context, chainAddress persist.ChainAddress, authMechanism model.AuthMechanism) (model.AddUserWalletPayloadOrError, error)
	RemoveUserWallets(ctx context.Context, walletIds []persist.DBID) (model.RemoveUserWalletsPayloadOrError, error)
	UpdateUserInfo(ctx context.Context, input model.UpdateUserInfoInput) (model.UpdateUserInfoPayloadOrError, error)
	RegisterUserPushToken(ctx context.Context, pushToken string) (model.RegisterUserPushTokenPayloadOrError, error)
	UnregisterUserPushToken(ctx context.Context, pushToken string) (model.UnregisterUserPushTokenPayloadOrError, error)
	GetAuthNonce(ctx context.Context) (model.GetAuthNoncePayloadOrError, error)
	CreateUser(ctx context.Context, authMechanism model.AuthMechanism, input model.CreateUserInput) (model.CreateUserPayloadOrError, error)
	UpdateEmail(ctx context.Context, input model.UpdateEmailInput) (model.UpdateEmailPayloadOrError, error)
	ResendVerificationEmail(ctx context.Context) (model.ResendVerificationEmailPayloadOrError, error)
	UpdateEmailNotificationSettings(ctx context.Context, input model.UpdateEmailNotificationSettingsInput) (model.UpdateEmailNotificationSettingsPayloadOrError, error)
	UnsubscribeFromEmailType(ctx context.Context, input model.UnsubscribeFromEmailTypeInput) (model.UnsubscribeFromEmailTypePayloadOrError, error)
	Login(ctx context.Context, authMechanism model.AuthMechanism) (model.LoginPayloadOrError, error)
	Logout(ctx context.Context, pushTokenToUnregister *string) (*model.LogoutPayload, error)
	ViewSplit(ctx context.Context, splitID persist.DBID) (model.ViewSplitPayloadOrError, error)
	UpdateSplit(ctx context.Context, input model.UpdateSplitInput) (model.UpdateSplitPayloadOrError, error)
	PublishSplit(ctx context.Context, input model.PublishSplitInput) (model.PublishSplitPayloadOrError, error)
	CreateSplit(ctx context.Context, input model.CreateSplitInput) (model.CreateSplitPayloadOrError, error)
	UpdateSplitHidden(ctx context.Context, input model.UpdateSplitHiddenInput) (model.UpdateSplitHiddenPayloadOrError, error)
	DeleteSplit(ctx context.Context, splitID persist.DBID) (model.DeleteSplitPayloadOrError, error)
	UpdateSplitOrder(ctx context.Context, input model.UpdateSplitOrderInput) (model.UpdateSplitOrderPayloadOrError, error)
	UpdateSplitInfo(ctx context.Context, input model.UpdateSplitInfoInput) (model.UpdateSplitInfoPayloadOrError, error)
	ClearAllNotifications(ctx context.Context) (*model.ClearAllNotificationsPayload, error)
	UpdateNotificationSettings(ctx context.Context, settings *model.NotificationSettingsInput) (*model.NotificationSettings, error)
	PreverifyEmail(ctx context.Context, input model.PreverifyEmailInput) (model.PreverifyEmailPayloadOrError, error)
	VerifyEmail(ctx context.Context, input model.VerifyEmailInput) (model.VerifyEmailPayloadOrError, error)
	VerifyEmailMagicLink(ctx context.Context, input model.VerifyEmailMagicLinkInput) (model.VerifyEmailMagicLinkPayloadOrError, error)
	OptInForRoles(ctx context.Context, roles []persist.Role) (model.OptInForRolesPayloadOrError, error)
	OptOutForRoles(ctx context.Context, roles []persist.Role) (model.OptOutForRolesPayloadOrError, error)
	AddRolesToUser(ctx context.Context, username string, roles []*persist.Role) (model.AddRolesToUserPayloadOrError, error)
	AddWalletToUserUnchecked(ctx context.Context, input model.AdminAddWalletInput) (model.AdminAddWalletPayloadOrError, error)
	RevokeRolesFromUser(ctx context.Context, username string, roles []*persist.Role) (model.RevokeRolesFromUserPayloadOrError, error)
	UploadPersistedQueries(ctx context.Context, input *model.UploadPersistedQueriesInput) (model.UploadPersistedQueriesPayloadOrError, error)
	UpdatePrimaryWallet(ctx context.Context, walletID persist.DBID) (model.UpdatePrimaryWalletPayloadOrError, error)
	UpdateUserExperience(ctx context.Context, input model.UpdateUserExperienceInput) (model.UpdateUserExperiencePayloadOrError, error)
}
type PreviewURLSetResolver interface {
	Blurhash(ctx context.Context, obj *model.PreviewURLSet) (*string, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id model.GqlID) (model.Node, error)
	Viewer(ctx context.Context) (model.ViewerOrError, error)
	UserByUsername(ctx context.Context, username string) (model.UserByUsernameOrError, error)
	UserByID(ctx context.Context, id persist.DBID) (model.UserByIDOrError, error)
	UserByAddress(ctx context.Context, chainAddress persist.ChainAddress) (model.UserByAddressOrError, error)
	UsersWithTrait(ctx context.Context, trait string) ([]*model.SplitFiUser, error)
	SplitByID(ctx context.Context, id persist.DBID) (model.SplitByIDPayloadOrError, error)
	ViewerSplitByID(ctx context.Context, id persist.DBID) (model.ViewerSplitByIDPayloadOrError, error)
	SearchUsers(ctx context.Context, query string, limit *int, usernameWeight *float64, bioWeight *float64) (model.SearchUsersPayloadOrError, error)
	SearchSplits(ctx context.Context, query string, limit *int, nameWeight *float64, descriptionWeight *float64) (model.SearchSplitsPayloadOrError, error)
	UsersByRole(ctx context.Context, role persist.Role, before *string, after *string, first *int, last *int) (*model.UsersConnection, error)
}
type RecipientResolver interface {
	Split(ctx context.Context, obj *model.Recipient) (*model.Split, error)
}
type SplitResolver interface {
	Assets(ctx context.Context, obj *model.Split, limit *int) ([]*model.Asset, error)
	Shares(ctx context.Context, obj *model.Split, limit *int) ([]*model.Recipient, error)
}
type SplitFiUserResolver interface {
	Roles(ctx context.Context, obj *model.SplitFiUser) ([]*persist.Role, error)
	Wallets(ctx context.Context, obj *model.SplitFiUser) ([]*model.Wallet, error)
	PrimaryWallet(ctx context.Context, obj *model.SplitFiUser) (*model.Wallet, error)
	Splits(ctx context.Context, obj *model.SplitFiUser) ([]*model.Split, error)
	SplitsByChain(ctx context.Context, obj *model.SplitFiUser, chain persist.Chain) (*model.ChainSplits, error)
}
type SubscriptionResolver interface {
	NewNotification(ctx context.Context) (<-chan model.Notification, error)
	NotificationUpdated(ctx context.Context) (<-chan model.Notification, error)
}
type UserEmailResolver interface {
	EmailNotificationSettings(ctx context.Context, obj *model.UserEmail) (*model.EmailNotificationSettings, error)
}
type ViewerResolver interface {
	User(ctx context.Context, obj *model.Viewer) (*model.SplitFiUser, error)
	ViewerSplits(ctx context.Context, obj *model.Viewer) ([]*model.ViewerSplit, error)
	Email(ctx context.Context, obj *model.Viewer) (*model.UserEmail, error)
	Notifications(ctx context.Context, obj *model.Viewer, before *string, after *string, first *int, last *int) (*model.NotificationsConnection, error)
	NotificationSettings(ctx context.Context, obj *model.Viewer) (*model.NotificationSettings, error)
	UserExperiences(ctx context.Context, obj *model.Viewer) ([]*model.UserExperience, error)
}
type WalletResolver interface {
	Splits(ctx context.Context, obj *model.Wallet) ([]*model.Split, error)
}

type ChainAddressInputResolver interface {
	Address(ctx context.Context, obj *persist.ChainAddress, data persist.Address) error
	Chain(ctx context.Context, obj *persist.ChainAddress, data persist.Chain) error
}
type ChainPubKeyInputResolver interface {
	PubKey(ctx context.Context, obj *persist.ChainPubKey, data persist.PubKey) error
	Chain(ctx context.Context, obj *persist.ChainPubKey, data persist.Chain) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AddUserWalletPayload.viewer":
		if e.complexity.AddUserWalletPayload.Viewer == nil {
			break
		}

		return e.complexity.AddUserWalletPayload.Viewer(childComplexity), true

	case "AdminAddWalletPayload.user":
		if e.complexity.AdminAddWalletPayload.User == nil {
			break
		}

		return e.complexity.AdminAddWalletPayload.User(childComplexity), true

	case "Asset.balance":
		if e.complexity.Asset.Balance == nil {
			break
		}

		return e.complexity.Asset.Balance(childComplexity), true

	case "Asset.dbid":
		if e.complexity.Asset.Dbid == nil {
			break
		}

		return e.complexity.Asset.Dbid(childComplexity), true

	case "Asset.id":
		if e.complexity.Asset.ID == nil {
			break
		}

		return e.complexity.Asset.ID(childComplexity), true

	case "Asset.ownerAddress":
		if e.complexity.Asset.OwnerAddress == nil {
			break
		}

		return e.complexity.Asset.OwnerAddress(childComplexity), true

	case "Asset.token":
		if e.complexity.Asset.Token == nil {
			break
		}

		return e.complexity.Asset.Token(childComplexity), true

	case "Asset.version":
		if e.complexity.Asset.Version == nil {
			break
		}

		return e.complexity.Asset.Version(childComplexity), true

	case "AudioMedia.contentRenderURL":
		if e.complexity.AudioMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.AudioMedia.ContentRenderURL(childComplexity), true

	case "AudioMedia.dimensions":
		if e.complexity.AudioMedia.Dimensions == nil {
			break
		}

		return e.complexity.AudioMedia.Dimensions(childComplexity), true

	case "AudioMedia.mediaType":
		if e.complexity.AudioMedia.MediaType == nil {
			break
		}

		return e.complexity.AudioMedia.MediaType(childComplexity), true

	case "AudioMedia.mediaURL":
		if e.complexity.AudioMedia.MediaURL == nil {
			break
		}

		return e.complexity.AudioMedia.MediaURL(childComplexity), true

	case "AudioMedia.previewURLs":
		if e.complexity.AudioMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.AudioMedia.PreviewURLs(childComplexity), true

	case "AuthNonce.message":
		if e.complexity.AuthNonce.Message == nil {
			break
		}

		return e.complexity.AuthNonce.Message(childComplexity), true

	case "AuthNonce.nonce":
		if e.complexity.AuthNonce.Nonce == nil {
			break
		}

		return e.complexity.AuthNonce.Nonce(childComplexity), true

	case "ChainAddress.address":
		if e.complexity.ChainAddress.Address == nil {
			break
		}

		return e.complexity.ChainAddress.Address(childComplexity), true

	case "ChainAddress.chain":
		if e.complexity.ChainAddress.Chain == nil {
			break
		}

		return e.complexity.ChainAddress.Chain(childComplexity), true

	case "ChainPubKey.chain":
		if e.complexity.ChainPubKey.Chain == nil {
			break
		}

		return e.complexity.ChainPubKey.Chain(childComplexity), true

	case "ChainPubKey.pubKey":
		if e.complexity.ChainPubKey.PubKey == nil {
			break
		}

		return e.complexity.ChainPubKey.PubKey(childComplexity), true

	case "ChainSplits.chain":
		if e.complexity.ChainSplits.Chain == nil {
			break
		}

		return e.complexity.ChainSplits.Chain(childComplexity), true

	case "ChainSplits.splits":
		if e.complexity.ChainSplits.Splits == nil {
			break
		}

		return e.complexity.ChainSplits.Splits(childComplexity), true

	case "ChainTokens.chain":
		if e.complexity.ChainTokens.Chain == nil {
			break
		}

		return e.complexity.ChainTokens.Chain(childComplexity), true

	case "ChainTokens.tokens":
		if e.complexity.ChainTokens.Tokens == nil {
			break
		}

		return e.complexity.ChainTokens.Tokens(childComplexity), true

	case "ClearAllNotificationsPayload.notifications":
		if e.complexity.ClearAllNotificationsPayload.Notifications == nil {
			break
		}

		return e.complexity.ClearAllNotificationsPayload.Notifications(childComplexity), true

	case "CreateSplitPayload.split":
		if e.complexity.CreateSplitPayload.Split == nil {
			break
		}

		return e.complexity.CreateSplitPayload.Split(childComplexity), true

	case "CreateUserPayload.splitId":
		if e.complexity.CreateUserPayload.SplitID == nil {
			break
		}

		return e.complexity.CreateUserPayload.SplitID(childComplexity), true

	case "CreateUserPayload.userId":
		if e.complexity.CreateUserPayload.UserID == nil {
			break
		}

		return e.complexity.CreateUserPayload.UserID(childComplexity), true

	case "CreateUserPayload.viewer":
		if e.complexity.CreateUserPayload.Viewer == nil {
			break
		}

		return e.complexity.CreateUserPayload.Viewer(childComplexity), true

	case "DeleteSplitPayload.deletedId":
		if e.complexity.DeleteSplitPayload.DeletedID == nil {
			break
		}

		return e.complexity.DeleteSplitPayload.DeletedID(childComplexity), true

	case "DeletedNode.dbid":
		if e.complexity.DeletedNode.Dbid == nil {
			break
		}

		return e.complexity.DeletedNode.Dbid(childComplexity), true

	case "DeletedNode.id":
		if e.complexity.DeletedNode.ID == nil {
			break
		}

		return e.complexity.DeletedNode.ID(childComplexity), true

	case "EmailNotificationSettings.unsubscribedFromAll":
		if e.complexity.EmailNotificationSettings.UnsubscribedFromAll == nil {
			break
		}

		return e.complexity.EmailNotificationSettings.UnsubscribedFromAll(childComplexity), true

	case "EmailNotificationSettings.unsubscribedFromNotifications":
		if e.complexity.EmailNotificationSettings.UnsubscribedFromNotifications == nil {
			break
		}

		return e.complexity.EmailNotificationSettings.UnsubscribedFromNotifications(childComplexity), true

	case "ErrAddressOwnedByUser.message":
		if e.complexity.ErrAddressOwnedByUser.Message == nil {
			break
		}

		return e.complexity.ErrAddressOwnedByUser.Message(childComplexity), true

	case "ErrAuthenticationFailed.message":
		if e.complexity.ErrAuthenticationFailed.Message == nil {
			break
		}

		return e.complexity.ErrAuthenticationFailed.Message(childComplexity), true

	case "ErrCommunityNotFound.message":
		if e.complexity.ErrCommunityNotFound.Message == nil {
			break
		}

		return e.complexity.ErrCommunityNotFound.Message(childComplexity), true

	case "ErrDoesNotOwnRequiredToken.message":
		if e.complexity.ErrDoesNotOwnRequiredToken.Message == nil {
			break
		}

		return e.complexity.ErrDoesNotOwnRequiredToken.Message(childComplexity), true

	case "ErrInvalidInput.message":
		if e.complexity.ErrInvalidInput.Message == nil {
			break
		}

		return e.complexity.ErrInvalidInput.Message(childComplexity), true

	case "ErrInvalidInput.parameters":
		if e.complexity.ErrInvalidInput.Parameters == nil {
			break
		}

		return e.complexity.ErrInvalidInput.Parameters(childComplexity), true

	case "ErrInvalidInput.reasons":
		if e.complexity.ErrInvalidInput.Reasons == nil {
			break
		}

		return e.complexity.ErrInvalidInput.Reasons(childComplexity), true

	case "ErrInvalidToken.message":
		if e.complexity.ErrInvalidToken.Message == nil {
			break
		}

		return e.complexity.ErrInvalidToken.Message(childComplexity), true

	case "ErrNoCookie.message":
		if e.complexity.ErrNoCookie.Message == nil {
			break
		}

		return e.complexity.ErrNoCookie.Message(childComplexity), true

	case "ErrNotAuthorized.cause":
		if e.complexity.ErrNotAuthorized.Cause == nil {
			break
		}

		return e.complexity.ErrNotAuthorized.Cause(childComplexity), true

	case "ErrNotAuthorized.message":
		if e.complexity.ErrNotAuthorized.Message == nil {
			break
		}

		return e.complexity.ErrNotAuthorized.Message(childComplexity), true

	case "ErrPushTokenBelongsToAnotherUser.message":
		if e.complexity.ErrPushTokenBelongsToAnotherUser.Message == nil {
			break
		}

		return e.complexity.ErrPushTokenBelongsToAnotherUser.Message(childComplexity), true

	case "ErrSessionInvalidated.message":
		if e.complexity.ErrSessionInvalidated.Message == nil {
			break
		}

		return e.complexity.ErrSessionInvalidated.Message(childComplexity), true

	case "ErrSplitNotFound.message":
		if e.complexity.ErrSplitNotFound.Message == nil {
			break
		}

		return e.complexity.ErrSplitNotFound.Message(childComplexity), true

	case "ErrSyncFailed.message":
		if e.complexity.ErrSyncFailed.Message == nil {
			break
		}

		return e.complexity.ErrSyncFailed.Message(childComplexity), true

	case "ErrTokenNotFound.message":
		if e.complexity.ErrTokenNotFound.Message == nil {
			break
		}

		return e.complexity.ErrTokenNotFound.Message(childComplexity), true

	case "ErrUserAlreadyExists.message":
		if e.complexity.ErrUserAlreadyExists.Message == nil {
			break
		}

		return e.complexity.ErrUserAlreadyExists.Message(childComplexity), true

	case "ErrUserNotFound.message":
		if e.complexity.ErrUserNotFound.Message == nil {
			break
		}

		return e.complexity.ErrUserNotFound.Message(childComplexity), true

	case "ErrUsernameNotAvailable.message":
		if e.complexity.ErrUsernameNotAvailable.Message == nil {
			break
		}

		return e.complexity.ErrUsernameNotAvailable.Message(childComplexity), true

	case "GIFMedia.contentRenderURL":
		if e.complexity.GIFMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.GIFMedia.ContentRenderURL(childComplexity), true

	case "GIFMedia.dimensions":
		if e.complexity.GIFMedia.Dimensions == nil {
			break
		}

		return e.complexity.GIFMedia.Dimensions(childComplexity), true

	case "GIFMedia.mediaType":
		if e.complexity.GIFMedia.MediaType == nil {
			break
		}

		return e.complexity.GIFMedia.MediaType(childComplexity), true

	case "GIFMedia.mediaURL":
		if e.complexity.GIFMedia.MediaURL == nil {
			break
		}

		return e.complexity.GIFMedia.MediaURL(childComplexity), true

	case "GIFMedia.previewURLs":
		if e.complexity.GIFMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.GIFMedia.PreviewURLs(childComplexity), true

	case "GIFMedia.staticPreviewURLs":
		if e.complexity.GIFMedia.StaticPreviewURLs == nil {
			break
		}

		return e.complexity.GIFMedia.StaticPreviewURLs(childComplexity), true

	case "GltfMedia.contentRenderURL":
		if e.complexity.GltfMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.GltfMedia.ContentRenderURL(childComplexity), true

	case "GltfMedia.dimensions":
		if e.complexity.GltfMedia.Dimensions == nil {
			break
		}

		return e.complexity.GltfMedia.Dimensions(childComplexity), true

	case "GltfMedia.mediaType":
		if e.complexity.GltfMedia.MediaType == nil {
			break
		}

		return e.complexity.GltfMedia.MediaType(childComplexity), true

	case "GltfMedia.mediaURL":
		if e.complexity.GltfMedia.MediaURL == nil {
			break
		}

		return e.complexity.GltfMedia.MediaURL(childComplexity), true

	case "GltfMedia.previewURLs":
		if e.complexity.GltfMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.GltfMedia.PreviewURLs(childComplexity), true

	case "GroupNotificationUserEdge.cursor":
		if e.complexity.GroupNotificationUserEdge.Cursor == nil {
			break
		}

		return e.complexity.GroupNotificationUserEdge.Cursor(childComplexity), true

	case "GroupNotificationUserEdge.node":
		if e.complexity.GroupNotificationUserEdge.Node == nil {
			break
		}

		return e.complexity.GroupNotificationUserEdge.Node(childComplexity), true

	case "GroupNotificationUsersConnection.edges":
		if e.complexity.GroupNotificationUsersConnection.Edges == nil {
			break
		}

		return e.complexity.GroupNotificationUsersConnection.Edges(childComplexity), true

	case "GroupNotificationUsersConnection.pageInfo":
		if e.complexity.GroupNotificationUsersConnection.PageInfo == nil {
			break
		}

		return e.complexity.GroupNotificationUsersConnection.PageInfo(childComplexity), true

	case "HtmlMedia.contentRenderURL":
		if e.complexity.HtmlMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.HtmlMedia.ContentRenderURL(childComplexity), true

	case "HtmlMedia.dimensions":
		if e.complexity.HtmlMedia.Dimensions == nil {
			break
		}

		return e.complexity.HtmlMedia.Dimensions(childComplexity), true

	case "HtmlMedia.mediaType":
		if e.complexity.HtmlMedia.MediaType == nil {
			break
		}

		return e.complexity.HtmlMedia.MediaType(childComplexity), true

	case "HtmlMedia.mediaURL":
		if e.complexity.HtmlMedia.MediaURL == nil {
			break
		}

		return e.complexity.HtmlMedia.MediaURL(childComplexity), true

	case "HtmlMedia.previewURLs":
		if e.complexity.HtmlMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.HtmlMedia.PreviewURLs(childComplexity), true

	case "ImageMedia.contentRenderURL":
		if e.complexity.ImageMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.ImageMedia.ContentRenderURL(childComplexity), true

	case "ImageMedia.dimensions":
		if e.complexity.ImageMedia.Dimensions == nil {
			break
		}

		return e.complexity.ImageMedia.Dimensions(childComplexity), true

	case "ImageMedia.mediaType":
		if e.complexity.ImageMedia.MediaType == nil {
			break
		}

		return e.complexity.ImageMedia.MediaType(childComplexity), true

	case "ImageMedia.mediaURL":
		if e.complexity.ImageMedia.MediaURL == nil {
			break
		}

		return e.complexity.ImageMedia.MediaURL(childComplexity), true

	case "ImageMedia.previewURLs":
		if e.complexity.ImageMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.ImageMedia.PreviewURLs(childComplexity), true

	case "InvalidMedia.contentRenderURL":
		if e.complexity.InvalidMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.InvalidMedia.ContentRenderURL(childComplexity), true

	case "InvalidMedia.dimensions":
		if e.complexity.InvalidMedia.Dimensions == nil {
			break
		}

		return e.complexity.InvalidMedia.Dimensions(childComplexity), true

	case "InvalidMedia.mediaType":
		if e.complexity.InvalidMedia.MediaType == nil {
			break
		}

		return e.complexity.InvalidMedia.MediaType(childComplexity), true

	case "InvalidMedia.mediaURL":
		if e.complexity.InvalidMedia.MediaURL == nil {
			break
		}

		return e.complexity.InvalidMedia.MediaURL(childComplexity), true

	case "InvalidMedia.previewURLs":
		if e.complexity.InvalidMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.InvalidMedia.PreviewURLs(childComplexity), true

	case "JsonMedia.contentRenderURL":
		if e.complexity.JsonMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.JsonMedia.ContentRenderURL(childComplexity), true

	case "JsonMedia.dimensions":
		if e.complexity.JsonMedia.Dimensions == nil {
			break
		}

		return e.complexity.JsonMedia.Dimensions(childComplexity), true

	case "JsonMedia.mediaType":
		if e.complexity.JsonMedia.MediaType == nil {
			break
		}

		return e.complexity.JsonMedia.MediaType(childComplexity), true

	case "JsonMedia.mediaURL":
		if e.complexity.JsonMedia.MediaURL == nil {
			break
		}

		return e.complexity.JsonMedia.MediaURL(childComplexity), true

	case "JsonMedia.previewURLs":
		if e.complexity.JsonMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.JsonMedia.PreviewURLs(childComplexity), true

	case "LoginPayload.userId":
		if e.complexity.LoginPayload.UserID == nil {
			break
		}

		return e.complexity.LoginPayload.UserID(childComplexity), true

	case "LoginPayload.viewer":
		if e.complexity.LoginPayload.Viewer == nil {
			break
		}

		return e.complexity.LoginPayload.Viewer(childComplexity), true

	case "LogoutPayload.viewer":
		if e.complexity.LogoutPayload.Viewer == nil {
			break
		}

		return e.complexity.LogoutPayload.Viewer(childComplexity), true

	case "MediaDimensions.aspectRatio":
		if e.complexity.MediaDimensions.AspectRatio == nil {
			break
		}

		return e.complexity.MediaDimensions.AspectRatio(childComplexity), true

	case "MediaDimensions.height":
		if e.complexity.MediaDimensions.Height == nil {
			break
		}

		return e.complexity.MediaDimensions.Height(childComplexity), true

	case "MediaDimensions.width":
		if e.complexity.MediaDimensions.Width == nil {
			break
		}

		return e.complexity.MediaDimensions.Width(childComplexity), true

	case "Mutation.addRolesToUser":
		if e.complexity.Mutation.AddRolesToUser == nil {
			break
		}

		args, err := ec.field_Mutation_addRolesToUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRolesToUser(childComplexity, args["username"].(string), args["roles"].([]*persist.Role)), true

	case "Mutation.addUserWallet":
		if e.complexity.Mutation.AddUserWallet == nil {
			break
		}

		args, err := ec.field_Mutation_addUserWallet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUserWallet(childComplexity, args["chainAddress"].(persist.ChainAddress), args["authMechanism"].(model.AuthMechanism)), true

	case "Mutation.addWalletToUserUnchecked":
		if e.complexity.Mutation.AddWalletToUserUnchecked == nil {
			break
		}

		args, err := ec.field_Mutation_addWalletToUserUnchecked_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddWalletToUserUnchecked(childComplexity, args["input"].(model.AdminAddWalletInput)), true

	case "Mutation.clearAllNotifications":
		if e.complexity.Mutation.ClearAllNotifications == nil {
			break
		}

		return e.complexity.Mutation.ClearAllNotifications(childComplexity), true

	case "Mutation.createSplit":
		if e.complexity.Mutation.CreateSplit == nil {
			break
		}

		args, err := ec.field_Mutation_createSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSplit(childComplexity, args["input"].(model.CreateSplitInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["authMechanism"].(model.AuthMechanism), args["input"].(model.CreateUserInput)), true

	case "Mutation.deleteSplit":
		if e.complexity.Mutation.DeleteSplit == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSplit(childComplexity, args["splitId"].(persist.DBID)), true

	case "Mutation.getAuthNonce":
		if e.complexity.Mutation.GetAuthNonce == nil {
			break
		}

		return e.complexity.Mutation.GetAuthNonce(childComplexity), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["authMechanism"].(model.AuthMechanism)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		args, err := ec.field_Mutation_logout_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Logout(childComplexity, args["pushTokenToUnregister"].(*string)), true

	case "Mutation.optInForRoles":
		if e.complexity.Mutation.OptInForRoles == nil {
			break
		}

		args, err := ec.field_Mutation_optInForRoles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OptInForRoles(childComplexity, args["roles"].([]persist.Role)), true

	case "Mutation.optOutForRoles":
		if e.complexity.Mutation.OptOutForRoles == nil {
			break
		}

		args, err := ec.field_Mutation_optOutForRoles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OptOutForRoles(childComplexity, args["roles"].([]persist.Role)), true

	case "Mutation.preverifyEmail":
		if e.complexity.Mutation.PreverifyEmail == nil {
			break
		}

		args, err := ec.field_Mutation_preverifyEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PreverifyEmail(childComplexity, args["input"].(model.PreverifyEmailInput)), true

	case "Mutation.publishSplit":
		if e.complexity.Mutation.PublishSplit == nil {
			break
		}

		args, err := ec.field_Mutation_publishSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PublishSplit(childComplexity, args["input"].(model.PublishSplitInput)), true

	case "Mutation.registerUserPushToken":
		if e.complexity.Mutation.RegisterUserPushToken == nil {
			break
		}

		args, err := ec.field_Mutation_registerUserPushToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterUserPushToken(childComplexity, args["pushToken"].(string)), true

	case "Mutation.removeUserWallets":
		if e.complexity.Mutation.RemoveUserWallets == nil {
			break
		}

		args, err := ec.field_Mutation_removeUserWallets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveUserWallets(childComplexity, args["walletIds"].([]persist.DBID)), true

	case "Mutation.resendVerificationEmail":
		if e.complexity.Mutation.ResendVerificationEmail == nil {
			break
		}

		return e.complexity.Mutation.ResendVerificationEmail(childComplexity), true

	case "Mutation.revokeRolesFromUser":
		if e.complexity.Mutation.RevokeRolesFromUser == nil {
			break
		}

		args, err := ec.field_Mutation_revokeRolesFromUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeRolesFromUser(childComplexity, args["username"].(string), args["roles"].([]*persist.Role)), true

	case "Mutation.unregisterUserPushToken":
		if e.complexity.Mutation.UnregisterUserPushToken == nil {
			break
		}

		args, err := ec.field_Mutation_unregisterUserPushToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnregisterUserPushToken(childComplexity, args["pushToken"].(string)), true

	case "Mutation.unsubscribeFromEmailType":
		if e.complexity.Mutation.UnsubscribeFromEmailType == nil {
			break
		}

		args, err := ec.field_Mutation_unsubscribeFromEmailType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnsubscribeFromEmailType(childComplexity, args["input"].(model.UnsubscribeFromEmailTypeInput)), true

	case "Mutation.updateEmail":
		if e.complexity.Mutation.UpdateEmail == nil {
			break
		}

		args, err := ec.field_Mutation_updateEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEmail(childComplexity, args["input"].(model.UpdateEmailInput)), true

	case "Mutation.updateEmailNotificationSettings":
		if e.complexity.Mutation.UpdateEmailNotificationSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateEmailNotificationSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEmailNotificationSettings(childComplexity, args["input"].(model.UpdateEmailNotificationSettingsInput)), true

	case "Mutation.updateNotificationSettings":
		if e.complexity.Mutation.UpdateNotificationSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateNotificationSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNotificationSettings(childComplexity, args["settings"].(*model.NotificationSettingsInput)), true

	case "Mutation.updatePrimaryWallet":
		if e.complexity.Mutation.UpdatePrimaryWallet == nil {
			break
		}

		args, err := ec.field_Mutation_updatePrimaryWallet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePrimaryWallet(childComplexity, args["walletID"].(persist.DBID)), true

	case "Mutation.updateSplit":
		if e.complexity.Mutation.UpdateSplit == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplit(childComplexity, args["input"].(model.UpdateSplitInput)), true

	case "Mutation.updateSplitHidden":
		if e.complexity.Mutation.UpdateSplitHidden == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplitHidden_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplitHidden(childComplexity, args["input"].(model.UpdateSplitHiddenInput)), true

	case "Mutation.updateSplitInfo":
		if e.complexity.Mutation.UpdateSplitInfo == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplitInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplitInfo(childComplexity, args["input"].(model.UpdateSplitInfoInput)), true

	case "Mutation.updateSplitOrder":
		if e.complexity.Mutation.UpdateSplitOrder == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplitOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplitOrder(childComplexity, args["input"].(model.UpdateSplitOrderInput)), true

	case "Mutation.updateUserExperience":
		if e.complexity.Mutation.UpdateUserExperience == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserExperience_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserExperience(childComplexity, args["input"].(model.UpdateUserExperienceInput)), true

	case "Mutation.updateUserInfo":
		if e.complexity.Mutation.UpdateUserInfo == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserInfo(childComplexity, args["input"].(model.UpdateUserInfoInput)), true

	case "Mutation.uploadPersistedQueries":
		if e.complexity.Mutation.UploadPersistedQueries == nil {
			break
		}

		args, err := ec.field_Mutation_uploadPersistedQueries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadPersistedQueries(childComplexity, args["input"].(*model.UploadPersistedQueriesInput)), true

	case "Mutation.verifyEmail":
		if e.complexity.Mutation.VerifyEmail == nil {
			break
		}

		args, err := ec.field_Mutation_verifyEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VerifyEmail(childComplexity, args["input"].(model.VerifyEmailInput)), true

	case "Mutation.verifyEmailMagicLink":
		if e.complexity.Mutation.VerifyEmailMagicLink == nil {
			break
		}

		args, err := ec.field_Mutation_verifyEmailMagicLink_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VerifyEmailMagicLink(childComplexity, args["input"].(model.VerifyEmailMagicLinkInput)), true

	case "Mutation.viewSplit":
		if e.complexity.Mutation.ViewSplit == nil {
			break
		}

		args, err := ec.field_Mutation_viewSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ViewSplit(childComplexity, args["splitId"].(persist.DBID)), true

	case "NotificationEdge.cursor":
		if e.complexity.NotificationEdge.Cursor == nil {
			break
		}

		return e.complexity.NotificationEdge.Cursor(childComplexity), true

	case "NotificationEdge.node":
		if e.complexity.NotificationEdge.Node == nil {
			break
		}

		return e.complexity.NotificationEdge.Node(childComplexity), true

	case "NotificationSettings.someoneFollowedYou":
		if e.complexity.NotificationSettings.SomeoneFollowedYou == nil {
			break
		}

		return e.complexity.NotificationSettings.SomeoneFollowedYou(childComplexity), true

	case "NotificationSettings.someoneViewedYourSplit":
		if e.complexity.NotificationSettings.SomeoneViewedYourSplit == nil {
			break
		}

		return e.complexity.NotificationSettings.SomeoneViewedYourSplit(childComplexity), true

	case "NotificationsConnection.edges":
		if e.complexity.NotificationsConnection.Edges == nil {
			break
		}

		return e.complexity.NotificationsConnection.Edges(childComplexity), true

	case "NotificationsConnection.pageInfo":
		if e.complexity.NotificationsConnection.PageInfo == nil {
			break
		}

		return e.complexity.NotificationsConnection.PageInfo(childComplexity), true

	case "NotificationsConnection.unseenCount":
		if e.complexity.NotificationsConnection.UnseenCount == nil {
			break
		}

		return e.complexity.NotificationsConnection.UnseenCount(childComplexity), true

	case "OptInForRolesPayload.user":
		if e.complexity.OptInForRolesPayload.User == nil {
			break
		}

		return e.complexity.OptInForRolesPayload.User(childComplexity), true

	case "OptOutForRolesPayload.user":
		if e.complexity.OptOutForRolesPayload.User == nil {
			break
		}

		return e.complexity.OptOutForRolesPayload.User(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.size":
		if e.complexity.PageInfo.Size == nil {
			break
		}

		return e.complexity.PageInfo.Size(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PageInfo.total":
		if e.complexity.PageInfo.Total == nil {
			break
		}

		return e.complexity.PageInfo.Total(childComplexity), true

	case "PdfMedia.contentRenderURL":
		if e.complexity.PdfMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.PdfMedia.ContentRenderURL(childComplexity), true

	case "PdfMedia.dimensions":
		if e.complexity.PdfMedia.Dimensions == nil {
			break
		}

		return e.complexity.PdfMedia.Dimensions(childComplexity), true

	case "PdfMedia.mediaType":
		if e.complexity.PdfMedia.MediaType == nil {
			break
		}

		return e.complexity.PdfMedia.MediaType(childComplexity), true

	case "PdfMedia.mediaURL":
		if e.complexity.PdfMedia.MediaURL == nil {
			break
		}

		return e.complexity.PdfMedia.MediaURL(childComplexity), true

	case "PdfMedia.previewURLs":
		if e.complexity.PdfMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.PdfMedia.PreviewURLs(childComplexity), true

	case "PreverifyEmailPayload.email":
		if e.complexity.PreverifyEmailPayload.Email == nil {
			break
		}

		return e.complexity.PreverifyEmailPayload.Email(childComplexity), true

	case "PreverifyEmailPayload.result":
		if e.complexity.PreverifyEmailPayload.Result == nil {
			break
		}

		return e.complexity.PreverifyEmailPayload.Result(childComplexity), true

	case "PreviewURLSet.blurhash":
		if e.complexity.PreviewURLSet.Blurhash == nil {
			break
		}

		return e.complexity.PreviewURLSet.Blurhash(childComplexity), true

	case "PreviewURLSet.large":
		if e.complexity.PreviewURLSet.Large == nil {
			break
		}

		return e.complexity.PreviewURLSet.Large(childComplexity), true

	case "PreviewURLSet.liveRender":
		if e.complexity.PreviewURLSet.LiveRender == nil {
			break
		}

		return e.complexity.PreviewURLSet.LiveRender(childComplexity), true

	case "PreviewURLSet.medium":
		if e.complexity.PreviewURLSet.Medium == nil {
			break
		}

		return e.complexity.PreviewURLSet.Medium(childComplexity), true

	case "PreviewURLSet.raw":
		if e.complexity.PreviewURLSet.Raw == nil {
			break
		}

		return e.complexity.PreviewURLSet.Raw(childComplexity), true

	case "PreviewURLSet.small":
		if e.complexity.PreviewURLSet.Small == nil {
			break
		}

		return e.complexity.PreviewURLSet.Small(childComplexity), true

	case "PreviewURLSet.srcSet":
		if e.complexity.PreviewURLSet.SrcSet == nil {
			break
		}

		return e.complexity.PreviewURLSet.SrcSet(childComplexity), true

	case "PreviewURLSet.thumbnail":
		if e.complexity.PreviewURLSet.Thumbnail == nil {
			break
		}

		return e.complexity.PreviewURLSet.Thumbnail(childComplexity), true

	case "PublishSplitPayload.split":
		if e.complexity.PublishSplitPayload.Split == nil {
			break
		}

		return e.complexity.PublishSplitPayload.Split(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(model.GqlID)), true

	case "Query.searchSplits":
		if e.complexity.Query.SearchSplits == nil {
			break
		}

		args, err := ec.field_Query_searchSplits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchSplits(childComplexity, args["query"].(string), args["limit"].(*int), args["nameWeight"].(*float64), args["descriptionWeight"].(*float64)), true

	case "Query.searchUsers":
		if e.complexity.Query.SearchUsers == nil {
			break
		}

		args, err := ec.field_Query_searchUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchUsers(childComplexity, args["query"].(string), args["limit"].(*int), args["usernameWeight"].(*float64), args["bioWeight"].(*float64)), true

	case "Query.splitById":
		if e.complexity.Query.SplitByID == nil {
			break
		}

		args, err := ec.field_Query_splitById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SplitByID(childComplexity, args["id"].(persist.DBID)), true

	case "Query.userByAddress":
		if e.complexity.Query.UserByAddress == nil {
			break
		}

		args, err := ec.field_Query_userByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByAddress(childComplexity, args["chainAddress"].(persist.ChainAddress)), true

	case "Query.userById":
		if e.complexity.Query.UserByID == nil {
			break
		}

		args, err := ec.field_Query_userById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByID(childComplexity, args["id"].(persist.DBID)), true

	case "Query.userByUsername":
		if e.complexity.Query.UserByUsername == nil {
			break
		}

		args, err := ec.field_Query_userByUsername_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByUsername(childComplexity, args["username"].(string)), true

	case "Query.usersByRole":
		if e.complexity.Query.UsersByRole == nil {
			break
		}

		args, err := ec.field_Query_usersByRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsersByRole(childComplexity, args["role"].(persist.Role), args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.usersWithTrait":
		if e.complexity.Query.UsersWithTrait == nil {
			break
		}

		args, err := ec.field_Query_usersWithTrait_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsersWithTrait(childComplexity, args["trait"].(string)), true

	case "Query.viewer":
		if e.complexity.Query.Viewer == nil {
			break
		}

		return e.complexity.Query.Viewer(childComplexity), true

	case "Query.viewerSplitById":
		if e.complexity.Query.ViewerSplitByID == nil {
			break
		}

		args, err := ec.field_Query_viewerSplitById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ViewerSplitByID(childComplexity, args["id"].(persist.DBID)), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "Recipient.address":
		if e.complexity.Recipient.Address == nil {
			break
		}

		return e.complexity.Recipient.Address(childComplexity), true

	case "Recipient.creationTime":
		if e.complexity.Recipient.CreationTime == nil {
			break
		}

		return e.complexity.Recipient.CreationTime(childComplexity), true

	case "Recipient.dbid":
		if e.complexity.Recipient.Dbid == nil {
			break
		}

		return e.complexity.Recipient.Dbid(childComplexity), true

	case "Recipient.id":
		if e.complexity.Recipient.ID == nil {
			break
		}

		return e.complexity.Recipient.ID(childComplexity), true

	case "Recipient.lastUpdated":
		if e.complexity.Recipient.LastUpdated == nil {
			break
		}

		return e.complexity.Recipient.LastUpdated(childComplexity), true

	case "Recipient.ownership":
		if e.complexity.Recipient.Ownership == nil {
			break
		}

		return e.complexity.Recipient.Ownership(childComplexity), true

	case "Recipient.split":
		if e.complexity.Recipient.Split == nil {
			break
		}

		return e.complexity.Recipient.Split(childComplexity), true

	case "Recipient.version":
		if e.complexity.Recipient.Version == nil {
			break
		}

		return e.complexity.Recipient.Version(childComplexity), true

	case "RegisterUserPushTokenPayload.viewer":
		if e.complexity.RegisterUserPushTokenPayload.Viewer == nil {
			break
		}

		return e.complexity.RegisterUserPushTokenPayload.Viewer(childComplexity), true

	case "RemoveUserWalletsPayload.viewer":
		if e.complexity.RemoveUserWalletsPayload.Viewer == nil {
			break
		}

		return e.complexity.RemoveUserWalletsPayload.Viewer(childComplexity), true

	case "ResendVerificationEmailPayload.viewer":
		if e.complexity.ResendVerificationEmailPayload.Viewer == nil {
			break
		}

		return e.complexity.ResendVerificationEmailPayload.Viewer(childComplexity), true

	case "SearchSplitsPayload.results":
		if e.complexity.SearchSplitsPayload.Results == nil {
			break
		}

		return e.complexity.SearchSplitsPayload.Results(childComplexity), true

	case "SearchUsersPayload.results":
		if e.complexity.SearchUsersPayload.Results == nil {
			break
		}

		return e.complexity.SearchUsersPayload.Results(childComplexity), true

	case "Split.assets":
		if e.complexity.Split.Assets == nil {
			break
		}

		args, err := ec.field_Split_assets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Split.Assets(childComplexity, args["limit"].(*int)), true

	case "Split.badgeURL":
		if e.complexity.Split.BadgeURL == nil {
			break
		}

		return e.complexity.Split.BadgeURL(childComplexity), true

	case "Split.bannerURL":
		if e.complexity.Split.BannerURL == nil {
			break
		}

		return e.complexity.Split.BannerURL(childComplexity), true

	case "Split.chain":
		if e.complexity.Split.Chain == nil {
			break
		}

		return e.complexity.Split.Chain(childComplexity), true

	case "Split.dbid":
		if e.complexity.Split.Dbid == nil {
			break
		}

		return e.complexity.Split.Dbid(childComplexity), true

	case "Split.description":
		if e.complexity.Split.Description == nil {
			break
		}

		return e.complexity.Split.Description(childComplexity), true

	case "Split.id":
		if e.complexity.Split.ID == nil {
			break
		}

		return e.complexity.Split.ID(childComplexity), true

	case "Split.logoURL":
		if e.complexity.Split.LogoURL == nil {
			break
		}

		return e.complexity.Split.LogoURL(childComplexity), true

	case "Split.name":
		if e.complexity.Split.Name == nil {
			break
		}

		return e.complexity.Split.Name(childComplexity), true

	case "Split.shares":
		if e.complexity.Split.Shares == nil {
			break
		}

		args, err := ec.field_Split_shares_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Split.Shares(childComplexity, args["limit"].(*int)), true

	case "Split.version":
		if e.complexity.Split.Version == nil {
			break
		}

		return e.complexity.Split.Version(childComplexity), true

	case "SplitFiUser.bio":
		if e.complexity.SplitFiUser.Bio == nil {
			break
		}

		return e.complexity.SplitFiUser.Bio(childComplexity), true

	case "SplitFiUser.dbid":
		if e.complexity.SplitFiUser.Dbid == nil {
			break
		}

		return e.complexity.SplitFiUser.Dbid(childComplexity), true

	case "SplitFiUser.id":
		if e.complexity.SplitFiUser.ID == nil {
			break
		}

		return e.complexity.SplitFiUser.ID(childComplexity), true

	case "SplitFiUser.isAuthenticatedUser":
		if e.complexity.SplitFiUser.IsAuthenticatedUser == nil {
			break
		}

		return e.complexity.SplitFiUser.IsAuthenticatedUser(childComplexity), true

	case "SplitFiUser.primaryWallet":
		if e.complexity.SplitFiUser.PrimaryWallet == nil {
			break
		}

		return e.complexity.SplitFiUser.PrimaryWallet(childComplexity), true

	case "SplitFiUser.roles":
		if e.complexity.SplitFiUser.Roles == nil {
			break
		}

		return e.complexity.SplitFiUser.Roles(childComplexity), true

	case "SplitFiUser.splits":
		if e.complexity.SplitFiUser.Splits == nil {
			break
		}

		return e.complexity.SplitFiUser.Splits(childComplexity), true

	case "SplitFiUser.splitsByChain":
		if e.complexity.SplitFiUser.SplitsByChain == nil {
			break
		}

		args, err := ec.field_SplitFiUser_splitsByChain_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SplitFiUser.SplitsByChain(childComplexity, args["chain"].(persist.Chain)), true

	case "SplitFiUser.traits":
		if e.complexity.SplitFiUser.Traits == nil {
			break
		}

		return e.complexity.SplitFiUser.Traits(childComplexity), true

	case "SplitFiUser.universal":
		if e.complexity.SplitFiUser.Universal == nil {
			break
		}

		return e.complexity.SplitFiUser.Universal(childComplexity), true

	case "SplitFiUser.username":
		if e.complexity.SplitFiUser.Username == nil {
			break
		}

		return e.complexity.SplitFiUser.Username(childComplexity), true

	case "SplitFiUser.wallets":
		if e.complexity.SplitFiUser.Wallets == nil {
			break
		}

		return e.complexity.SplitFiUser.Wallets(childComplexity), true

	case "SplitSearchResult.split":
		if e.complexity.SplitSearchResult.Split == nil {
			break
		}

		return e.complexity.SplitSearchResult.Split(childComplexity), true

	case "Subscription.newNotification":
		if e.complexity.Subscription.NewNotification == nil {
			break
		}

		return e.complexity.Subscription.NewNotification(childComplexity), true

	case "Subscription.notificationUpdated":
		if e.complexity.Subscription.NotificationUpdated == nil {
			break
		}

		return e.complexity.Subscription.NotificationUpdated(childComplexity), true

	case "TextMedia.contentRenderURL":
		if e.complexity.TextMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.TextMedia.ContentRenderURL(childComplexity), true

	case "TextMedia.dimensions":
		if e.complexity.TextMedia.Dimensions == nil {
			break
		}

		return e.complexity.TextMedia.Dimensions(childComplexity), true

	case "TextMedia.mediaType":
		if e.complexity.TextMedia.MediaType == nil {
			break
		}

		return e.complexity.TextMedia.MediaType(childComplexity), true

	case "TextMedia.mediaURL":
		if e.complexity.TextMedia.MediaURL == nil {
			break
		}

		return e.complexity.TextMedia.MediaURL(childComplexity), true

	case "TextMedia.previewURLs":
		if e.complexity.TextMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.TextMedia.PreviewURLs(childComplexity), true

	case "Token.blockNumber":
		if e.complexity.Token.BlockNumber == nil {
			break
		}

		return e.complexity.Token.BlockNumber(childComplexity), true

	case "Token.chain":
		if e.complexity.Token.Chain == nil {
			break
		}

		return e.complexity.Token.Chain(childComplexity), true

	case "Token.contractAddress":
		if e.complexity.Token.ContractAddress == nil {
			break
		}

		return e.complexity.Token.ContractAddress(childComplexity), true

	case "Token.creationTime":
		if e.complexity.Token.CreationTime == nil {
			break
		}

		return e.complexity.Token.CreationTime(childComplexity), true

	case "Token.dbid":
		if e.complexity.Token.Dbid == nil {
			break
		}

		return e.complexity.Token.Dbid(childComplexity), true

	case "Token.decimals":
		if e.complexity.Token.Decimals == nil {
			break
		}

		return e.complexity.Token.Decimals(childComplexity), true

	case "Token.id":
		if e.complexity.Token.ID == nil {
			break
		}

		return e.complexity.Token.ID(childComplexity), true

	case "Token.isSpam":
		if e.complexity.Token.IsSpam == nil {
			break
		}

		return e.complexity.Token.IsSpam(childComplexity), true

	case "Token.lastUpdated":
		if e.complexity.Token.LastUpdated == nil {
			break
		}

		return e.complexity.Token.LastUpdated(childComplexity), true

	case "Token.logo":
		if e.complexity.Token.Logo == nil {
			break
		}

		return e.complexity.Token.Logo(childComplexity), true

	case "Token.name":
		if e.complexity.Token.Name == nil {
			break
		}

		return e.complexity.Token.Name(childComplexity), true

	case "Token.symbol":
		if e.complexity.Token.Symbol == nil {
			break
		}

		return e.complexity.Token.Symbol(childComplexity), true

	case "Token.tokenType":
		if e.complexity.Token.TokenType == nil {
			break
		}

		return e.complexity.Token.TokenType(childComplexity), true

	case "Token.totalSupply":
		if e.complexity.Token.TotalSupply == nil {
			break
		}

		return e.complexity.Token.TotalSupply(childComplexity), true

	case "Token.version":
		if e.complexity.Token.Version == nil {
			break
		}

		return e.complexity.Token.Version(childComplexity), true

	case "UnknownMedia.contentRenderURL":
		if e.complexity.UnknownMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.UnknownMedia.ContentRenderURL(childComplexity), true

	case "UnknownMedia.dimensions":
		if e.complexity.UnknownMedia.Dimensions == nil {
			break
		}

		return e.complexity.UnknownMedia.Dimensions(childComplexity), true

	case "UnknownMedia.mediaType":
		if e.complexity.UnknownMedia.MediaType == nil {
			break
		}

		return e.complexity.UnknownMedia.MediaType(childComplexity), true

	case "UnknownMedia.mediaURL":
		if e.complexity.UnknownMedia.MediaURL == nil {
			break
		}

		return e.complexity.UnknownMedia.MediaURL(childComplexity), true

	case "UnknownMedia.previewURLs":
		if e.complexity.UnknownMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.UnknownMedia.PreviewURLs(childComplexity), true

	case "UnregisterUserPushTokenPayload.viewer":
		if e.complexity.UnregisterUserPushTokenPayload.Viewer == nil {
			break
		}

		return e.complexity.UnregisterUserPushTokenPayload.Viewer(childComplexity), true

	case "UnsubscribeFromEmailTypePayload.viewer":
		if e.complexity.UnsubscribeFromEmailTypePayload.Viewer == nil {
			break
		}

		return e.complexity.UnsubscribeFromEmailTypePayload.Viewer(childComplexity), true

	case "UpdateEmailNotificationSettingsPayload.viewer":
		if e.complexity.UpdateEmailNotificationSettingsPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateEmailNotificationSettingsPayload.Viewer(childComplexity), true

	case "UpdateEmailPayload.viewer":
		if e.complexity.UpdateEmailPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateEmailPayload.Viewer(childComplexity), true

	case "UpdatePrimaryWalletPayload.viewer":
		if e.complexity.UpdatePrimaryWalletPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdatePrimaryWalletPayload.Viewer(childComplexity), true

	case "UpdateSplitHiddenPayload.split":
		if e.complexity.UpdateSplitHiddenPayload.Split == nil {
			break
		}

		return e.complexity.UpdateSplitHiddenPayload.Split(childComplexity), true

	case "UpdateSplitInfoPayload.split":
		if e.complexity.UpdateSplitInfoPayload.Split == nil {
			break
		}

		return e.complexity.UpdateSplitInfoPayload.Split(childComplexity), true

	case "UpdateSplitOrderPayload.viewer":
		if e.complexity.UpdateSplitOrderPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateSplitOrderPayload.Viewer(childComplexity), true

	case "UpdateSplitPayload.split":
		if e.complexity.UpdateSplitPayload.Split == nil {
			break
		}

		return e.complexity.UpdateSplitPayload.Split(childComplexity), true

	case "UpdateUserExperiencePayload.viewer":
		if e.complexity.UpdateUserExperiencePayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateUserExperiencePayload.Viewer(childComplexity), true

	case "UpdateUserInfoPayload.viewer":
		if e.complexity.UpdateUserInfoPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateUserInfoPayload.Viewer(childComplexity), true

	case "UploadPersistedQueriesPayload.message":
		if e.complexity.UploadPersistedQueriesPayload.Message == nil {
			break
		}

		return e.complexity.UploadPersistedQueriesPayload.Message(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UserEmail.email":
		if e.complexity.UserEmail.Email == nil {
			break
		}

		return e.complexity.UserEmail.Email(childComplexity), true

	case "UserEmail.emailNotificationSettings":
		if e.complexity.UserEmail.EmailNotificationSettings == nil {
			break
		}

		return e.complexity.UserEmail.EmailNotificationSettings(childComplexity), true

	case "UserEmail.verificationStatus":
		if e.complexity.UserEmail.VerificationStatus == nil {
			break
		}

		return e.complexity.UserEmail.VerificationStatus(childComplexity), true

	case "UserExperience.experienced":
		if e.complexity.UserExperience.Experienced == nil {
			break
		}

		return e.complexity.UserExperience.Experienced(childComplexity), true

	case "UserExperience.type":
		if e.complexity.UserExperience.Type == nil {
			break
		}

		return e.complexity.UserExperience.Type(childComplexity), true

	case "UserSearchResult.user":
		if e.complexity.UserSearchResult.User == nil {
			break
		}

		return e.complexity.UserSearchResult.User(childComplexity), true

	case "UsersConnection.edges":
		if e.complexity.UsersConnection.Edges == nil {
			break
		}

		return e.complexity.UsersConnection.Edges(childComplexity), true

	case "UsersConnection.pageInfo":
		if e.complexity.UsersConnection.PageInfo == nil {
			break
		}

		return e.complexity.UsersConnection.PageInfo(childComplexity), true

	case "VerifyEmailMagicLinkPayload.canSend":
		if e.complexity.VerifyEmailMagicLinkPayload.CanSend == nil {
			break
		}

		return e.complexity.VerifyEmailMagicLinkPayload.CanSend(childComplexity), true

	case "VerifyEmailPayload.email":
		if e.complexity.VerifyEmailPayload.Email == nil {
			break
		}

		return e.complexity.VerifyEmailPayload.Email(childComplexity), true

	case "VideoMedia.contentRenderURLs":
		if e.complexity.VideoMedia.ContentRenderURLs == nil {
			break
		}

		return e.complexity.VideoMedia.ContentRenderURLs(childComplexity), true

	case "VideoMedia.dimensions":
		if e.complexity.VideoMedia.Dimensions == nil {
			break
		}

		return e.complexity.VideoMedia.Dimensions(childComplexity), true

	case "VideoMedia.mediaType":
		if e.complexity.VideoMedia.MediaType == nil {
			break
		}

		return e.complexity.VideoMedia.MediaType(childComplexity), true

	case "VideoMedia.mediaURL":
		if e.complexity.VideoMedia.MediaURL == nil {
			break
		}

		return e.complexity.VideoMedia.MediaURL(childComplexity), true

	case "VideoMedia.previewURLs":
		if e.complexity.VideoMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.VideoMedia.PreviewURLs(childComplexity), true

	case "VideoURLSet.large":
		if e.complexity.VideoURLSet.Large == nil {
			break
		}

		return e.complexity.VideoURLSet.Large(childComplexity), true

	case "VideoURLSet.medium":
		if e.complexity.VideoURLSet.Medium == nil {
			break
		}

		return e.complexity.VideoURLSet.Medium(childComplexity), true

	case "VideoURLSet.raw":
		if e.complexity.VideoURLSet.Raw == nil {
			break
		}

		return e.complexity.VideoURLSet.Raw(childComplexity), true

	case "VideoURLSet.small":
		if e.complexity.VideoURLSet.Small == nil {
			break
		}

		return e.complexity.VideoURLSet.Small(childComplexity), true

	case "ViewSplitPayload.split":
		if e.complexity.ViewSplitPayload.Split == nil {
			break
		}

		return e.complexity.ViewSplitPayload.Split(childComplexity), true

	case "Viewer.email":
		if e.complexity.Viewer.Email == nil {
			break
		}

		return e.complexity.Viewer.Email(childComplexity), true

	case "Viewer.id":
		if e.complexity.Viewer.ID == nil {
			break
		}

		return e.complexity.Viewer.ID(childComplexity), true

	case "Viewer.notificationSettings":
		if e.complexity.Viewer.NotificationSettings == nil {
			break
		}

		return e.complexity.Viewer.NotificationSettings(childComplexity), true

	case "Viewer.notifications":
		if e.complexity.Viewer.Notifications == nil {
			break
		}

		args, err := ec.field_Viewer_notifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Viewer.Notifications(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Viewer.user":
		if e.complexity.Viewer.User == nil {
			break
		}

		return e.complexity.Viewer.User(childComplexity), true

	case "Viewer.userExperiences":
		if e.complexity.Viewer.UserExperiences == nil {
			break
		}

		return e.complexity.Viewer.UserExperiences(childComplexity), true

	case "Viewer.viewerSplits":
		if e.complexity.Viewer.ViewerSplits == nil {
			break
		}

		return e.complexity.Viewer.ViewerSplits(childComplexity), true

	case "ViewerSplit.split":
		if e.complexity.ViewerSplit.Split == nil {
			break
		}

		return e.complexity.ViewerSplit.Split(childComplexity), true

	case "Wallet.chain":
		if e.complexity.Wallet.Chain == nil {
			break
		}

		return e.complexity.Wallet.Chain(childComplexity), true

	case "Wallet.chainAddress":
		if e.complexity.Wallet.ChainAddress == nil {
			break
		}

		return e.complexity.Wallet.ChainAddress(childComplexity), true

	case "Wallet.dbid":
		if e.complexity.Wallet.Dbid == nil {
			break
		}

		return e.complexity.Wallet.Dbid(childComplexity), true

	case "Wallet.id":
		if e.complexity.Wallet.ID == nil {
			break
		}

		return e.complexity.Wallet.ID(childComplexity), true

	case "Wallet.splits":
		if e.complexity.Wallet.Splits == nil {
			break
		}

		return e.complexity.Wallet.Splits(childComplexity), true

	case "Wallet.walletType":
		if e.complexity.Wallet.WalletType == nil {
			break
		}

		return e.complexity.Wallet.WalletType(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAdminAddWalletInput,
		ec.unmarshalInputAuthMechanism,
		ec.unmarshalInputChainAddressInput,
		ec.unmarshalInputChainPubKeyInput,
		ec.unmarshalInputCreateSplitInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputDebugAuth,
		ec.unmarshalInputEoaAuth,
		ec.unmarshalInputGnosisSafeAuth,
		ec.unmarshalInputMagicLinkAuth,
		ec.unmarshalInputNotificationSettingsInput,
		ec.unmarshalInputOneTimeLoginTokenAuth,
		ec.unmarshalInputPreverifyEmailInput,
		ec.unmarshalInputPrivyAuth,
		ec.unmarshalInputPublishSplitInput,
		ec.unmarshalInputSplitPositionInput,
		ec.unmarshalInputSplitShareInput,
		ec.unmarshalInputUnsubscribeFromEmailTypeInput,
		ec.unmarshalInputUpdateEmailInput,
		ec.unmarshalInputUpdateEmailNotificationSettingsInput,
		ec.unmarshalInputUpdateSplitHiddenInput,
		ec.unmarshalInputUpdateSplitInfoInput,
		ec.unmarshalInputUpdateSplitInput,
		ec.unmarshalInputUpdateSplitOrderInput,
		ec.unmarshalInputUpdateUserExperienceInput,
		ec.unmarshalInputUpdateUserInfoInput,
		ec.unmarshalInputUploadPersistedQueriesInput,
		ec.unmarshalInputVerifyEmailInput,
		ec.unmarshalInputVerifyEmailMagicLinkInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/schema.graphql", Input: `"""
Any field decorated with the @experimental directive should not be used in production.
It will not conform to our rules around breaking changes.
"""
directive @experimental on FIELD_DEFINITION

# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
  forceResolver: Boolean
  name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Add @authRequired to any field that requires a user to be logged in. NOTE: Any field tagged with
# @authRequired MUST return a union type that includes ErrNotAuthorized.
#
# If we need more control over auth in the future, this directive can be updated to take
# arguments that specify the level of access required.
directive @authRequired on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Add @basicAuth to any field that should be secured by a basic auth token. For example, some fields
# should only be usable by Retool, so they'd use @basicAuth(allowed: [Retool]). Other fields might be
# accessible by both Retool and Monitoring, so they'd use @basicAuth(allowed: [Retool, Monitoring]).
directive @basicAuth(allowed: [BasicAuthType!]!) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @frontendBuildAuth on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Use @scrub on any input field that should be omitted from request logging (e.g. passwords or
# other sensitive data)
directive @scrub on INPUT_FIELD_DEFINITION

# Use @restrictEnvironment to choose which values of the ENV environment variable the annotated field/object
# should be usable in (case-insensitive). Example: @restrictEnvironment(allowed:["local", "development"]) would
# allow a field in "local" and "development" environments but not in "production"
directive @restrictEnvironment(
  allowed: [String!]!
) on INPUT_FIELD_DEFINITION | INPUT_OBJECT | FIELD_DEFINITION | OBJECT

# All types that implement Node must have a unique GqlID set in their "id" field. For types with
# a "dbid" field, it's assumed that we can synthesize a unique ID from the type name and the dbid,
# so those types will automatically have an ID function generated for them (which gqlgen will find
# and bind to). Types without a dbid field, or types that need multiple inputs to create a unique ID
# that can be used to refetch the node in the future, must use the @goGqlId directive to explicitly
# state the fields that will be used to generate the ID. If a named field exists on the object and is
# a string-based type, that field will be used as part of the ID automatically. Otherwise, a manual
# getter method will need to be implemented to retrieve that component of the GqlID.
directive @goGqlId(fields: [String!]!) on OBJECT

# Injects a "Helper<TypeName>Data" struct embed into a generated type. Useful for adding backend-only
# helper data necessary to resolve queries, while keeping that data out of the schema and invisible
# to clients.
directive @goEmbedHelper on OBJECT

scalar Time
scalar Address
scalar PubKey
scalar DBID
scalar Email

enum BasicAuthType {
  Retool
  Monitoring
}

interface Node {
  id: ID!
}

type DeletedNode implements Node {
  id: ID!
  dbid: DBID!
}

interface Error {
  message: String!
}

type SplitFiUser implements Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  username: String
  bio: String
  traits: String
  universal: Boolean
  roles: [Role] @goField(forceResolver: true)

  wallets: [Wallet] @goField(forceResolver: true)
  primaryWallet: Wallet @goField(forceResolver: true)
  # Returns all splits owned by this user. Useful for retrieving all tokens without any duplicates,
  # as opposed to retrieving user -> wallets -> splits, which would contain duplicates for any token
  # that appears in more than one of the user's wallets.
  splits: [Split] @goField(forceResolver: true)
  splitsByChain(chain: Chain!): ChainSplits @goField(forceResolver: true)
  isAuthenticatedUser: Boolean
}

type Wallet implements Node {
  id: ID!
  dbid: DBID!
  chainAddress: ChainAddress
  chain: Chain
  walletType: WalletType
  splits: [Split] @goField(forceResolver: true)
}

type ChainAddress {
  address: Address
  chain: Chain
}

type ChainPubKey {
  pubKey: PubKey
  chain: Chain
}

type ChainTokens {
  chain: Chain
  tokens: [Token]
}

type ChainSplits {
  chain: Chain
  splits: [Split]
}

input ChainAddressInput {
  address: Address! @goField(forceResolver: true)
  chain: Chain! @goField(forceResolver: true)
}

input ChainPubKeyInput {
  pubKey: PubKey! @goField(forceResolver: true)
  chain: Chain! @goField(forceResolver: true)
}

union SplitFiUserOrWallet = SplitFiUser | Wallet

union SplitFiUserOrAddress = SplitFiUser | ChainAddress

union MediaSubtype =
    ImageMedia
  | GIFMedia
  | VideoMedia
  | AudioMedia
  | TextMedia
  | PdfMedia
  | HtmlMedia
  | JsonMedia
  | GltfMedia
  | UnknownMedia
  | InvalidMedia

type PreviewURLSet {
  raw: String
  thumbnail: String
  small: String
  medium: String
  large: String
  srcSet: String
  liveRender: String
  blurhash: String @experimental @goField(forceResolver: true)
}

type VideoURLSet {
  raw: String
  small: String
  medium: String
  large: String
}

type MediaDimensions {
  width: Int
  height: Int
  aspectRatio: Float
}

interface Media {
  # Various sizes of preview images for the media
  previewURLs: PreviewURLSet

  # The original source URL for the media (may be IPFS, etc)
  mediaURL: String

  # The type of media, as determined by the backend. May be redundant given the approach we're using here
  # (media subtypes implementing the Media interface)
  mediaType: String

  # All Media types will also have something like contentRenderURL or contentRenderURLs,
  # which are the URL(s) that should actually be used for rendering the media's content

  # The dimensions of the media, if known
  dimensions: MediaDimensions
}

type ImageMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type GIFMedia implements Media {
  previewURLs: PreviewURLSet
  staticPreviewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type VideoMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURLs: VideoURLSet
  dimensions: MediaDimensions
}

type AudioMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type TextMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type PdfMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type HtmlMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type JsonMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type GltfMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type UnknownMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type InvalidMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

enum TokenType {
  ERC721
  ERC1155
  ERC20
}

enum Chain {
  Ethereum
  Arbitrum
  Polygon
  Optimism
}

enum WalletType {
  EOA
  GnosisSafe
}

type Token implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  creationTime: Time
  lastUpdated: Time
  tokenType: TokenType
  chain: Chain
  name: String
  symbol: String
  decimals: Int
  logo: String
  totalSupply: Int
  contractAddress: Int
  blockNumber: String # source is uint64
  isSpam: Boolean
}

type Asset implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  ownerAddress: ChainAddress
  balance: Int
  token: Token @goField(forceResolver: true)
}

type Recipient implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  creationTime: Time
  lastUpdated: Time
  address: Address
  split: Split @goField(forceResolver: true)
  ownership: Int
}

type Split implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  name: String
  description: String
  chain: Chain
  logoURL: String
  bannerURL: String
  badgeURL: String
  assets(limit: Int): [Asset] @goField(forceResolver: true)
  shares(limit: Int): [Recipient] @goField(forceResolver: true)
}

# We have this extra type in case we need to stick authed data
# in here one day.
type ViewerSplit {
  split: Split
}

type NotificationEdge {
  node: Notification
  cursor: String
}

type NotificationsConnection @goEmbedHelper {
  edges: [NotificationEdge]
  unseenCount: Int
  pageInfo: PageInfo
}

type Viewer implements Node @goGqlId(fields: ["userId"]) @goEmbedHelper {
  id: ID!
  user: SplitFiUser @goField(forceResolver: true)
  viewerSplits: [ViewerSplit] @goField(forceResolver: true)

  email: UserEmail @goField(forceResolver: true)
  """
  Returns a list of notifications in reverse chronological order.
  Seen notifications come after unseen notifications
  """
  notifications(before: String, after: String, first: Int, last: Int): NotificationsConnection
    @goField(forceResolver: true)

  notificationSettings: NotificationSettings @goField(forceResolver: true)

  userExperiences: [UserExperience!] @goField(forceResolver: true)
}

type NotificationSettings {
  someoneFollowedYou: Boolean
  someoneViewedYourSplit: Boolean
}

input NotificationSettingsInput {
  someoneFollowedYou: Boolean
  someoneViewedYourSplit: Boolean
}

enum EmailVerificationStatus {
  Unverified
  Verified
  Failed
  Admin
}

enum EmailUnsubscriptionType {
  All
  Notifications
}

type UserEmail {
  email: Email
  verificationStatus: EmailVerificationStatus
  emailNotificationSettings: EmailNotificationSettings @goField(forceResolver: true)
}

type EmailNotificationSettings {
  unsubscribedFromAll: Boolean!
  unsubscribedFromNotifications: Boolean!
}

input UpdateEmailNotificationSettingsInput {
  unsubscribedFromAll: Boolean!
  unsubscribedFromNotifications: Boolean!
}

input UnsubscribeFromEmailTypeInput {
  type: EmailUnsubscriptionType!
  token: String! @scrub
}

enum UserExperienceType {
  EmailUpsell
  MaintenanceFeb2023
  TwitterConnectionOnboardingUpsell
  UpsellMintMemento4
}

type UserExperience {
  type: UserExperienceType!
  experienced: Boolean!
}

union UserByUsernameOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union UserByIdOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union UserByAddressOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union ViewerOrError = Viewer | ErrNotAuthorized

type ErrTokenNotFound implements Error {
  message: String!
}

# Actions a user can take on a resource
enum Action {
  UserCreated
}

type PageInfo {
  total: Int
  size: Int!
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type UserEdge {
  node: SplitFiUser
  cursor: String
}

type UsersConnection {
  edges: [UserEdge]
  pageInfo: PageInfo!
}

enum Role {
  ADMIN
  BETA_TESTER
  EARLY_ACCESS
}

type ErrSplitNotFound implements Error {
  message: String!
}

union SplitByIdPayloadOrError = Split | ErrSplitNotFound
union ViewerSplitByIdPayloadOrError = ViewerSplit | ErrSplitNotFound

enum ReportWindow {
  LAST_5_DAYS
  LAST_7_DAYS
  ALL_TIME
}

type UserSearchResult {
  user: SplitFiUser
}

type SearchUsersPayload {
  results: [UserSearchResult!]
}

union SearchUsersPayloadOrError = SearchUsersPayload | ErrInvalidInput

type SplitSearchResult {
  split: Split
}

type SearchSplitsPayload {
  results: [SplitSearchResult!]
}

union SearchSplitsPayloadOrError = SearchSplitsPayload | ErrInvalidInput

type Query {
  node(id: ID!): Node
  viewer: ViewerOrError @authRequired
  userByUsername(username: String!): UserByUsernameOrError
  userById(id: DBID!): UserByIdOrError
  userByAddress(chainAddress: ChainAddressInput!): UserByAddressOrError
  usersWithTrait(trait: String!): [SplitFiUser]
  splitById(id: DBID!): SplitByIdPayloadOrError
  viewerSplitById(id: DBID!): ViewerSplitByIdPayloadOrError
  """
  Search for users with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. usernameWeight defaults to 0.4 and
  bioWeight defaults to 0.2, meaning that a search result matching a username is considered
  twice as relevant as a search result matching a bio.
  """
  searchUsers(
    query: String!
    limit: Int
    usernameWeight: Float
    bioWeight: Float
  ): SearchUsersPayloadOrError
  """
  Search for splits with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. nameWeight defaults to 0.4 and
  descriptionWeight defaults to 0.2, meaning that a search result matching a split name is
  considered twice as relevant as a search result matching a split description.
  """
  searchSplits(
    query: String!
    limit: Int
    nameWeight: Float
    descriptionWeight: Float
  ): SearchSplitsPayloadOrError

  # Retool Specific
  usersByRole(role: Role!, before: String, after: String, first: Int, last: Int): UsersConnection
    @basicAuth(allowed: [Retool])
}

union AddUserWalletPayloadOrError =
    AddUserWalletPayload
  | ErrAuthenticationFailed
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrAddressOwnedByUser

type AddUserWalletPayload {
  viewer: Viewer
}

union RemoveUserWalletsPayloadOrError =
    RemoveUserWalletsPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type RemoveUserWalletsPayload {
  viewer: Viewer
}

input UpdateUserInfoInput {
  username: String!
  bio: String!
}

union UpdateUserInfoPayloadOrError =
    UpdateUserInfoPayload
  | ErrNotAuthorized
  | ErrUsernameNotAvailable
  | ErrInvalidInput

type UpdateUserInfoPayload {
  viewer: Viewer
}

union RegisterUserPushTokenPayloadOrError =
  RegisterUserPushTokenPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrPushTokenBelongsToAnotherUser

type RegisterUserPushTokenPayload {
  viewer: Viewer
}

union UnregisterUserPushTokenPayloadOrError =
  UnregisterUserPushTokenPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrPushTokenBelongsToAnotherUser

type UnregisterUserPushTokenPayload {
  viewer: Viewer
}

type AuthNonce {
  nonce: String
  message: String
}

union GetAuthNoncePayloadOrError = AuthNonce

type ErrAuthenticationFailed implements Error {
  message: String!
}

type ErrUserAlreadyExists implements Error {
  message: String!
}

type ErrUsernameNotAvailable implements Error {
  message: String!
}

type ErrAddressOwnedByUser implements Error {
  message: String!
}

type ErrUserNotFound implements Error {
  message: String!
}

type ErrCommunityNotFound implements Error {
  message: String!
}

union AuthorizationError =
  ErrNoCookie
  | ErrInvalidToken
  | ErrSessionInvalidated
  | ErrDoesNotOwnRequiredToken

type ErrNotAuthorized implements Error {
  message: String!
  cause: AuthorizationError!
}

type ErrInvalidInput implements Error {
  message: String!
  parameters: [String!]!
  reasons: [String!]!
}

type ErrNoCookie implements Error {
  message: String!
}

type ErrInvalidToken implements Error {
  message: String!
}

type ErrSessionInvalidated implements Error {
  message: String!
}

type ErrDoesNotOwnRequiredToken implements Error {
  message: String!
}

type ErrSyncFailed implements Error {
  message: String!
}

type ErrPushTokenBelongsToAnotherUser implements Error {
  message: String!
}

input AuthMechanism {
  eoa: EoaAuth
  gnosisSafe: GnosisSafeAuth
  debug: DebugAuth
  magicLink: MagicLinkAuth
  oneTimeLoginToken: OneTimeLoginTokenAuth
  privy: PrivyAuth
}

input EoaAuth {
  chainPubKey: ChainPubKeyInput!
  nonce: String!
  message: String!
  signature: String! @scrub
}

# DebugAuth is a debug-only authentication mechanism for testing and debugging.
# It creates an authenticator that will return the supplied userId and chainAddresses as if they had been
# successfully authenticated. For existing users, the asUsername parameter may be supplied as a convenience
# method to look up and return their userId and chainAddresses.
input DebugAuth @restrictEnvironment(allowed: ["local", "development", "sandbox"]) {
  # Convenience method to authenticate as an existing user.
  # Cannot be used in conjunction with the userId and chainAddresses parameters.
  asUsername: String

  # The userId that will be returned from the resulting authenticator.
  # May be omitted or blank to indicate that there is no user associated with the supplied chainAddresses.
  # Cannot be used in conjunction with the asUsername parameter.
  userId: DBID

  # The chainAddresses that will be returned from the resulting authenticator.
  # Cannot be used in conjunction with the asUsername parameter.
  chainAddresses: [ChainAddressInput!]

  # A password required to use debug tools. Typically empty in local environments.
  debugToolsPassword: String
}

input GnosisSafeAuth {
  address: Address!
  nonce: String!
  message: String!
}

input MagicLinkAuth {
  token: String!
}

input PrivyAuth {
  token: String!
}

input OneTimeLoginTokenAuth {
  token: String!
}

union LoginPayloadOrError =
    LoginPayload
  | ErrUserNotFound
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredToken

type LoginPayload {
  # TODO: Remove userId in favor of viewer
  userId: DBID
  viewer: Viewer
}

type LogoutPayload {
  viewer: Viewer
}
input CreateUserInput {
  username: String!
  bio: String
  email: Email
  splitName: String
  splitDescription: String
  splitPosition: String
}

union CreateUserPayloadOrError =
    CreateUserPayload
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredToken
  | ErrUserAlreadyExists
  | ErrUsernameNotAvailable
  | ErrInvalidInput

type CreateUserPayload {
  userId: DBID
  splitId: DBID
  # TODO: Remove userId and splitId in favor of viewer
  viewer: Viewer
}

interface Notification implements Node {
  id: ID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
}

interface GroupedNotification implements Notification & Node {
  id: ID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  count: Int
}

type GroupNotificationUserEdge {
  node: SplitFiUser
  cursor: String
}

type GroupNotificationUsersConnection @goEmbedHelper {
  edges: [GroupNotificationUserEdge]
  pageInfo: PageInfo
}

type ClearAllNotificationsPayload {
  notifications: [Notification]
}

type ViewSplitPayload {
  split: Split
}

union ViewSplitPayloadOrError = ViewSplitPayload | ErrAuthenticationFailed

input VerifyEmailInput {
  token: String! @scrub
}

type VerifyEmailPayload {
  email: Email!
}

union VerifyEmailPayloadOrError = VerifyEmailPayload | ErrInvalidInput

input PreverifyEmailInput {
  email: Email! @scrub
}

enum PreverifyEmailResult {
  Invalid
  Risky
  Valid
}

type PreverifyEmailPayload {
  email: Email!
  result: PreverifyEmailResult!
}

union PreverifyEmailPayloadOrError = PreverifyEmailPayload | ErrInvalidInput

input VerifyEmailMagicLinkInput {
  email: Email! @scrub
}

type VerifyEmailMagicLinkPayload {
  canSend: Boolean!
}

union VerifyEmailMagicLinkPayloadOrError = VerifyEmailMagicLinkPayload | ErrInvalidInput

input UpdateEmailInput {
  email: Email! @scrub
  """
  authMechanism is an optional parameter that can verify a user's email address in lieu of sending
  a verification email to the user. If not provided, a verification email will be sent.
  """
  authMechanism: AuthMechanism
}

type UpdateEmailPayload {
  viewer: Viewer
}

union UpdateEmailPayloadOrError = UpdateEmailPayload | ErrInvalidInput

type ResendVerificationEmailPayload {
  viewer: Viewer
}

union ResendVerificationEmailPayloadOrError = ResendVerificationEmailPayload | ErrInvalidInput

type UpdateEmailNotificationSettingsPayload {
  viewer: Viewer
}

union UpdateEmailNotificationSettingsPayloadOrError =
  UpdateEmailNotificationSettingsPayload
  | ErrInvalidInput

type UnsubscribeFromEmailTypePayload {
  viewer: Viewer
}

union UnsubscribeFromEmailTypePayloadOrError = UnsubscribeFromEmailTypePayload | ErrInvalidInput

union AddRolesToUserPayloadOrError = SplitFiUser | ErrNotAuthorized
union RevokeRolesFromUserPayloadOrError = SplitFiUser | ErrNotAuthorized

type OptInForRolesPayload {
  user: SplitFiUser
}

type OptOutForRolesPayload {
  user: SplitFiUser
}

union OptInForRolesPayloadOrError = OptInForRolesPayload | ErrNotAuthorized | ErrInvalidInput
union OptOutForRolesPayloadOrError = OptOutForRolesPayload | ErrNotAuthorized | ErrInvalidInput

input UploadPersistedQueriesInput {
  persistedQueries: String
}

union UploadPersistedQueriesPayloadOrError = UploadPersistedQueriesPayload | ErrNotAuthorized

type UploadPersistedQueriesPayload {
  message: String
}

input SplitShareInput {
  splitId: DBID!
  recipientAddress: Address!
  ownership: Int!
}

input SplitPositionInput {
  splitId: DBID!
  position: String!
}

input UpdateSplitOrderInput {
  positions: [SplitPositionInput!]!
}

input UpdateSplitHiddenInput {
  id: DBID!
  hidden: Boolean!
}

input UpdateSplitInfoInput {
  id: DBID!
  name: String
  description: String
}

input CreateSplitInput {
  name: String
  description: String
  logo: String
}

type CreateSplitPayload {
  split: Split
}

union CreateSplitPayloadOrError = CreateSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdateSplitInfoPayload {
  split: Split
}

union UpdateSplitInfoPayloadOrError =
    UpdateSplitInfoPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type UpdateSplitHiddenPayload {
  split: Split
}

union UpdateSplitHiddenPayloadOrError =
    UpdateSplitHiddenPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type DeleteSplitPayload {
  deletedId: DeletedNode
}

union DeleteSplitPayloadOrError = DeleteSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdateSplitOrderPayload {
  viewer: Viewer
}

union UpdateSplitOrderPayloadOrError =
    UpdateSplitOrderPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input UpdateSplitInput {
  splitId: DBID!

  name: String
  description: String

  # leaving caption around for a bit for backwards compatibility
  caption: String

  deletedCollections: [DBID!]

  order: [DBID!]

  # generated on the frontend
  # will be String! in the future, not required for temp backwards compatibility
  editId: String
}

type UpdateSplitPayload {
  split: Split
}

union UpdateSplitPayloadOrError = UpdateSplitPayload | ErrInvalidInput | ErrNotAuthorized

input PublishSplitInput {
  splitId: DBID!
  editId: String!
  caption: String
}

type PublishSplitPayload {
  split: Split
}

union PublishSplitPayloadOrError = PublishSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdatePrimaryWalletPayload {
  viewer: Viewer
}

union UpdatePrimaryWalletPayloadOrError =
    UpdatePrimaryWalletPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input AdminAddWalletInput {
  username: String!
  chainAddress: ChainAddressInput!
  walletType: WalletType!
}

type AdminAddWalletPayload {
  user: SplitFiUser
}

union AdminAddWalletPayloadOrError =
    AdminAddWalletPayload
  | ErrUserNotFound
  | ErrAddressOwnedByUser
  | ErrNotAuthorized

input UpdateUserExperienceInput {
  experienceType: UserExperienceType!
  experienced: Boolean!
}

type UpdateUserExperiencePayload {
  viewer: Viewer
}

union UpdateUserExperiencePayloadOrError =
    UpdateUserExperiencePayload
  | ErrInvalidInput
  | ErrNotAuthorized

type Mutation {
  # User Mutations
  addUserWallet(
    chainAddress: ChainAddressInput!
    authMechanism: AuthMechanism!
  ): AddUserWalletPayloadOrError @authRequired
  removeUserWallets(walletIds: [DBID!]!): RemoveUserWalletsPayloadOrError @authRequired
  updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayloadOrError @authRequired
  registerUserPushToken(pushToken: String!): RegisterUserPushTokenPayloadOrError @authRequired
  unregisterUserPushToken(pushToken: String!): UnregisterUserPushTokenPayloadOrError @authRequired

  getAuthNonce: GetAuthNoncePayloadOrError

  createUser(authMechanism: AuthMechanism!, input: CreateUserInput!): CreateUserPayloadOrError
  updateEmail(input: UpdateEmailInput!): UpdateEmailPayloadOrError @authRequired
  resendVerificationEmail: ResendVerificationEmailPayloadOrError @authRequired
  updateEmailNotificationSettings(
    input: UpdateEmailNotificationSettingsInput!
  ): UpdateEmailNotificationSettingsPayloadOrError @authRequired
  unsubscribeFromEmailType(
    input: UnsubscribeFromEmailTypeInput!
  ): UnsubscribeFromEmailTypePayloadOrError
  login(authMechanism: AuthMechanism!): LoginPayloadOrError
  logout(pushTokenToUnregister: String): LogoutPayload

  viewSplit(splitId: DBID!): ViewSplitPayloadOrError

  updateSplit(input: UpdateSplitInput!): UpdateSplitPayloadOrError @authRequired
  publishSplit(input: PublishSplitInput!): PublishSplitPayloadOrError @authRequired

  createSplit(input: CreateSplitInput!): CreateSplitPayloadOrError @authRequired
  updateSplitHidden(input: UpdateSplitHiddenInput!): UpdateSplitHiddenPayloadOrError
    @authRequired
  deleteSplit(splitId: DBID!): DeleteSplitPayloadOrError @authRequired
  updateSplitOrder(input: UpdateSplitOrderInput!): UpdateSplitOrderPayloadOrError
    @authRequired
  updateSplitInfo(input: UpdateSplitInfoInput!): UpdateSplitInfoPayloadOrError @authRequired

  clearAllNotifications: ClearAllNotificationsPayload @authRequired

  updateNotificationSettings(settings: NotificationSettingsInput): NotificationSettings

  preverifyEmail(input: PreverifyEmailInput!): PreverifyEmailPayloadOrError
  verifyEmail(input: VerifyEmailInput!): VerifyEmailPayloadOrError
  verifyEmailMagicLink(input: VerifyEmailMagicLinkInput!): VerifyEmailMagicLinkPayloadOrError

  optInForRoles(roles: [Role!]!): OptInForRolesPayloadOrError @authRequired
  optOutForRoles(roles: [Role!]!): OptOutForRolesPayloadOrError @authRequired

  # Retool Specific Mutations
  addRolesToUser(username: String!, roles: [Role]): AddRolesToUserPayloadOrError @basicAuth(allowed: [Retool])
  addWalletToUserUnchecked(input: AdminAddWalletInput!): AdminAddWalletPayloadOrError @basicAuth(allowed: [Retool])
  revokeRolesFromUser(username: String!, roles: [Role]): RevokeRolesFromUserPayloadOrError
    @basicAuth(allowed: [Retool])

  # SplitFi Frontend Deploy Persisted Queries
  uploadPersistedQueries(input: UploadPersistedQueriesInput): UploadPersistedQueriesPayloadOrError
    @frontendBuildAuth

  updatePrimaryWallet(walletID: DBID!): UpdatePrimaryWalletPayloadOrError @authRequired

  updateUserExperience(input: UpdateUserExperienceInput!): UpdateUserExperiencePayloadOrError
    @authRequired
}

type Subscription {
  newNotification: Notification
  notificationUpdated: Notification
}
`, BuiltIn: false},
	{Name: "../../federation/directives.graphql", Input: `
	directive @authenticated on FIELD_DEFINITION | OBJECT | INTERFACE | SCALAR | ENUM
	directive @composeDirective(name: String!) repeatable on SCHEMA
	directive @extends on OBJECT | INTERFACE
	directive @external on OBJECT | FIELD_DEFINITION
	directive @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @inaccessible on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	directive @interfaceObject on OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @override(from: String!, label: String) on FIELD_DEFINITION
	directive @policy(policies: [[federation__Policy!]!]!) on 
	  | FIELD_DEFINITION
	  | OBJECT
	  | INTERFACE
	  | SCALAR
	  | ENUM
	directive @provides(fields: FieldSet!) on FIELD_DEFINITION
	directive @requires(fields: FieldSet!) on FIELD_DEFINITION
	directive @requiresScopes(scopes: [[federation__Scope!]!]!) on 
	  | FIELD_DEFINITION
	  | OBJECT
	  | INTERFACE
	  | SCALAR
	  | ENUM
	directive @shareable repeatable on FIELD_DEFINITION | OBJECT
	directive @tag(name: String!) repeatable on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	scalar _Any
	scalar FieldSet
	scalar federation__Policy
	scalar federation__Scope
`, BuiltIn: true},
	{Name: "../../federation/entity.graphql", Input: `
type _Service {
  sdl: String
}

extend type Query {
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_basicAuth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []basicauth.AuthTokenType
	if tmp, ok := rawArgs["allowed"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowed"))
		arg0, err = ec.unmarshalNBasicAuthType2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenTypeᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowed"] = arg0
	return args, nil
}

func (ec *executionContext) dir_restrictEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["allowed"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowed"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowed"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addRolesToUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 []*persist.Role
	if tmp, ok := rawArgs["roles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
		arg1, err = ec.unmarshalORole2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roles"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addUserWallet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.ChainAddress
	if tmp, ok := rawArgs["chainAddress"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddress"))
		arg0, err = ec.unmarshalNChainAddressInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chainAddress"] = arg0
	var arg1 model.AuthMechanism
	if tmp, ok := rawArgs["authMechanism"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMechanism"))
		arg1, err = ec.unmarshalNAuthMechanism2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAuthMechanism(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authMechanism"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addWalletToUserUnchecked_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AdminAddWalletInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAdminAddWalletInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAdminAddWalletInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateSplitInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateSplitInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐCreateSplitInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AuthMechanism
	if tmp, ok := rawArgs["authMechanism"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMechanism"))
		arg0, err = ec.unmarshalNAuthMechanism2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAuthMechanism(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authMechanism"] = arg0
	var arg1 model.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNCreateUserInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐCreateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["splitId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
		arg0, err = ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["splitId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_login_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AuthMechanism
	if tmp, ok := rawArgs["authMechanism"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMechanism"))
		arg0, err = ec.unmarshalNAuthMechanism2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAuthMechanism(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authMechanism"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_logout_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["pushTokenToUnregister"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushTokenToUnregister"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pushTokenToUnregister"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_optInForRoles_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []persist.Role
	if tmp, ok := rawArgs["roles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
		arg0, err = ec.unmarshalNRole2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRoleᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roles"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_optOutForRoles_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []persist.Role
	if tmp, ok := rawArgs["roles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
		arg0, err = ec.unmarshalNRole2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRoleᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roles"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_preverifyEmail_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PreverifyEmailInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNPreverifyEmailInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreverifyEmailInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_publishSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PublishSplitInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNPublishSplitInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPublishSplitInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registerUserPushToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["pushToken"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushToken"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pushToken"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeUserWallets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []persist.DBID
	if tmp, ok := rawArgs["walletIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("walletIds"))
		arg0, err = ec.unmarshalNDBID2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBIDᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["walletIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_revokeRolesFromUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 []*persist.Role
	if tmp, ok := rawArgs["roles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
		arg1, err = ec.unmarshalORole2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roles"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unregisterUserPushToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["pushToken"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pushToken"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pushToken"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unsubscribeFromEmailType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UnsubscribeFromEmailTypeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUnsubscribeFromEmailTypeInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUnsubscribeFromEmailTypeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEmailNotificationSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateEmailNotificationSettingsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateEmailNotificationSettingsInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateEmailNotificationSettingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEmail_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateEmailInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateEmailInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateEmailInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateNotificationSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.NotificationSettingsInput
	if tmp, ok := rawArgs["settings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settings"))
		arg0, err = ec.unmarshalONotificationSettingsInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationSettingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["settings"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePrimaryWallet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["walletID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("walletID"))
		arg0, err = ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["walletID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplitHidden_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitHiddenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitHiddenInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitHiddenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplitInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitInfoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitInfoInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplitOrder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitOrderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitOrderInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitOrderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserExperience_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateUserExperienceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateUserExperienceInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateUserExperienceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateUserInfoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateUserInfoInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateUserInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_uploadPersistedQueries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.UploadPersistedQueriesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUploadPersistedQueriesInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUploadPersistedQueriesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_verifyEmailMagicLink_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.VerifyEmailMagicLinkInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNVerifyEmailMagicLinkInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVerifyEmailMagicLinkInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_verifyEmail_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.VerifyEmailInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNVerifyEmailInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVerifyEmailInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_viewSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["splitId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
		arg0, err = ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["splitId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GqlID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_searchSplits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *float64
	if tmp, ok := rawArgs["nameWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameWeight"))
		arg2, err = ec.unmarshalOFloat2ᚖfloat64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["nameWeight"] = arg2
	var arg3 *float64
	if tmp, ok := rawArgs["descriptionWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionWeight"))
		arg3, err = ec.unmarshalOFloat2ᚖfloat64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["descriptionWeight"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_searchUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *float64
	if tmp, ok := rawArgs["usernameWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameWeight"))
		arg2, err = ec.unmarshalOFloat2ᚖfloat64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["usernameWeight"] = arg2
	var arg3 *float64
	if tmp, ok := rawArgs["bioWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioWeight"))
		arg3, err = ec.unmarshalOFloat2ᚖfloat64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bioWeight"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_splitById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.ChainAddress
	if tmp, ok := rawArgs["chainAddress"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddress"))
		arg0, err = ec.unmarshalNChainAddressInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chainAddress"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userByUsername_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_usersByRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.Role
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg0, err = ec.unmarshalNRole2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_usersWithTrait_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["trait"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trait"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["trait"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_viewerSplitById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_SplitFiUser_splitsByChain_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.Chain
	if tmp, ok := rawArgs["chain"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
		arg0, err = ec.unmarshalNChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chain"] = arg0
	return args, nil
}

func (ec *executionContext) field_Split_assets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Split_shares_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Viewer_notifications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddUserWalletPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.AddUserWalletPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddUserWalletPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddUserWalletPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddUserWalletPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminAddWalletPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.AdminAddWalletPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminAddWalletPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminAddWalletPayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminAddWalletPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "splitsByChain":
				return ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Asset_id(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Asset_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Asset_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Asset_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Asset_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Asset_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Asset_version(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Asset_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Asset_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Asset_ownerAddress(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Asset_ownerAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Asset_ownerAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Asset_balance(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Asset_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Asset_balance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Asset_token(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Asset_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Asset().Token(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Token)
	fc.Result = res
	return ec.marshalOToken2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Asset_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Token_version(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "symbol":
				return ec.fieldContext_Token_symbol(ctx, field)
			case "decimals":
				return ec.fieldContext_Token_decimals(ctx, field)
			case "logo":
				return ec.fieldContext_Token_logo(ctx, field)
			case "totalSupply":
				return ec.fieldContext_Token_totalSupply(ctx, field)
			case "contractAddress":
				return ec.fieldContext_Token_contractAddress(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpam":
				return ec.fieldContext_Token_isSpam(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthNonce_nonce(ctx context.Context, field graphql.CollectedField, obj *model.AuthNonce) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthNonce_nonce(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthNonce_nonce(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthNonce",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthNonce_message(ctx context.Context, field graphql.CollectedField, obj *model.AuthNonce) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthNonce_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthNonce_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthNonce",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainAddress_address(ctx context.Context, field graphql.CollectedField, obj *persist.ChainAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainAddress_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(persist.Address)
	fc.Result = res
	return ec.marshalOAddress2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainAddress_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainAddress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainAddress_chain(ctx context.Context, field graphql.CollectedField, obj *persist.ChainAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainAddress_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainAddress_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainAddress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainPubKey_pubKey(ctx context.Context, field graphql.CollectedField, obj *persist.ChainPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainPubKey_pubKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PubKey(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(persist.PubKey)
	fc.Result = res
	return ec.marshalOPubKey2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐPubKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainPubKey_pubKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainPubKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PubKey does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainPubKey_chain(ctx context.Context, field graphql.CollectedField, obj *persist.ChainPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainPubKey_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainPubKey_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainPubKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainSplits_chain(ctx context.Context, field graphql.CollectedField, obj *model.ChainSplits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainSplits_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainSplits_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainSplits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainSplits_splits(ctx context.Context, field graphql.CollectedField, obj *model.ChainSplits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainSplits_splits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Splits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainSplits_splits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainSplits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainTokens_chain(ctx context.Context, field graphql.CollectedField, obj *model.ChainTokens) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainTokens_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainTokens_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainTokens",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainTokens_tokens(ctx context.Context, field graphql.CollectedField, obj *model.ChainTokens) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainTokens_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Token)
	fc.Result = res
	return ec.marshalOToken2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainTokens_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainTokens",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Token_version(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "symbol":
				return ec.fieldContext_Token_symbol(ctx, field)
			case "decimals":
				return ec.fieldContext_Token_decimals(ctx, field)
			case "logo":
				return ec.fieldContext_Token_logo(ctx, field)
			case "totalSupply":
				return ec.fieldContext_Token_totalSupply(ctx, field)
			case "contractAddress":
				return ec.fieldContext_Token_contractAddress(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpam":
				return ec.fieldContext_Token_isSpam(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClearAllNotificationsPayload_notifications(ctx context.Context, field graphql.CollectedField, obj *model.ClearAllNotificationsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClearAllNotificationsPayload_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Notification)
	fc.Result = res
	return ec.marshalONotification2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClearAllNotificationsPayload_notifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClearAllNotificationsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateSplitPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.CreateSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateSplitPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateSplitPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateUserPayload_userId(ctx context.Context, field graphql.CollectedField, obj *model.CreateUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateUserPayload_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.DBID)
	fc.Result = res
	return ec.marshalODBID2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateUserPayload_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateUserPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateUserPayload_splitId(ctx context.Context, field graphql.CollectedField, obj *model.CreateUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateUserPayload_splitId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SplitID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.DBID)
	fc.Result = res
	return ec.marshalODBID2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateUserPayload_splitId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateUserPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateUserPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.CreateUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateUserPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateUserPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateUserPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteSplitPayload_deletedId(ctx context.Context, field graphql.CollectedField, obj *model.DeleteSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteSplitPayload_deletedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeletedNode)
	fc.Result = res
	return ec.marshalODeletedNode2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐDeletedNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteSplitPayload_deletedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeletedNode_id(ctx, field)
			case "dbid":
				return ec.fieldContext_DeletedNode_dbid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletedNode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedNode_id(ctx context.Context, field graphql.CollectedField, obj *model.DeletedNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedNode_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedNode_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedNode",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedNode_dbid(ctx context.Context, field graphql.CollectedField, obj *model.DeletedNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedNode_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedNode_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmailNotificationSettings_unsubscribedFromAll(ctx context.Context, field graphql.CollectedField, obj *model.EmailNotificationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmailNotificationSettings_unsubscribedFromAll(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnsubscribedFromAll, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmailNotificationSettings_unsubscribedFromAll(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmailNotificationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmailNotificationSettings_unsubscribedFromNotifications(ctx context.Context, field graphql.CollectedField, obj *model.EmailNotificationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmailNotificationSettings_unsubscribedFromNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnsubscribedFromNotifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmailNotificationSettings_unsubscribedFromNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmailNotificationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrAddressOwnedByUser_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrAddressOwnedByUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrAddressOwnedByUser_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrAddressOwnedByUser_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrAddressOwnedByUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrAuthenticationFailed_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrAuthenticationFailed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrAuthenticationFailed_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrAuthenticationFailed_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrAuthenticationFailed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrCommunityNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrCommunityNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrCommunityNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrCommunityNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrCommunityNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrDoesNotOwnRequiredToken_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrDoesNotOwnRequiredToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrDoesNotOwnRequiredToken_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrDoesNotOwnRequiredToken_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrDoesNotOwnRequiredToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrInvalidInput_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrInvalidInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrInvalidInput_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrInvalidInput_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrInvalidInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrInvalidInput_parameters(ctx context.Context, field graphql.CollectedField, obj *model.ErrInvalidInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrInvalidInput_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrInvalidInput_parameters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrInvalidInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrInvalidInput_reasons(ctx context.Context, field graphql.CollectedField, obj *model.ErrInvalidInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrInvalidInput_reasons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reasons, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrInvalidInput_reasons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrInvalidInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrInvalidToken_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrInvalidToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrInvalidToken_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrInvalidToken_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrInvalidToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrNoCookie_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrNoCookie) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrNoCookie_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrNoCookie_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrNoCookie",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrNotAuthorized_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrNotAuthorized) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrNotAuthorized_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrNotAuthorized_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrNotAuthorized",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrNotAuthorized_cause(ctx context.Context, field graphql.CollectedField, obj *model.ErrNotAuthorized) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrNotAuthorized_cause(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cause, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthorizationError)
	fc.Result = res
	return ec.marshalNAuthorizationError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAuthorizationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrNotAuthorized_cause(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrNotAuthorized",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuthorizationError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrPushTokenBelongsToAnotherUser_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrPushTokenBelongsToAnotherUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrPushTokenBelongsToAnotherUser_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrPushTokenBelongsToAnotherUser_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrPushTokenBelongsToAnotherUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrSessionInvalidated_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrSessionInvalidated) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrSessionInvalidated_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrSessionInvalidated_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrSessionInvalidated",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrSplitNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrSplitNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrSplitNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrSplitNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrSplitNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrSyncFailed_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrSyncFailed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrSyncFailed_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrSyncFailed_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrSyncFailed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrTokenNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrTokenNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrTokenNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrTokenNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrTokenNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrUserAlreadyExists_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrUserAlreadyExists) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrUserAlreadyExists_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrUserAlreadyExists_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrUserAlreadyExists",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrUserNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrUserNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrUserNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrUserNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrUserNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrUsernameNotAvailable_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrUsernameNotAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrUsernameNotAvailable_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrUsernameNotAvailable_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrUsernameNotAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_staticPreviewURLs(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_staticPreviewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticPreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_staticPreviewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupNotificationUserEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.GroupNotificationUserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupNotificationUserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupNotificationUserEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupNotificationUserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "splitsByChain":
				return ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupNotificationUserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.GroupNotificationUserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupNotificationUserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupNotificationUserEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupNotificationUserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupNotificationUsersConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.GroupNotificationUsersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupNotificationUsersConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GroupNotificationUserEdge)
	fc.Result = res
	return ec.marshalOGroupNotificationUserEdge2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGroupNotificationUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupNotificationUsersConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupNotificationUsersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GroupNotificationUserEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GroupNotificationUserEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupNotificationUserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupNotificationUsersConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.GroupNotificationUsersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupNotificationUsersConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalOPageInfo2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupNotificationUsersConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupNotificationUsersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginPayload_userId(ctx context.Context, field graphql.CollectedField, obj *model.LoginPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginPayload_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.DBID)
	fc.Result = res
	return ec.marshalODBID2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginPayload_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.LoginPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogoutPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.LogoutPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogoutPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogoutPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogoutPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MediaDimensions_width(ctx context.Context, field graphql.CollectedField, obj *model.MediaDimensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MediaDimensions_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MediaDimensions_width(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MediaDimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MediaDimensions_height(ctx context.Context, field graphql.CollectedField, obj *model.MediaDimensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MediaDimensions_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MediaDimensions_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MediaDimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MediaDimensions_aspectRatio(ctx context.Context, field graphql.CollectedField, obj *model.MediaDimensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AspectRatio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MediaDimensions_aspectRatio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MediaDimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addUserWallet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addUserWallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddUserWallet(rctx, fc.Args["chainAddress"].(persist.ChainAddress), fc.Args["authMechanism"].(model.AuthMechanism))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.AddUserWalletPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.AddUserWalletPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.AddUserWalletPayloadOrError)
	fc.Result = res
	return ec.marshalOAddUserWalletPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAddUserWalletPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addUserWallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AddUserWalletPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addUserWallet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeUserWallets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeUserWallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RemoveUserWallets(rctx, fc.Args["walletIds"].([]persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.RemoveUserWalletsPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.RemoveUserWalletsPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.RemoveUserWalletsPayloadOrError)
	fc.Result = res
	return ec.marshalORemoveUserWalletsPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRemoveUserWalletsPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeUserWallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RemoveUserWalletsPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeUserWallets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUserInfo(rctx, fc.Args["input"].(model.UpdateUserInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateUserInfoPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateUserInfoPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateUserInfoPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateUserInfoPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateUserInfoPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateUserInfoPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registerUserPushToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registerUserPushToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RegisterUserPushToken(rctx, fc.Args["pushToken"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.RegisterUserPushTokenPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.RegisterUserPushTokenPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.RegisterUserPushTokenPayloadOrError)
	fc.Result = res
	return ec.marshalORegisterUserPushTokenPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRegisterUserPushTokenPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registerUserPushToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RegisterUserPushTokenPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registerUserPushToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unregisterUserPushToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unregisterUserPushToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnregisterUserPushToken(rctx, fc.Args["pushToken"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UnregisterUserPushTokenPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UnregisterUserPushTokenPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UnregisterUserPushTokenPayloadOrError)
	fc.Result = res
	return ec.marshalOUnregisterUserPushTokenPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUnregisterUserPushTokenPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unregisterUserPushToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UnregisterUserPushTokenPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unregisterUserPushToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_getAuthNonce(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_getAuthNonce(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetAuthNonce(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.GetAuthNoncePayloadOrError)
	fc.Result = res
	return ec.marshalOGetAuthNoncePayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGetAuthNoncePayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_getAuthNonce(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetAuthNoncePayloadOrError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["authMechanism"].(model.AuthMechanism), fc.Args["input"].(model.CreateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CreateUserPayloadOrError)
	fc.Result = res
	return ec.marshalOCreateUserPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐCreateUserPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateUserPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEmail(rctx, fc.Args["input"].(model.UpdateEmailInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEmailPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateEmailPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateEmailPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateEmailPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateEmailPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEmailPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEmail_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resendVerificationEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resendVerificationEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ResendVerificationEmail(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.ResendVerificationEmailPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.ResendVerificationEmailPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ResendVerificationEmailPayloadOrError)
	fc.Result = res
	return ec.marshalOResendVerificationEmailPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐResendVerificationEmailPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resendVerificationEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResendVerificationEmailPayloadOrError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEmailNotificationSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEmailNotificationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEmailNotificationSettings(rctx, fc.Args["input"].(model.UpdateEmailNotificationSettingsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEmailNotificationSettingsPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateEmailNotificationSettingsPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateEmailNotificationSettingsPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateEmailNotificationSettingsPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateEmailNotificationSettingsPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEmailNotificationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEmailNotificationSettingsPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEmailNotificationSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unsubscribeFromEmailType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unsubscribeFromEmailType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnsubscribeFromEmailType(rctx, fc.Args["input"].(model.UnsubscribeFromEmailTypeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UnsubscribeFromEmailTypePayloadOrError)
	fc.Result = res
	return ec.marshalOUnsubscribeFromEmailTypePayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUnsubscribeFromEmailTypePayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unsubscribeFromEmailType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UnsubscribeFromEmailTypePayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unsubscribeFromEmailType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_login(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Login(rctx, fc.Args["authMechanism"].(model.AuthMechanism))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.LoginPayloadOrError)
	fc.Result = res
	return ec.marshalOLoginPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐLoginPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LoginPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_login_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_logout(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_logout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Logout(rctx, fc.Args["pushTokenToUnregister"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LogoutPayload)
	fc.Result = res
	return ec.marshalOLogoutPayload2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐLogoutPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_logout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "viewer":
				return ec.fieldContext_LogoutPayload_viewer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogoutPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_logout_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_viewSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_viewSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ViewSplit(rctx, fc.Args["splitId"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ViewSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOViewSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_viewSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ViewSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_viewSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplit(rctx, fc.Args["input"].(model.UpdateSplitInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_publishSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_publishSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PublishSplit(rctx, fc.Args["input"].(model.PublishSplitInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.PublishSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.PublishSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.PublishSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOPublishSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPublishSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_publishSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PublishSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_publishSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateSplit(rctx, fc.Args["input"].(model.CreateSplitInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.CreateSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CreateSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOCreateSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐCreateSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplitHidden(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplitHidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplitHidden(rctx, fc.Args["input"].(model.UpdateSplitHiddenInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitHiddenPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitHiddenPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitHiddenPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitHiddenPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitHiddenPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplitHidden(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitHiddenPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplitHidden_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSplit(rctx, fc.Args["splitId"].(persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.DeleteSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.DeleteSplitPayloadOrError)
	fc.Result = res
	return ec.marshalODeleteSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐDeleteSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplitOrder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplitOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplitOrder(rctx, fc.Args["input"].(model.UpdateSplitOrderInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitOrderPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitOrderPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitOrderPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitOrderPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitOrderPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplitOrder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitOrderPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplitOrder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplitInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplitInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplitInfo(rctx, fc.Args["input"].(model.UpdateSplitInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitInfoPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitInfoPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitInfoPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitInfoPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitInfoPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplitInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitInfoPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplitInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_clearAllNotifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_clearAllNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ClearAllNotifications(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ClearAllNotificationsPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.ClearAllNotificationsPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ClearAllNotificationsPayload)
	fc.Result = res
	return ec.marshalOClearAllNotificationsPayload2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐClearAllNotificationsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_clearAllNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "notifications":
				return ec.fieldContext_ClearAllNotificationsPayload_notifications(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClearAllNotificationsPayload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateNotificationSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateNotificationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateNotificationSettings(rctx, fc.Args["settings"].(*model.NotificationSettingsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NotificationSettings)
	fc.Result = res
	return ec.marshalONotificationSettings2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateNotificationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "someoneFollowedYou":
				return ec.fieldContext_NotificationSettings_someoneFollowedYou(ctx, field)
			case "someoneViewedYourSplit":
				return ec.fieldContext_NotificationSettings_someoneViewedYourSplit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateNotificationSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_preverifyEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_preverifyEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PreverifyEmail(rctx, fc.Args["input"].(model.PreverifyEmailInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.PreverifyEmailPayloadOrError)
	fc.Result = res
	return ec.marshalOPreverifyEmailPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreverifyEmailPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_preverifyEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PreverifyEmailPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_preverifyEmail_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_verifyEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_verifyEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VerifyEmail(rctx, fc.Args["input"].(model.VerifyEmailInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.VerifyEmailPayloadOrError)
	fc.Result = res
	return ec.marshalOVerifyEmailPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVerifyEmailPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_verifyEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VerifyEmailPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_verifyEmail_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_verifyEmailMagicLink(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_verifyEmailMagicLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VerifyEmailMagicLink(rctx, fc.Args["input"].(model.VerifyEmailMagicLinkInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.VerifyEmailMagicLinkPayloadOrError)
	fc.Result = res
	return ec.marshalOVerifyEmailMagicLinkPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVerifyEmailMagicLinkPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_verifyEmailMagicLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VerifyEmailMagicLinkPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_verifyEmailMagicLink_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_optInForRoles(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_optInForRoles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().OptInForRoles(rctx, fc.Args["roles"].([]persist.Role))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.OptInForRolesPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.OptInForRolesPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.OptInForRolesPayloadOrError)
	fc.Result = res
	return ec.marshalOOptInForRolesPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐOptInForRolesPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_optInForRoles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OptInForRolesPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_optInForRoles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_optOutForRoles(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_optOutForRoles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().OptOutForRoles(rctx, fc.Args["roles"].([]persist.Role))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.OptOutForRolesPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.OptOutForRolesPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.OptOutForRolesPayloadOrError)
	fc.Result = res
	return ec.marshalOOptOutForRolesPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐOptOutForRolesPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_optOutForRoles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OptOutForRolesPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_optOutForRoles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addRolesToUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addRolesToUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddRolesToUser(rctx, fc.Args["username"].(string), fc.Args["roles"].([]*persist.Role))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			allowed, err := ec.unmarshalNBasicAuthType2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenTypeᚄ(ctx, []interface{}{"Retool"})
			if err != nil {
				return nil, err
			}
			if ec.directives.BasicAuth == nil {
				return nil, errors.New("directive basicAuth is not implemented")
			}
			return ec.directives.BasicAuth(ctx, nil, directive0, allowed)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.AddRolesToUserPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.AddRolesToUserPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.AddRolesToUserPayloadOrError)
	fc.Result = res
	return ec.marshalOAddRolesToUserPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAddRolesToUserPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addRolesToUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AddRolesToUserPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addRolesToUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addWalletToUserUnchecked(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addWalletToUserUnchecked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddWalletToUserUnchecked(rctx, fc.Args["input"].(model.AdminAddWalletInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			allowed, err := ec.unmarshalNBasicAuthType2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenTypeᚄ(ctx, []interface{}{"Retool"})
			if err != nil {
				return nil, err
			}
			if ec.directives.BasicAuth == nil {
				return nil, errors.New("directive basicAuth is not implemented")
			}
			return ec.directives.BasicAuth(ctx, nil, directive0, allowed)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.AdminAddWalletPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.AdminAddWalletPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.AdminAddWalletPayloadOrError)
	fc.Result = res
	return ec.marshalOAdminAddWalletPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAdminAddWalletPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addWalletToUserUnchecked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminAddWalletPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addWalletToUserUnchecked_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeRolesFromUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeRolesFromUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RevokeRolesFromUser(rctx, fc.Args["username"].(string), fc.Args["roles"].([]*persist.Role))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			allowed, err := ec.unmarshalNBasicAuthType2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenTypeᚄ(ctx, []interface{}{"Retool"})
			if err != nil {
				return nil, err
			}
			if ec.directives.BasicAuth == nil {
				return nil, errors.New("directive basicAuth is not implemented")
			}
			return ec.directives.BasicAuth(ctx, nil, directive0, allowed)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.RevokeRolesFromUserPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.RevokeRolesFromUserPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.RevokeRolesFromUserPayloadOrError)
	fc.Result = res
	return ec.marshalORevokeRolesFromUserPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRevokeRolesFromUserPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeRolesFromUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RevokeRolesFromUserPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeRolesFromUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadPersistedQueries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_uploadPersistedQueries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UploadPersistedQueries(rctx, fc.Args["input"].(*model.UploadPersistedQueriesInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.FrontendBuildAuth == nil {
				return nil, errors.New("directive frontendBuildAuth is not implemented")
			}
			return ec.directives.FrontendBuildAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UploadPersistedQueriesPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UploadPersistedQueriesPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UploadPersistedQueriesPayloadOrError)
	fc.Result = res
	return ec.marshalOUploadPersistedQueriesPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUploadPersistedQueriesPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_uploadPersistedQueries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UploadPersistedQueriesPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadPersistedQueries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePrimaryWallet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePrimaryWallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdatePrimaryWallet(rctx, fc.Args["walletID"].(persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdatePrimaryWalletPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdatePrimaryWalletPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdatePrimaryWalletPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdatePrimaryWalletPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdatePrimaryWalletPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePrimaryWallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdatePrimaryWalletPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePrimaryWallet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserExperience(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserExperience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUserExperience(rctx, fc.Args["input"].(model.UpdateUserExperienceInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateUserExperiencePayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateUserExperiencePayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateUserExperiencePayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateUserExperiencePayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateUserExperiencePayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserExperience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateUserExperiencePayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserExperience_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NotificationEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.NotificationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Notification)
	fc.Result = res
	return ec.marshalONotification2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.NotificationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationSettings_someoneFollowedYou(ctx context.Context, field graphql.CollectedField, obj *model.NotificationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationSettings_someoneFollowedYou(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SomeoneFollowedYou, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationSettings_someoneFollowedYou(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationSettings_someoneViewedYourSplit(ctx context.Context, field graphql.CollectedField, obj *model.NotificationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationSettings_someoneViewedYourSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SomeoneViewedYourSplit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationSettings_someoneViewedYourSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationsConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.NotificationsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationsConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.NotificationEdge)
	fc.Result = res
	return ec.marshalONotificationEdge2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationsConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_NotificationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_NotificationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationsConnection_unseenCount(ctx context.Context, field graphql.CollectedField, obj *model.NotificationsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationsConnection_unseenCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnseenCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationsConnection_unseenCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationsConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.NotificationsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationsConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalOPageInfo2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationsConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OptInForRolesPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.OptInForRolesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OptInForRolesPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OptInForRolesPayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OptInForRolesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "splitsByChain":
				return ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OptOutForRolesPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.OptOutForRolesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OptOutForRolesPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OptOutForRolesPayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OptOutForRolesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "splitsByChain":
				return ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_total(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_size(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreverifyEmailPayload_email(ctx context.Context, field graphql.CollectedField, obj *model.PreverifyEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreverifyEmailPayload_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.Email)
	fc.Result = res
	return ec.marshalNEmail2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreverifyEmailPayload_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreverifyEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Email does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreverifyEmailPayload_result(ctx context.Context, field graphql.CollectedField, obj *model.PreverifyEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreverifyEmailPayload_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PreverifyEmailResult)
	fc.Result = res
	return ec.marshalNPreverifyEmailResult2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreverifyEmailResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreverifyEmailPayload_result(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreverifyEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PreverifyEmailResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_raw(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_thumbnail(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Thumbnail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_thumbnail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_small(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_small(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Small, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_small(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_medium(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_medium(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Medium, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_medium(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_large(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_large(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Large, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_large(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_srcSet(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SrcSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_srcSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_liveRender(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveRender, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_liveRender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_blurhash(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.PreviewURLSet().Blurhash(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Experimental == nil {
				return nil, errors.New("directive experimental is not implemented")
			}
			return ec.directives.Experimental(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_blurhash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublishSplitPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.PublishSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublishSplitPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublishSplitPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublishSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(model.GqlID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Node)
	fc.Result = res
	return ec.marshalONode2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Viewer(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.ViewerOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.ViewerOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ViewerOrError)
	fc.Result = res
	return ec.marshalOViewerOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewerOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ViewerOrError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userByUsername(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userByUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserByUsername(rctx, fc.Args["username"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UserByUsernameOrError)
	fc.Result = res
	return ec.marshalOUserByUsernameOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserByUsernameOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userByUsername(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserByUsernameOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userByUsername_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserByID(rctx, fc.Args["id"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UserByIDOrError)
	fc.Result = res
	return ec.marshalOUserByIdOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserByIDOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserByIdOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserByAddress(rctx, fc.Args["chainAddress"].(persist.ChainAddress))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UserByAddressOrError)
	fc.Result = res
	return ec.marshalOUserByAddressOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserByAddressOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserByAddressOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_usersWithTrait(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_usersWithTrait(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UsersWithTrait(rctx, fc.Args["trait"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_usersWithTrait(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "splitsByChain":
				return ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_usersWithTrait_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_splitById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_splitById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SplitByID(rctx, fc.Args["id"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SplitByIDPayloadOrError)
	fc.Result = res
	return ec.marshalOSplitByIdPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitByIDPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_splitById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SplitByIdPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_splitById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewerSplitById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewerSplitById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ViewerSplitByID(rctx, fc.Args["id"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ViewerSplitByIDPayloadOrError)
	fc.Result = res
	return ec.marshalOViewerSplitByIdPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewerSplitByIDPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewerSplitById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ViewerSplitByIdPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_viewerSplitById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchUsers(rctx, fc.Args["query"].(string), fc.Args["limit"].(*int), fc.Args["usernameWeight"].(*float64), fc.Args["bioWeight"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SearchUsersPayloadOrError)
	fc.Result = res
	return ec.marshalOSearchUsersPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSearchUsersPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchUsersPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchSplits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchSplits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchSplits(rctx, fc.Args["query"].(string), fc.Args["limit"].(*int), fc.Args["nameWeight"].(*float64), fc.Args["descriptionWeight"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SearchSplitsPayloadOrError)
	fc.Result = res
	return ec.marshalOSearchSplitsPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSearchSplitsPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchSplits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchSplitsPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchSplits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_usersByRole(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_usersByRole(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().UsersByRole(rctx, fc.Args["role"].(persist.Role), fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			allowed, err := ec.unmarshalNBasicAuthType2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenTypeᚄ(ctx, []interface{}{"Retool"})
			if err != nil {
				return nil, err
			}
			if ec.directives.BasicAuth == nil {
				return nil, errors.New("directive basicAuth is not implemented")
			}
			return ec.directives.BasicAuth(ctx, nil, directive0, allowed)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UsersConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.UsersConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UsersConnection)
	fc.Result = res
	return ec.marshalOUsersConnection2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUsersConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_usersByRole(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UsersConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UsersConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UsersConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_usersByRole_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve__service(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(fedruntime.Service)
	fc.Result = res
	return ec.marshalN_Service2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sdl":
				return ec.fieldContext__Service_sdl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Recipient_id(ctx context.Context, field graphql.CollectedField, obj *model.Recipient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Recipient_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Recipient_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Recipient",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Recipient_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Recipient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Recipient_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Recipient_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Recipient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Recipient_version(ctx context.Context, field graphql.CollectedField, obj *model.Recipient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Recipient_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Recipient_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Recipient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Recipient_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.Recipient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Recipient_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Recipient_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Recipient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Recipient_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.Recipient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Recipient_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Recipient_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Recipient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Recipient_address(ctx context.Context, field graphql.CollectedField, obj *model.Recipient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Recipient_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Address)
	fc.Result = res
	return ec.marshalOAddress2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Recipient_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Recipient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Recipient_split(ctx context.Context, field graphql.CollectedField, obj *model.Recipient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Recipient_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Recipient().Split(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Recipient_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Recipient",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Recipient_ownership(ctx context.Context, field graphql.CollectedField, obj *model.Recipient) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Recipient_ownership(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ownership, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Recipient_ownership(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Recipient",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegisterUserPushTokenPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.RegisterUserPushTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegisterUserPushTokenPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegisterUserPushTokenPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegisterUserPushTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveUserWalletsPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.RemoveUserWalletsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveUserWalletsPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveUserWalletsPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveUserWalletsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResendVerificationEmailPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.ResendVerificationEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResendVerificationEmailPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResendVerificationEmailPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResendVerificationEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchSplitsPayload_results(ctx context.Context, field graphql.CollectedField, obj *model.SearchSplitsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchSplitsPayload_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SplitSearchResult)
	fc.Result = res
	return ec.marshalOSplitSearchResult2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitSearchResultᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchSplitsPayload_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchSplitsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "split":
				return ec.fieldContext_SplitSearchResult_split(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitSearchResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchUsersPayload_results(ctx context.Context, field graphql.CollectedField, obj *model.SearchUsersPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchUsersPayload_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.UserSearchResult)
	fc.Result = res
	return ec.marshalOUserSearchResult2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserSearchResultᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchUsersPayload_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchUsersPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserSearchResult_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSearchResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_id(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_version(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_name(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_description(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_chain(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_logoURL(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_logoURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_logoURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_bannerURL(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_bannerURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BannerURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_bannerURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_badgeURL(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_badgeURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BadgeURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_badgeURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_assets(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_assets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Split().Assets(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Asset)
	fc.Result = res
	return ec.marshalOAsset2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAsset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_assets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Asset_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Asset_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Asset_version(ctx, field)
			case "ownerAddress":
				return ec.fieldContext_Asset_ownerAddress(ctx, field)
			case "balance":
				return ec.fieldContext_Asset_balance(ctx, field)
			case "token":
				return ec.fieldContext_Asset_token(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Asset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Split_assets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Split_shares(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_shares(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Split().Shares(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Recipient)
	fc.Result = res
	return ec.marshalORecipient2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRecipient(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_shares(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Recipient_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Recipient_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Recipient_version(ctx, field)
			case "creationTime":
				return ec.fieldContext_Recipient_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Recipient_lastUpdated(ctx, field)
			case "address":
				return ec.fieldContext_Recipient_address(ctx, field)
			case "split":
				return ec.fieldContext_Recipient_split(ctx, field)
			case "ownership":
				return ec.fieldContext_Recipient_ownership(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Recipient", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Split_shares_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_id(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_dbid(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_username(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_bio(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_bio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_bio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_traits(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_traits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Traits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_traits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_universal(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_universal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Universal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_universal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_roles(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Roles(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*persist.Role)
	fc.Result = res
	return ec.marshalORole2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_roles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Role does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_wallets(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_wallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Wallets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Wallet)
	fc.Result = res
	return ec.marshalOWallet2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_wallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Wallet_dbid(ctx, field)
			case "chainAddress":
				return ec.fieldContext_Wallet_chainAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Wallet_chain(ctx, field)
			case "walletType":
				return ec.fieldContext_Wallet_walletType(ctx, field)
			case "splits":
				return ec.fieldContext_Wallet_splits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_primaryWallet(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().PrimaryWallet(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Wallet)
	fc.Result = res
	return ec.marshalOWallet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_primaryWallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Wallet_dbid(ctx, field)
			case "chainAddress":
				return ec.fieldContext_Wallet_chainAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Wallet_chain(ctx, field)
			case "walletType":
				return ec.fieldContext_Wallet_walletType(ctx, field)
			case "splits":
				return ec.fieldContext_Wallet_splits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_splits(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_splits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Splits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_splits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_splitsByChain(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().SplitsByChain(rctx, obj, fc.Args["chain"].(persist.Chain))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChainSplits)
	fc.Result = res
	return ec.marshalOChainSplits2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐChainSplits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_splitsByChain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chain":
				return ec.fieldContext_ChainSplits_chain(ctx, field)
			case "splits":
				return ec.fieldContext_ChainSplits_splits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainSplits", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SplitFiUser_splitsByChain_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_isAuthenticatedUser(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAuthenticatedUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_isAuthenticatedUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitSearchResult_split(ctx context.Context, field graphql.CollectedField, obj *model.SplitSearchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitSearchResult_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitSearchResult_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitSearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_newNotification(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_newNotification(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().NewNotification(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan model.Notification):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalONotification2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotification(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_newNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_notificationUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_notificationUpdated(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().NotificationUpdated(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan model.Notification):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalONotification2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotification(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_notificationUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_id(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_version(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_tokenType(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_tokenType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TokenType)
	fc.Result = res
	return ec.marshalOTokenType2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐTokenType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_tokenType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TokenType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_chain(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_name(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_symbol(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_symbol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_symbol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_decimals(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_decimals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Decimals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_decimals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_logo(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_logo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_logo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_totalSupply(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_totalSupply(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSupply, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_totalSupply(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_contractAddress(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_contractAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContractAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_contractAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_blockNumber(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_blockNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_blockNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_isSpam(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_isSpam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSpam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_isSpam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnregisterUserPushTokenPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UnregisterUserPushTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnregisterUserPushTokenPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnregisterUserPushTokenPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnregisterUserPushTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnsubscribeFromEmailTypePayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UnsubscribeFromEmailTypePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnsubscribeFromEmailTypePayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnsubscribeFromEmailTypePayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnsubscribeFromEmailTypePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEmailNotificationSettingsPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateEmailNotificationSettingsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEmailNotificationSettingsPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEmailNotificationSettingsPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEmailNotificationSettingsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEmailPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEmailPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEmailPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdatePrimaryWalletPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdatePrimaryWalletPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdatePrimaryWalletPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdatePrimaryWalletPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdatePrimaryWalletPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitHiddenPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitHiddenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitHiddenPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitHiddenPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitHiddenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitInfoPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitInfoPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitInfoPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitInfoPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitInfoPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitOrderPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitOrderPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitOrderPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitOrderPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitOrderPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateUserExperiencePayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateUserExperiencePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateUserExperiencePayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateUserExperiencePayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateUserExperiencePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateUserInfoPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateUserInfoPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateUserInfoPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateUserInfoPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateUserInfoPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadPersistedQueriesPayload_message(ctx context.Context, field graphql.CollectedField, obj *model.UploadPersistedQueriesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UploadPersistedQueriesPayload_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UploadPersistedQueriesPayload_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadPersistedQueriesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "splitsByChain":
				return ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEmail_email(ctx context.Context, field graphql.CollectedField, obj *model.UserEmail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEmail_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Email)
	fc.Result = res
	return ec.marshalOEmail2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEmail_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEmail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Email does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEmail_verificationStatus(ctx context.Context, field graphql.CollectedField, obj *model.UserEmail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEmail_verificationStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VerificationStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.EmailVerificationStatus)
	fc.Result = res
	return ec.marshalOEmailVerificationStatus2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmailVerificationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEmail_verificationStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEmail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EmailVerificationStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEmail_emailNotificationSettings(ctx context.Context, field graphql.CollectedField, obj *model.UserEmail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEmail_emailNotificationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserEmail().EmailNotificationSettings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.EmailNotificationSettings)
	fc.Result = res
	return ec.marshalOEmailNotificationSettings2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐEmailNotificationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEmail_emailNotificationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEmail",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unsubscribedFromAll":
				return ec.fieldContext_EmailNotificationSettings_unsubscribedFromAll(ctx, field)
			case "unsubscribedFromNotifications":
				return ec.fieldContext_EmailNotificationSettings_unsubscribedFromNotifications(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EmailNotificationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserExperience_type(ctx context.Context, field graphql.CollectedField, obj *model.UserExperience) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserExperience_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UserExperienceType)
	fc.Result = res
	return ec.marshalNUserExperienceType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserExperienceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserExperience_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserExperience",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserExperienceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserExperience_experienced(ctx context.Context, field graphql.CollectedField, obj *model.UserExperience) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserExperience_experienced(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experienced, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserExperience_experienced(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserExperience",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSearchResult_user(ctx context.Context, field graphql.CollectedField, obj *model.UserSearchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSearchResult_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSearchResult_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "splitsByChain":
				return ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UsersConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.UsersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UsersConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.UserEdge)
	fc.Result = res
	return ec.marshalOUserEdge2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UsersConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UsersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_UserEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_UserEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UsersConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.UsersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UsersConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UsersConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UsersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VerifyEmailMagicLinkPayload_canSend(ctx context.Context, field graphql.CollectedField, obj *model.VerifyEmailMagicLinkPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VerifyEmailMagicLinkPayload_canSend(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanSend, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VerifyEmailMagicLinkPayload_canSend(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VerifyEmailMagicLinkPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VerifyEmailPayload_email(ctx context.Context, field graphql.CollectedField, obj *model.VerifyEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VerifyEmailPayload_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.Email)
	fc.Result = res
	return ec.marshalNEmail2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VerifyEmailPayload_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VerifyEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Email does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_contentRenderURLs(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_contentRenderURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.VideoURLSet)
	fc.Result = res
	return ec.marshalOVideoURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVideoURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_contentRenderURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_VideoURLSet_raw(ctx, field)
			case "small":
				return ec.fieldContext_VideoURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_VideoURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_VideoURLSet_large(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VideoURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoURLSet_raw(ctx context.Context, field graphql.CollectedField, obj *model.VideoURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoURLSet_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoURLSet_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoURLSet_small(ctx context.Context, field graphql.CollectedField, obj *model.VideoURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoURLSet_small(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Small, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoURLSet_small(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoURLSet_medium(ctx context.Context, field graphql.CollectedField, obj *model.VideoURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoURLSet_medium(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Medium, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoURLSet_medium(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoURLSet_large(ctx context.Context, field graphql.CollectedField, obj *model.VideoURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoURLSet_large(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Large, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoURLSet_large(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ViewSplitPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.ViewSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ViewSplitPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ViewSplitPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ViewSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_id(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_user(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "splitsByChain":
				return ec.fieldContext_SplitFiUser_splitsByChain(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_viewerSplits(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_viewerSplits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().ViewerSplits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ViewerSplit)
	fc.Result = res
	return ec.marshalOViewerSplit2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewerSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_viewerSplits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "split":
				return ec.fieldContext_ViewerSplit_split(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ViewerSplit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_email(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().Email(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserEmail)
	fc.Result = res
	return ec.marshalOUserEmail2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "email":
				return ec.fieldContext_UserEmail_email(ctx, field)
			case "verificationStatus":
				return ec.fieldContext_UserEmail_verificationStatus(ctx, field)
			case "emailNotificationSettings":
				return ec.fieldContext_UserEmail_emailNotificationSettings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEmail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_notifications(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().Notifications(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NotificationsConnection)
	fc.Result = res
	return ec.marshalONotificationsConnection2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationsConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_notifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_NotificationsConnection_edges(ctx, field)
			case "unseenCount":
				return ec.fieldContext_NotificationsConnection_unseenCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_NotificationsConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationsConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Viewer_notifications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_notificationSettings(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_notificationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().NotificationSettings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NotificationSettings)
	fc.Result = res
	return ec.marshalONotificationSettings2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_notificationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "someoneFollowedYou":
				return ec.fieldContext_NotificationSettings_someoneFollowedYou(ctx, field)
			case "someoneViewedYourSplit":
				return ec.fieldContext_NotificationSettings_someoneViewedYourSplit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_userExperiences(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_userExperiences(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().UserExperiences(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.UserExperience)
	fc.Result = res
	return ec.marshalOUserExperience2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserExperienceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_userExperiences(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_UserExperience_type(ctx, field)
			case "experienced":
				return ec.fieldContext_UserExperience_experienced(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserExperience", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ViewerSplit_split(ctx context.Context, field graphql.CollectedField, obj *model.ViewerSplit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ViewerSplit_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ViewerSplit_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ViewerSplit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_id(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_chainAddress(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_chainAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChainAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_chainAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_chain(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_walletType(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_walletType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WalletType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.WalletType)
	fc.Result = res
	return ec.marshalOWalletType2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐWalletType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_walletType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WalletType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_splits(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_splits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Wallet().Splits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Split)
	fc.Result = res
	return ec.marshalOSplit2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_splits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Split_version(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "chain":
				return ec.fieldContext_Split_chain(ctx, field)
			case "logoURL":
				return ec.fieldContext_Split_logoURL(ctx, field)
			case "bannerURL":
				return ec.fieldContext_Split_bannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Split_badgeURL(ctx, field)
			case "assets":
				return ec.fieldContext_Split_assets(ctx, field)
			case "shares":
				return ec.fieldContext_Split_shares(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext__Service_sdl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext__Service_sdl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_Service",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAdminAddWalletInput(ctx context.Context, obj interface{}) (model.AdminAddWalletInput, error) {
	var it model.AdminAddWalletInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "chainAddress", "walletType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "chainAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddress"))
			data, err := ec.unmarshalNChainAddressInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainAddress = data
		case "walletType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("walletType"))
			data, err := ec.unmarshalNWalletType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐWalletType(ctx, v)
			if err != nil {
				return it, err
			}
			it.WalletType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthMechanism(ctx context.Context, obj interface{}) (model.AuthMechanism, error) {
	var it model.AuthMechanism
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eoa", "gnosisSafe", "debug", "magicLink", "oneTimeLoginToken", "privy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eoa":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eoa"))
			data, err := ec.unmarshalOEoaAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐEoaAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eoa = data
		case "gnosisSafe":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gnosisSafe"))
			data, err := ec.unmarshalOGnosisSafeAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGnosisSafeAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.GnosisSafe = data
		case "debug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("debug"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalODebugAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐDebugAuth(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"local", "development", "sandbox"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.DebugAuth); ok {
				it.Debug = data
			} else if tmp == nil {
				it.Debug = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.DebugAuth`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "magicLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("magicLink"))
			data, err := ec.unmarshalOMagicLinkAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMagicLinkAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.MagicLink = data
		case "oneTimeLoginToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oneTimeLoginToken"))
			data, err := ec.unmarshalOOneTimeLoginTokenAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐOneTimeLoginTokenAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.OneTimeLoginToken = data
		case "privy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privy"))
			data, err := ec.unmarshalOPrivyAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPrivyAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.Privy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChainAddressInput(ctx context.Context, obj interface{}) (persist.ChainAddress, error) {
	var it persist.ChainAddress
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"address", "chain"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			data, err := ec.unmarshalNAddress2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ChainAddressInput().Address(ctx, &it, data); err != nil {
				return it, err
			}
		case "chain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
			data, err := ec.unmarshalNChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ChainAddressInput().Chain(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChainPubKeyInput(ctx context.Context, obj interface{}) (persist.ChainPubKey, error) {
	var it persist.ChainPubKey
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pubKey", "chain"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pubKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pubKey"))
			data, err := ec.unmarshalNPubKey2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐPubKey(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ChainPubKeyInput().PubKey(ctx, &it, data); err != nil {
				return it, err
			}
		case "chain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
			data, err := ec.unmarshalNChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ChainPubKeyInput().Chain(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSplitInput(ctx context.Context, obj interface{}) (model.CreateSplitInput, error) {
	var it model.CreateSplitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "logo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "logo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logo"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Logo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (model.CreateUserInput, error) {
	var it model.CreateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "bio", "email", "splitName", "splitDescription", "splitPosition"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "bio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOEmail2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "splitName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitName = data
		case "splitDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitDescription"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitDescription = data
		case "splitPosition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitPosition"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitPosition = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDebugAuth(ctx context.Context, obj interface{}) (model.DebugAuth, error) {
	var it model.DebugAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"asUsername", "userId", "chainAddresses", "debugToolsPassword"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "asUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asUsername"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"local", "development", "sandbox"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.AsUsername = data
			} else if tmp == nil {
				it.AsUsername = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalODBID2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"local", "development", "sandbox"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*persist.DBID); ok {
				it.UserID = data
			} else if tmp == nil {
				it.UserID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/service/persist.DBID`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "chainAddresses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddresses"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOChainAddressInput2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddressᚄ(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"local", "development", "sandbox"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*persist.ChainAddress); ok {
				it.ChainAddresses = data
			} else if tmp == nil {
				it.ChainAddresses = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/SplitFi/go-splitfi/service/persist.ChainAddress`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "debugToolsPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("debugToolsPassword"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"local", "development", "sandbox"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.DebugToolsPassword = data
			} else if tmp == nil {
				it.DebugToolsPassword = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEoaAuth(ctx context.Context, obj interface{}) (model.EoaAuth, error) {
	var it model.EoaAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"chainPubKey", "nonce", "message", "signature"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "chainPubKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainPubKey"))
			data, err := ec.unmarshalNChainPubKeyInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainPubKey(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainPubKey = data
		case "nonce":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nonce = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "signature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signature"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Signature = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGnosisSafeAuth(ctx context.Context, obj interface{}) (model.GnosisSafeAuth, error) {
	var it model.GnosisSafeAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"address", "nonce", "message"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			data, err := ec.unmarshalNAddress2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx, v)
			if err != nil {
				return it, err
			}
			it.Address = data
		case "nonce":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nonce = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMagicLinkAuth(ctx context.Context, obj interface{}) (model.MagicLinkAuth, error) {
	var it model.MagicLinkAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"token"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationSettingsInput(ctx context.Context, obj interface{}) (model.NotificationSettingsInput, error) {
	var it model.NotificationSettingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"someoneFollowedYou", "someoneViewedYourSplit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "someoneFollowedYou":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("someoneFollowedYou"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SomeoneFollowedYou = data
		case "someoneViewedYourSplit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("someoneViewedYourSplit"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SomeoneViewedYourSplit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOneTimeLoginTokenAuth(ctx context.Context, obj interface{}) (model.OneTimeLoginTokenAuth, error) {
	var it model.OneTimeLoginTokenAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"token"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPreverifyEmailInput(ctx context.Context, obj interface{}) (model.PreverifyEmailInput, error) {
	var it model.PreverifyEmailInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNEmail2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPrivyAuth(ctx context.Context, obj interface{}) (model.PrivyAuth, error) {
	var it model.PrivyAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"token"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublishSplitInput(ctx context.Context, obj interface{}) (model.PublishSplitInput, error) {
	var it model.PublishSplitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "editId", "caption"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "editId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("editId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EditID = data
		case "caption":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caption"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caption = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSplitPositionInput(ctx context.Context, obj interface{}) (model.SplitPositionInput, error) {
	var it model.SplitPositionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "position"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSplitShareInput(ctx context.Context, obj interface{}) (model.SplitShareInput, error) {
	var it model.SplitShareInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "recipientAddress", "ownership"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "recipientAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("recipientAddress"))
			data, err := ec.unmarshalNAddress2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx, v)
			if err != nil {
				return it, err
			}
			it.RecipientAddress = data
		case "ownership":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ownership"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ownership = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnsubscribeFromEmailTypeInput(ctx context.Context, obj interface{}) (model.UnsubscribeFromEmailTypeInput, error) {
	var it model.UnsubscribeFromEmailTypeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "token"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNEmailUnsubscriptionType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐEmailUnsubscriptionType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEmailInput(ctx context.Context, obj interface{}) (model.UpdateEmailInput, error) {
	var it model.UpdateEmailInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email", "authMechanism"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNEmail2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "authMechanism":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMechanism"))
			data, err := ec.unmarshalOAuthMechanism2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAuthMechanism(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthMechanism = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEmailNotificationSettingsInput(ctx context.Context, obj interface{}) (model.UpdateEmailNotificationSettingsInput, error) {
	var it model.UpdateEmailNotificationSettingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unsubscribedFromAll", "unsubscribedFromNotifications"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unsubscribedFromAll":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unsubscribedFromAll"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnsubscribedFromAll = data
		case "unsubscribedFromNotifications":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unsubscribedFromNotifications"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnsubscribedFromNotifications = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitHiddenInput(ctx context.Context, obj interface{}) (model.UpdateSplitHiddenInput, error) {
	var it model.UpdateSplitHiddenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "hidden"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "hidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitInfoInput(ctx context.Context, obj interface{}) (model.UpdateSplitInfoInput, error) {
	var it model.UpdateSplitInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitInput(ctx context.Context, obj interface{}) (model.UpdateSplitInput, error) {
	var it model.UpdateSplitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "name", "description", "caption", "deletedCollections", "order", "editId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "caption":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caption"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caption = data
		case "deletedCollections":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedCollections"))
			data, err := ec.unmarshalODBID2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedCollections = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalODBID2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBIDᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "editId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("editId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EditID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitOrderInput(ctx context.Context, obj interface{}) (model.UpdateSplitOrderInput, error) {
	var it model.UpdateSplitOrderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"positions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "positions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positions"))
			data, err := ec.unmarshalNSplitPositionInput2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitPositionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Positions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserExperienceInput(ctx context.Context, obj interface{}) (model.UpdateUserExperienceInput, error) {
	var it model.UpdateUserExperienceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"experienceType", "experienced"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "experienceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("experienceType"))
			data, err := ec.unmarshalNUserExperienceType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserExperienceType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExperienceType = data
		case "experienced":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("experienced"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Experienced = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserInfoInput(ctx context.Context, obj interface{}) (model.UpdateUserInfoInput, error) {
	var it model.UpdateUserInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "bio"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "bio":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUploadPersistedQueriesInput(ctx context.Context, obj interface{}) (model.UploadPersistedQueriesInput, error) {
	var it model.UploadPersistedQueriesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"persistedQueries"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "persistedQueries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("persistedQueries"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersistedQueries = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVerifyEmailInput(ctx context.Context, obj interface{}) (model.VerifyEmailInput, error) {
	var it model.VerifyEmailInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"token"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVerifyEmailMagicLinkInput(ctx context.Context, obj interface{}) (model.VerifyEmailMagicLinkInput, error) {
	var it model.VerifyEmailMagicLinkInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNEmail2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _AddRolesToUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.AddRolesToUserPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AddUserWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.AddUserWalletPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrAddressOwnedByUser:
		return ec._ErrAddressOwnedByUser(ctx, sel, &obj)
	case *model.ErrAddressOwnedByUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAddressOwnedByUser(ctx, sel, obj)
	case model.AddUserWalletPayload:
		return ec._AddUserWalletPayload(ctx, sel, &obj)
	case *model.AddUserWalletPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._AddUserWalletPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AdminAddWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.AdminAddWalletPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrAddressOwnedByUser:
		return ec._ErrAddressOwnedByUser(ctx, sel, &obj)
	case *model.ErrAddressOwnedByUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAddressOwnedByUser(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.AdminAddWalletPayload:
		return ec._AdminAddWalletPayload(ctx, sel, &obj)
	case *model.AdminAddWalletPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._AdminAddWalletPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthorizationError(ctx context.Context, sel ast.SelectionSet, obj model.AuthorizationError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNoCookie:
		return ec._ErrNoCookie(ctx, sel, &obj)
	case *model.ErrNoCookie:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNoCookie(ctx, sel, obj)
	case model.ErrInvalidToken:
		return ec._ErrInvalidToken(ctx, sel, &obj)
	case *model.ErrInvalidToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidToken(ctx, sel, obj)
	case model.ErrSessionInvalidated:
		return ec._ErrSessionInvalidated(ctx, sel, &obj)
	case *model.ErrSessionInvalidated:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSessionInvalidated(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CreateSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.CreateSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.CreateSplitPayload:
		return ec._CreateSplitPayload(ctx, sel, &obj)
	case *model.CreateSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._CreateSplitPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CreateUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.CreateUserPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	case model.ErrUserAlreadyExists:
		return ec._ErrUserAlreadyExists(ctx, sel, &obj)
	case *model.ErrUserAlreadyExists:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserAlreadyExists(ctx, sel, obj)
	case model.ErrUsernameNotAvailable:
		return ec._ErrUsernameNotAvailable(ctx, sel, &obj)
	case *model.ErrUsernameNotAvailable:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUsernameNotAvailable(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.CreateUserPayload:
		return ec._CreateUserPayload(ctx, sel, &obj)
	case *model.CreateUserPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._CreateUserPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DeleteSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.DeleteSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.DeleteSplitPayload:
		return ec._DeleteSplitPayload(ctx, sel, &obj)
	case *model.DeleteSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeleteSplitPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Error(ctx context.Context, sel ast.SelectionSet, obj model.Error) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrTokenNotFound:
		return ec._ErrTokenNotFound(ctx, sel, &obj)
	case *model.ErrTokenNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrTokenNotFound(ctx, sel, obj)
	case model.ErrSplitNotFound:
		return ec._ErrSplitNotFound(ctx, sel, &obj)
	case *model.ErrSplitNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSplitNotFound(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrUserAlreadyExists:
		return ec._ErrUserAlreadyExists(ctx, sel, &obj)
	case *model.ErrUserAlreadyExists:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserAlreadyExists(ctx, sel, obj)
	case model.ErrUsernameNotAvailable:
		return ec._ErrUsernameNotAvailable(ctx, sel, &obj)
	case *model.ErrUsernameNotAvailable:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUsernameNotAvailable(ctx, sel, obj)
	case model.ErrAddressOwnedByUser:
		return ec._ErrAddressOwnedByUser(ctx, sel, &obj)
	case *model.ErrAddressOwnedByUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAddressOwnedByUser(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrCommunityNotFound:
		return ec._ErrCommunityNotFound(ctx, sel, &obj)
	case *model.ErrCommunityNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrCommunityNotFound(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNoCookie:
		return ec._ErrNoCookie(ctx, sel, &obj)
	case *model.ErrNoCookie:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNoCookie(ctx, sel, obj)
	case model.ErrInvalidToken:
		return ec._ErrInvalidToken(ctx, sel, &obj)
	case *model.ErrInvalidToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidToken(ctx, sel, obj)
	case model.ErrSessionInvalidated:
		return ec._ErrSessionInvalidated(ctx, sel, &obj)
	case *model.ErrSessionInvalidated:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSessionInvalidated(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	case model.ErrSyncFailed:
		return ec._ErrSyncFailed(ctx, sel, &obj)
	case *model.ErrSyncFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSyncFailed(ctx, sel, obj)
	case model.ErrPushTokenBelongsToAnotherUser:
		return ec._ErrPushTokenBelongsToAnotherUser(ctx, sel, &obj)
	case *model.ErrPushTokenBelongsToAnotherUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrPushTokenBelongsToAnotherUser(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _GetAuthNoncePayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.GetAuthNoncePayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.AuthNonce:
		return ec._AuthNonce(ctx, sel, &obj)
	case *model.AuthNonce:
		if obj == nil {
			return graphql.Null
		}
		return ec._AuthNonce(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _GroupedNotification(ctx context.Context, sel ast.SelectionSet, obj model.GroupedNotification) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _LoginPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.LoginPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	case model.LoginPayload:
		return ec._LoginPayload(ctx, sel, &obj)
	case *model.LoginPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoginPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Media(ctx context.Context, sel ast.SelectionSet, obj model.Media) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ImageMedia:
		return ec._ImageMedia(ctx, sel, &obj)
	case *model.ImageMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageMedia(ctx, sel, obj)
	case model.GIFMedia:
		return ec._GIFMedia(ctx, sel, &obj)
	case *model.GIFMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._GIFMedia(ctx, sel, obj)
	case model.VideoMedia:
		return ec._VideoMedia(ctx, sel, &obj)
	case *model.VideoMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._VideoMedia(ctx, sel, obj)
	case model.AudioMedia:
		return ec._AudioMedia(ctx, sel, &obj)
	case *model.AudioMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._AudioMedia(ctx, sel, obj)
	case model.TextMedia:
		return ec._TextMedia(ctx, sel, &obj)
	case *model.TextMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._TextMedia(ctx, sel, obj)
	case model.PDFMedia:
		return ec._PdfMedia(ctx, sel, &obj)
	case *model.PDFMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._PdfMedia(ctx, sel, obj)
	case model.HTMLMedia:
		return ec._HtmlMedia(ctx, sel, &obj)
	case *model.HTMLMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._HtmlMedia(ctx, sel, obj)
	case model.JSONMedia:
		return ec._JsonMedia(ctx, sel, &obj)
	case *model.JSONMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._JsonMedia(ctx, sel, obj)
	case model.GltfMedia:
		return ec._GltfMedia(ctx, sel, &obj)
	case *model.GltfMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._GltfMedia(ctx, sel, obj)
	case model.UnknownMedia:
		return ec._UnknownMedia(ctx, sel, &obj)
	case *model.UnknownMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnknownMedia(ctx, sel, obj)
	case model.InvalidMedia:
		return ec._InvalidMedia(ctx, sel, &obj)
	case *model.InvalidMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidMedia(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _MediaSubtype(ctx context.Context, sel ast.SelectionSet, obj model.MediaSubtype) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ImageMedia:
		return ec._ImageMedia(ctx, sel, &obj)
	case *model.ImageMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageMedia(ctx, sel, obj)
	case model.GIFMedia:
		return ec._GIFMedia(ctx, sel, &obj)
	case *model.GIFMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._GIFMedia(ctx, sel, obj)
	case model.VideoMedia:
		return ec._VideoMedia(ctx, sel, &obj)
	case *model.VideoMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._VideoMedia(ctx, sel, obj)
	case model.AudioMedia:
		return ec._AudioMedia(ctx, sel, &obj)
	case *model.AudioMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._AudioMedia(ctx, sel, obj)
	case model.TextMedia:
		return ec._TextMedia(ctx, sel, &obj)
	case *model.TextMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._TextMedia(ctx, sel, obj)
	case model.PDFMedia:
		return ec._PdfMedia(ctx, sel, &obj)
	case *model.PDFMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._PdfMedia(ctx, sel, obj)
	case model.HTMLMedia:
		return ec._HtmlMedia(ctx, sel, &obj)
	case *model.HTMLMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._HtmlMedia(ctx, sel, obj)
	case model.JSONMedia:
		return ec._JsonMedia(ctx, sel, &obj)
	case *model.JSONMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._JsonMedia(ctx, sel, obj)
	case model.GltfMedia:
		return ec._GltfMedia(ctx, sel, &obj)
	case *model.GltfMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._GltfMedia(ctx, sel, obj)
	case model.UnknownMedia:
		return ec._UnknownMedia(ctx, sel, &obj)
	case *model.UnknownMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnknownMedia(ctx, sel, obj)
	case model.InvalidMedia:
		return ec._InvalidMedia(ctx, sel, &obj)
	case *model.InvalidMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidMedia(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj model.Node) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.GroupedNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._GroupedNotification(ctx, sel, obj)
	case model.DeletedNode:
		return ec._DeletedNode(ctx, sel, &obj)
	case *model.DeletedNode:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeletedNode(ctx, sel, obj)
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.Wallet:
		return ec._Wallet(ctx, sel, &obj)
	case *model.Wallet:
		if obj == nil {
			return graphql.Null
		}
		return ec._Wallet(ctx, sel, obj)
	case model.Token:
		return ec._Token(ctx, sel, &obj)
	case *model.Token:
		if obj == nil {
			return graphql.Null
		}
		return ec._Token(ctx, sel, obj)
	case model.Asset:
		return ec._Asset(ctx, sel, &obj)
	case *model.Asset:
		if obj == nil {
			return graphql.Null
		}
		return ec._Asset(ctx, sel, obj)
	case model.Recipient:
		return ec._Recipient(ctx, sel, &obj)
	case *model.Recipient:
		if obj == nil {
			return graphql.Null
		}
		return ec._Recipient(ctx, sel, obj)
	case model.Split:
		return ec._Split(ctx, sel, &obj)
	case *model.Split:
		if obj == nil {
			return graphql.Null
		}
		return ec._Split(ctx, sel, obj)
	case model.Viewer:
		return ec._Viewer(ctx, sel, &obj)
	case *model.Viewer:
		if obj == nil {
			return graphql.Null
		}
		return ec._Viewer(ctx, sel, obj)
	case model.Notification:
		if obj == nil {
			return graphql.Null
		}
		return ec._Notification(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Notification(ctx context.Context, sel ast.SelectionSet, obj model.Notification) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.GroupedNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._GroupedNotification(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _OptInForRolesPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.OptInForRolesPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.OptInForRolesPayload:
		return ec._OptInForRolesPayload(ctx, sel, &obj)
	case *model.OptInForRolesPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._OptInForRolesPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _OptOutForRolesPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.OptOutForRolesPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.OptOutForRolesPayload:
		return ec._OptOutForRolesPayload(ctx, sel, &obj)
	case *model.OptOutForRolesPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._OptOutForRolesPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _PreverifyEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.PreverifyEmailPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.PreverifyEmailPayload:
		return ec._PreverifyEmailPayload(ctx, sel, &obj)
	case *model.PreverifyEmailPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._PreverifyEmailPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _PublishSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.PublishSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.PublishSplitPayload:
		return ec._PublishSplitPayload(ctx, sel, &obj)
	case *model.PublishSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._PublishSplitPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _RegisterUserPushTokenPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.RegisterUserPushTokenPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrPushTokenBelongsToAnotherUser:
		return ec._ErrPushTokenBelongsToAnotherUser(ctx, sel, &obj)
	case *model.ErrPushTokenBelongsToAnotherUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrPushTokenBelongsToAnotherUser(ctx, sel, obj)
	case model.RegisterUserPushTokenPayload:
		return ec._RegisterUserPushTokenPayload(ctx, sel, &obj)
	case *model.RegisterUserPushTokenPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._RegisterUserPushTokenPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _RemoveUserWalletsPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.RemoveUserWalletsPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.RemoveUserWalletsPayload:
		return ec._RemoveUserWalletsPayload(ctx, sel, &obj)
	case *model.RemoveUserWalletsPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._RemoveUserWalletsPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ResendVerificationEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.ResendVerificationEmailPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ResendVerificationEmailPayload:
		return ec._ResendVerificationEmailPayload(ctx, sel, &obj)
	case *model.ResendVerificationEmailPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._ResendVerificationEmailPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _RevokeRolesFromUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.RevokeRolesFromUserPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchSplitsPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SearchSplitsPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.SearchSplitsPayload:
		return ec._SearchSplitsPayload(ctx, sel, &obj)
	case *model.SearchSplitsPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._SearchSplitsPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchUsersPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SearchUsersPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.SearchUsersPayload:
		return ec._SearchUsersPayload(ctx, sel, &obj)
	case *model.SearchUsersPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._SearchUsersPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SplitByIdPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SplitByIDPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Split:
		return ec._Split(ctx, sel, &obj)
	case *model.Split:
		if obj == nil {
			return graphql.Null
		}
		return ec._Split(ctx, sel, obj)
	case model.ErrSplitNotFound:
		return ec._ErrSplitNotFound(ctx, sel, &obj)
	case *model.ErrSplitNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSplitNotFound(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SplitFiUserOrAddress(ctx context.Context, sel ast.SelectionSet, obj model.SplitFiUserOrAddress) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case *persist.ChainAddress:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChainAddress(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SplitFiUserOrWallet(ctx context.Context, sel ast.SelectionSet, obj model.SplitFiUserOrWallet) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.Wallet:
		return ec._Wallet(ctx, sel, &obj)
	case *model.Wallet:
		if obj == nil {
			return graphql.Null
		}
		return ec._Wallet(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UnregisterUserPushTokenPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UnregisterUserPushTokenPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrPushTokenBelongsToAnotherUser:
		return ec._ErrPushTokenBelongsToAnotherUser(ctx, sel, &obj)
	case *model.ErrPushTokenBelongsToAnotherUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrPushTokenBelongsToAnotherUser(ctx, sel, obj)
	case model.UnregisterUserPushTokenPayload:
		return ec._UnregisterUserPushTokenPayload(ctx, sel, &obj)
	case *model.UnregisterUserPushTokenPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnregisterUserPushTokenPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UnsubscribeFromEmailTypePayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UnsubscribeFromEmailTypePayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.UnsubscribeFromEmailTypePayload:
		return ec._UnsubscribeFromEmailTypePayload(ctx, sel, &obj)
	case *model.UnsubscribeFromEmailTypePayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnsubscribeFromEmailTypePayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateEmailNotificationSettingsPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateEmailNotificationSettingsPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.UpdateEmailNotificationSettingsPayload:
		return ec._UpdateEmailNotificationSettingsPayload(ctx, sel, &obj)
	case *model.UpdateEmailNotificationSettingsPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateEmailNotificationSettingsPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateEmailPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.UpdateEmailPayload:
		return ec._UpdateEmailPayload(ctx, sel, &obj)
	case *model.UpdateEmailPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateEmailPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdatePrimaryWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdatePrimaryWalletPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.UpdatePrimaryWalletPayload:
		return ec._UpdatePrimaryWalletPayload(ctx, sel, &obj)
	case *model.UpdatePrimaryWalletPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdatePrimaryWalletPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitHiddenPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitHiddenPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.UpdateSplitHiddenPayload:
		return ec._UpdateSplitHiddenPayload(ctx, sel, &obj)
	case *model.UpdateSplitHiddenPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitHiddenPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitInfoPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.UpdateSplitInfoPayload:
		return ec._UpdateSplitInfoPayload(ctx, sel, &obj)
	case *model.UpdateSplitInfoPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitInfoPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitOrderPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitOrderPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.UpdateSplitOrderPayload:
		return ec._UpdateSplitOrderPayload(ctx, sel, &obj)
	case *model.UpdateSplitOrderPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitOrderPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.UpdateSplitPayload:
		return ec._UpdateSplitPayload(ctx, sel, &obj)
	case *model.UpdateSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateUserExperiencePayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateUserExperiencePayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.UpdateUserExperiencePayload:
		return ec._UpdateUserExperiencePayload(ctx, sel, &obj)
	case *model.UpdateUserExperiencePayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateUserExperiencePayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateUserInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateUserInfoPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrUsernameNotAvailable:
		return ec._ErrUsernameNotAvailable(ctx, sel, &obj)
	case *model.ErrUsernameNotAvailable:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUsernameNotAvailable(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.UpdateUserInfoPayload:
		return ec._UpdateUserInfoPayload(ctx, sel, &obj)
	case *model.UpdateUserInfoPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateUserInfoPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UploadPersistedQueriesPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UploadPersistedQueriesPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.UploadPersistedQueriesPayload:
		return ec._UploadPersistedQueriesPayload(ctx, sel, &obj)
	case *model.UploadPersistedQueriesPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UploadPersistedQueriesPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserByAddressOrError(ctx context.Context, sel ast.SelectionSet, obj model.UserByAddressOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserByIdOrError(ctx context.Context, sel ast.SelectionSet, obj model.UserByIDOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserByUsernameOrError(ctx context.Context, sel ast.SelectionSet, obj model.UserByUsernameOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _VerifyEmailMagicLinkPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.VerifyEmailMagicLinkPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.VerifyEmailMagicLinkPayload:
		return ec._VerifyEmailMagicLinkPayload(ctx, sel, &obj)
	case *model.VerifyEmailMagicLinkPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._VerifyEmailMagicLinkPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _VerifyEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.VerifyEmailPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.VerifyEmailPayload:
		return ec._VerifyEmailPayload(ctx, sel, &obj)
	case *model.VerifyEmailPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._VerifyEmailPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ViewSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.ViewSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ViewSplitPayload:
		return ec._ViewSplitPayload(ctx, sel, &obj)
	case *model.ViewSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._ViewSplitPayload(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ViewerOrError(ctx context.Context, sel ast.SelectionSet, obj model.ViewerOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Viewer:
		return ec._Viewer(ctx, sel, &obj)
	case *model.Viewer:
		if obj == nil {
			return graphql.Null
		}
		return ec._Viewer(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ViewerSplitByIdPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.ViewerSplitByIDPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrSplitNotFound:
		return ec._ErrSplitNotFound(ctx, sel, &obj)
	case *model.ErrSplitNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSplitNotFound(ctx, sel, obj)
	case model.ViewerSplit:
		return ec._ViewerSplit(ctx, sel, &obj)
	case *model.ViewerSplit:
		if obj == nil {
			return graphql.Null
		}
		return ec._ViewerSplit(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addUserWalletPayloadImplementors = []string{"AddUserWalletPayload", "AddUserWalletPayloadOrError"}

func (ec *executionContext) _AddUserWalletPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddUserWalletPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addUserWalletPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddUserWalletPayload")
		case "viewer":
			out.Values[i] = ec._AddUserWalletPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminAddWalletPayloadImplementors = []string{"AdminAddWalletPayload", "AdminAddWalletPayloadOrError"}

func (ec *executionContext) _AdminAddWalletPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AdminAddWalletPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminAddWalletPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminAddWalletPayload")
		case "user":
			out.Values[i] = ec._AdminAddWalletPayload_user(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var assetImplementors = []string{"Asset", "Node"}

func (ec *executionContext) _Asset(ctx context.Context, sel ast.SelectionSet, obj *model.Asset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Asset")
		case "id":
			out.Values[i] = ec._Asset_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dbid":
			out.Values[i] = ec._Asset_dbid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._Asset_version(ctx, field, obj)
		case "ownerAddress":
			out.Values[i] = ec._Asset_ownerAddress(ctx, field, obj)
		case "balance":
			out.Values[i] = ec._Asset_balance(ctx, field, obj)
		case "token":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Asset_token(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var audioMediaImplementors = []string{"AudioMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _AudioMedia(ctx context.Context, sel ast.SelectionSet, obj *model.AudioMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, audioMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AudioMedia")
		case "previewURLs":
			out.Values[i] = ec._AudioMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._AudioMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._AudioMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._AudioMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._AudioMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authNonceImplementors = []string{"AuthNonce", "GetAuthNoncePayloadOrError"}

func (ec *executionContext) _AuthNonce(ctx context.Context, sel ast.SelectionSet, obj *model.AuthNonce) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authNonceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthNonce")
		case "nonce":
			out.Values[i] = ec._AuthNonce_nonce(ctx, field, obj)
		case "message":
			out.Values[i] = ec._AuthNonce_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chainAddressImplementors = []string{"ChainAddress", "SplitFiUserOrAddress"}

func (ec *executionContext) _ChainAddress(ctx context.Context, sel ast.SelectionSet, obj *persist.ChainAddress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chainAddressImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChainAddress")
		case "address":
			out.Values[i] = ec._ChainAddress_address(ctx, field, obj)
		case "chain":
			out.Values[i] = ec._ChainAddress_chain(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chainPubKeyImplementors = []string{"ChainPubKey"}

func (ec *executionContext) _ChainPubKey(ctx context.Context, sel ast.SelectionSet, obj *persist.ChainPubKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chainPubKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChainPubKey")
		case "pubKey":
			out.Values[i] = ec._ChainPubKey_pubKey(ctx, field, obj)
		case "chain":
			out.Values[i] = ec._ChainPubKey_chain(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chainSplitsImplementors = []string{"ChainSplits"}

func (ec *executionContext) _ChainSplits(ctx context.Context, sel ast.SelectionSet, obj *model.ChainSplits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chainSplitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChainSplits")
		case "chain":
			out.Values[i] = ec._ChainSplits_chain(ctx, field, obj)
		case "splits":
			out.Values[i] = ec._ChainSplits_splits(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chainTokensImplementors = []string{"ChainTokens"}

func (ec *executionContext) _ChainTokens(ctx context.Context, sel ast.SelectionSet, obj *model.ChainTokens) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chainTokensImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChainTokens")
		case "chain":
			out.Values[i] = ec._ChainTokens_chain(ctx, field, obj)
		case "tokens":
			out.Values[i] = ec._ChainTokens_tokens(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var clearAllNotificationsPayloadImplementors = []string{"ClearAllNotificationsPayload"}

func (ec *executionContext) _ClearAllNotificationsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ClearAllNotificationsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clearAllNotificationsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClearAllNotificationsPayload")
		case "notifications":
			out.Values[i] = ec._ClearAllNotificationsPayload_notifications(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createSplitPayloadImplementors = []string{"CreateSplitPayload", "CreateSplitPayloadOrError"}

func (ec *executionContext) _CreateSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createSplitPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateSplitPayload")
		case "split":
			out.Values[i] = ec._CreateSplitPayload_split(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var createUserPayloadImplementors = []string{"CreateUserPayload", "CreateUserPayloadOrError"}

func (ec *executionContext) _CreateUserPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateUserPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createUserPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateUserPayload")
		case "userId":
			out.Values[i] = ec._CreateUserPayload_userId(ctx, field, obj)
		case "splitId":
			out.Values[i] = ec._CreateUserPayload_splitId(ctx, field, obj)
		case "viewer":
			out.Values[i] = ec._CreateUserPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteSplitPayloadImplementors = []string{"DeleteSplitPayload", "DeleteSplitPayloadOrError"}

func (ec *executionContext) _DeleteSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteSplitPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteSplitPayload")
		case "deletedId":
			out.Values[i] = ec._DeleteSplitPayload_deletedId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deletedNodeImplementors = []string{"DeletedNode", "Node"}

func (ec *executionContext) _DeletedNode(ctx context.Context, sel ast.SelectionSet, obj *model.DeletedNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletedNodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletedNode")
		case "id":
			out.Values[i] = ec._DeletedNode_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dbid":
			out.Values[i] = ec._DeletedNode_dbid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var emailNotificationSettingsImplementors = []string{"EmailNotificationSettings"}

func (ec *executionContext) _EmailNotificationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.EmailNotificationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, emailNotificationSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EmailNotificationSettings")
		case "unsubscribedFromAll":
			out.Values[i] = ec._EmailNotificationSettings_unsubscribedFromAll(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unsubscribedFromNotifications":
			out.Values[i] = ec._EmailNotificationSettings_unsubscribedFromNotifications(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errAddressOwnedByUserImplementors = []string{"ErrAddressOwnedByUser", "AddUserWalletPayloadOrError", "Error", "AdminAddWalletPayloadOrError"}

func (ec *executionContext) _ErrAddressOwnedByUser(ctx context.Context, sel ast.SelectionSet, obj *model.ErrAddressOwnedByUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errAddressOwnedByUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrAddressOwnedByUser")
		case "message":
			out.Values[i] = ec._ErrAddressOwnedByUser_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errAuthenticationFailedImplementors = []string{"ErrAuthenticationFailed", "AddUserWalletPayloadOrError", "Error", "LoginPayloadOrError", "CreateUserPayloadOrError", "ViewSplitPayloadOrError"}

func (ec *executionContext) _ErrAuthenticationFailed(ctx context.Context, sel ast.SelectionSet, obj *model.ErrAuthenticationFailed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errAuthenticationFailedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrAuthenticationFailed")
		case "message":
			out.Values[i] = ec._ErrAuthenticationFailed_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errCommunityNotFoundImplementors = []string{"ErrCommunityNotFound", "Error"}

func (ec *executionContext) _ErrCommunityNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrCommunityNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errCommunityNotFoundImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrCommunityNotFound")
		case "message":
			out.Values[i] = ec._ErrCommunityNotFound_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errDoesNotOwnRequiredTokenImplementors = []string{"ErrDoesNotOwnRequiredToken", "AuthorizationError", "Error", "LoginPayloadOrError", "CreateUserPayloadOrError"}

func (ec *executionContext) _ErrDoesNotOwnRequiredToken(ctx context.Context, sel ast.SelectionSet, obj *model.ErrDoesNotOwnRequiredToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errDoesNotOwnRequiredTokenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrDoesNotOwnRequiredToken")
		case "message":
			out.Values[i] = ec._ErrDoesNotOwnRequiredToken_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errInvalidInputImplementors = []string{"ErrInvalidInput", "UserByUsernameOrError", "UserByIdOrError", "UserByAddressOrError", "SearchUsersPayloadOrError", "SearchSplitsPayloadOrError", "AddUserWalletPayloadOrError", "RemoveUserWalletsPayloadOrError", "UpdateUserInfoPayloadOrError", "RegisterUserPushTokenPayloadOrError", "UnregisterUserPushTokenPayloadOrError", "Error", "CreateUserPayloadOrError", "VerifyEmailPayloadOrError", "PreverifyEmailPayloadOrError", "VerifyEmailMagicLinkPayloadOrError", "UpdateEmailPayloadOrError", "ResendVerificationEmailPayloadOrError", "UpdateEmailNotificationSettingsPayloadOrError", "UnsubscribeFromEmailTypePayloadOrError", "OptInForRolesPayloadOrError", "OptOutForRolesPayloadOrError", "CreateSplitPayloadOrError", "UpdateSplitInfoPayloadOrError", "UpdateSplitHiddenPayloadOrError", "DeleteSplitPayloadOrError", "UpdateSplitOrderPayloadOrError", "UpdateSplitPayloadOrError", "PublishSplitPayloadOrError", "UpdatePrimaryWalletPayloadOrError", "UpdateUserExperiencePayloadOrError"}

func (ec *executionContext) _ErrInvalidInput(ctx context.Context, sel ast.SelectionSet, obj *model.ErrInvalidInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errInvalidInputImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrInvalidInput")
		case "message":
			out.Values[i] = ec._ErrInvalidInput_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parameters":
			out.Values[i] = ec._ErrInvalidInput_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reasons":
			out.Values[i] = ec._ErrInvalidInput_reasons(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errInvalidTokenImplementors = []string{"ErrInvalidToken", "AuthorizationError", "Error"}

func (ec *executionContext) _ErrInvalidToken(ctx context.Context, sel ast.SelectionSet, obj *model.ErrInvalidToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errInvalidTokenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrInvalidToken")
		case "message":
			out.Values[i] = ec._ErrInvalidToken_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errNoCookieImplementors = []string{"ErrNoCookie", "AuthorizationError", "Error"}

func (ec *executionContext) _ErrNoCookie(ctx context.Context, sel ast.SelectionSet, obj *model.ErrNoCookie) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errNoCookieImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrNoCookie")
		case "message":
			out.Values[i] = ec._ErrNoCookie_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errNotAuthorizedImplementors = []string{"ErrNotAuthorized", "ViewerOrError", "AddUserWalletPayloadOrError", "RemoveUserWalletsPayloadOrError", "UpdateUserInfoPayloadOrError", "RegisterUserPushTokenPayloadOrError", "UnregisterUserPushTokenPayloadOrError", "Error", "AddRolesToUserPayloadOrError", "RevokeRolesFromUserPayloadOrError", "OptInForRolesPayloadOrError", "OptOutForRolesPayloadOrError", "UploadPersistedQueriesPayloadOrError", "CreateSplitPayloadOrError", "UpdateSplitInfoPayloadOrError", "UpdateSplitHiddenPayloadOrError", "DeleteSplitPayloadOrError", "UpdateSplitOrderPayloadOrError", "UpdateSplitPayloadOrError", "PublishSplitPayloadOrError", "UpdatePrimaryWalletPayloadOrError", "AdminAddWalletPayloadOrError", "UpdateUserExperiencePayloadOrError"}

func (ec *executionContext) _ErrNotAuthorized(ctx context.Context, sel ast.SelectionSet, obj *model.ErrNotAuthorized) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errNotAuthorizedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrNotAuthorized")
		case "message":
			out.Values[i] = ec._ErrNotAuthorized_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cause":
			out.Values[i] = ec._ErrNotAuthorized_cause(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errPushTokenBelongsToAnotherUserImplementors = []string{"ErrPushTokenBelongsToAnotherUser", "RegisterUserPushTokenPayloadOrError", "UnregisterUserPushTokenPayloadOrError", "Error"}

func (ec *executionContext) _ErrPushTokenBelongsToAnotherUser(ctx context.Context, sel ast.SelectionSet, obj *model.ErrPushTokenBelongsToAnotherUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errPushTokenBelongsToAnotherUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrPushTokenBelongsToAnotherUser")
		case "message":
			out.Values[i] = ec._ErrPushTokenBelongsToAnotherUser_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errSessionInvalidatedImplementors = []string{"ErrSessionInvalidated", "AuthorizationError", "Error"}

func (ec *executionContext) _ErrSessionInvalidated(ctx context.Context, sel ast.SelectionSet, obj *model.ErrSessionInvalidated) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errSessionInvalidatedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrSessionInvalidated")
		case "message":
			out.Values[i] = ec._ErrSessionInvalidated_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errSplitNotFoundImplementors = []string{"ErrSplitNotFound", "Error", "SplitByIdPayloadOrError", "ViewerSplitByIdPayloadOrError"}

func (ec *executionContext) _ErrSplitNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrSplitNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errSplitNotFoundImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrSplitNotFound")
		case "message":
			out.Values[i] = ec._ErrSplitNotFound_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errSyncFailedImplementors = []string{"ErrSyncFailed", "Error"}

func (ec *executionContext) _ErrSyncFailed(ctx context.Context, sel ast.SelectionSet, obj *model.ErrSyncFailed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errSyncFailedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrSyncFailed")
		case "message":
			out.Values[i] = ec._ErrSyncFailed_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errTokenNotFoundImplementors = []string{"ErrTokenNotFound", "Error"}

func (ec *executionContext) _ErrTokenNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrTokenNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errTokenNotFoundImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrTokenNotFound")
		case "message":
			out.Values[i] = ec._ErrTokenNotFound_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errUserAlreadyExistsImplementors = []string{"ErrUserAlreadyExists", "Error", "CreateUserPayloadOrError"}

func (ec *executionContext) _ErrUserAlreadyExists(ctx context.Context, sel ast.SelectionSet, obj *model.ErrUserAlreadyExists) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errUserAlreadyExistsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrUserAlreadyExists")
		case "message":
			out.Values[i] = ec._ErrUserAlreadyExists_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errUserNotFoundImplementors = []string{"ErrUserNotFound", "UserByUsernameOrError", "UserByIdOrError", "UserByAddressOrError", "Error", "LoginPayloadOrError", "AdminAddWalletPayloadOrError"}

func (ec *executionContext) _ErrUserNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrUserNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errUserNotFoundImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrUserNotFound")
		case "message":
			out.Values[i] = ec._ErrUserNotFound_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var errUsernameNotAvailableImplementors = []string{"ErrUsernameNotAvailable", "UpdateUserInfoPayloadOrError", "Error", "CreateUserPayloadOrError"}

func (ec *executionContext) _ErrUsernameNotAvailable(ctx context.Context, sel ast.SelectionSet, obj *model.ErrUsernameNotAvailable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errUsernameNotAvailableImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrUsernameNotAvailable")
		case "message":
			out.Values[i] = ec._ErrUsernameNotAvailable_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gIFMediaImplementors = []string{"GIFMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _GIFMedia(ctx context.Context, sel ast.SelectionSet, obj *model.GIFMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gIFMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GIFMedia")
		case "previewURLs":
			out.Values[i] = ec._GIFMedia_previewURLs(ctx, field, obj)
		case "staticPreviewURLs":
			out.Values[i] = ec._GIFMedia_staticPreviewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._GIFMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._GIFMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._GIFMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._GIFMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gltfMediaImplementors = []string{"GltfMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _GltfMedia(ctx context.Context, sel ast.SelectionSet, obj *model.GltfMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gltfMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GltfMedia")
		case "previewURLs":
			out.Values[i] = ec._GltfMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._GltfMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._GltfMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._GltfMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._GltfMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupNotificationUserEdgeImplementors = []string{"GroupNotificationUserEdge"}

func (ec *executionContext) _GroupNotificationUserEdge(ctx context.Context, sel ast.SelectionSet, obj *model.GroupNotificationUserEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupNotificationUserEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupNotificationUserEdge")
		case "node":
			out.Values[i] = ec._GroupNotificationUserEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._GroupNotificationUserEdge_cursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupNotificationUsersConnectionImplementors = []string{"GroupNotificationUsersConnection"}

func (ec *executionContext) _GroupNotificationUsersConnection(ctx context.Context, sel ast.SelectionSet, obj *model.GroupNotificationUsersConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupNotificationUsersConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupNotificationUsersConnection")
		case "edges":
			out.Values[i] = ec._GroupNotificationUsersConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._GroupNotificationUsersConnection_pageInfo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var htmlMediaImplementors = []string{"HtmlMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _HtmlMedia(ctx context.Context, sel ast.SelectionSet, obj *model.HTMLMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, htmlMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HtmlMedia")
		case "previewURLs":
			out.Values[i] = ec._HtmlMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._HtmlMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._HtmlMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._HtmlMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._HtmlMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageMediaImplementors = []string{"ImageMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _ImageMedia(ctx context.Context, sel ast.SelectionSet, obj *model.ImageMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageMedia")
		case "previewURLs":
			out.Values[i] = ec._ImageMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._ImageMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._ImageMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._ImageMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._ImageMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invalidMediaImplementors = []string{"InvalidMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _InvalidMedia(ctx context.Context, sel ast.SelectionSet, obj *model.InvalidMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invalidMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvalidMedia")
		case "previewURLs":
			out.Values[i] = ec._InvalidMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._InvalidMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._InvalidMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._InvalidMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._InvalidMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jsonMediaImplementors = []string{"JsonMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _JsonMedia(ctx context.Context, sel ast.SelectionSet, obj *model.JSONMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jsonMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JsonMedia")
		case "previewURLs":
			out.Values[i] = ec._JsonMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._JsonMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._JsonMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._JsonMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._JsonMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var loginPayloadImplementors = []string{"LoginPayload", "LoginPayloadOrError"}

func (ec *executionContext) _LoginPayload(ctx context.Context, sel ast.SelectionSet, obj *model.LoginPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loginPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoginPayload")
		case "userId":
			out.Values[i] = ec._LoginPayload_userId(ctx, field, obj)
		case "viewer":
			out.Values[i] = ec._LoginPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logoutPayloadImplementors = []string{"LogoutPayload"}

func (ec *executionContext) _LogoutPayload(ctx context.Context, sel ast.SelectionSet, obj *model.LogoutPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logoutPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogoutPayload")
		case "viewer":
			out.Values[i] = ec._LogoutPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mediaDimensionsImplementors = []string{"MediaDimensions"}

func (ec *executionContext) _MediaDimensions(ctx context.Context, sel ast.SelectionSet, obj *model.MediaDimensions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mediaDimensionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MediaDimensions")
		case "width":
			out.Values[i] = ec._MediaDimensions_width(ctx, field, obj)
		case "height":
			out.Values[i] = ec._MediaDimensions_height(ctx, field, obj)
		case "aspectRatio":
			out.Values[i] = ec._MediaDimensions_aspectRatio(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "addUserWallet":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addUserWallet(ctx, field)
			})
		case "removeUserWallets":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeUserWallets(ctx, field)
			})
		case "updateUserInfo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserInfo(ctx, field)
			})
		case "registerUserPushToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registerUserPushToken(ctx, field)
			})
		case "unregisterUserPushToken":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unregisterUserPushToken(ctx, field)
			})
		case "getAuthNonce":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_getAuthNonce(ctx, field)
			})
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
		case "updateEmail":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEmail(ctx, field)
			})
		case "resendVerificationEmail":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resendVerificationEmail(ctx, field)
			})
		case "updateEmailNotificationSettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEmailNotificationSettings(ctx, field)
			})
		case "unsubscribeFromEmailType":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unsubscribeFromEmailType(ctx, field)
			})
		case "login":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_login(ctx, field)
			})
		case "logout":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_logout(ctx, field)
			})
		case "viewSplit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_viewSplit(ctx, field)
			})
		case "updateSplit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplit(ctx, field)
			})
		case "publishSplit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_publishSplit(ctx, field)
			})
		case "createSplit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSplit(ctx, field)
			})
		case "updateSplitHidden":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplitHidden(ctx, field)
			})
		case "deleteSplit":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSplit(ctx, field)
			})
		case "updateSplitOrder":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplitOrder(ctx, field)
			})
		case "updateSplitInfo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplitInfo(ctx, field)
			})
		case "clearAllNotifications":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_clearAllNotifications(ctx, field)
			})
		case "updateNotificationSettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateNotificationSettings(ctx, field)
			})
		case "preverifyEmail":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_preverifyEmail(ctx, field)
			})
		case "verifyEmail":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_verifyEmail(ctx, field)
			})
		case "verifyEmailMagicLink":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_verifyEmailMagicLink(ctx, field)
			})
		case "optInForRoles":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_optInForRoles(ctx, field)
			})
		case "optOutForRoles":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_optOutForRoles(ctx, field)
			})
		case "addRolesToUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addRolesToUser(ctx, field)
			})
		case "addWalletToUserUnchecked":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addWalletToUserUnchecked(ctx, field)
			})
		case "revokeRolesFromUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeRolesFromUser(ctx, field)
			})
		case "uploadPersistedQueries":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadPersistedQueries(ctx, field)
			})
		case "updatePrimaryWallet":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePrimaryWallet(ctx, field)
			})
		case "updateUserExperience":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserExperience(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationEdgeImplementors = []string{"NotificationEdge"}

func (ec *executionContext) _NotificationEdge(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationEdge")
		case "node":
			out.Values[i] = ec._NotificationEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._NotificationEdge_cursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationSettingsImplementors = []string{"NotificationSettings"}

func (ec *executionContext) _NotificationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationSettings")
		case "someoneFollowedYou":
			out.Values[i] = ec._NotificationSettings_someoneFollowedYou(ctx, field, obj)
		case "someoneViewedYourSplit":
			out.Values[i] = ec._NotificationSettings_someoneViewedYourSplit(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationsConnectionImplementors = []string{"NotificationsConnection"}

func (ec *executionContext) _NotificationsConnection(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationsConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationsConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationsConnection")
		case "edges":
			out.Values[i] = ec._NotificationsConnection_edges(ctx, field, obj)
		case "unseenCount":
			out.Values[i] = ec._NotificationsConnection_unseenCount(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._NotificationsConnection_pageInfo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var optInForRolesPayloadImplementors = []string{"OptInForRolesPayload", "OptInForRolesPayloadOrError"}

func (ec *executionContext) _OptInForRolesPayload(ctx context.Context, sel ast.SelectionSet, obj *model.OptInForRolesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, optInForRolesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OptInForRolesPayload")
		case "user":
			out.Values[i] = ec._OptInForRolesPayload_user(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var optOutForRolesPayloadImplementors = []string{"OptOutForRolesPayload", "OptOutForRolesPayloadOrError"}

func (ec *executionContext) _OptOutForRolesPayload(ctx context.Context, sel ast.SelectionSet, obj *model.OptOutForRolesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, optOutForRolesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OptOutForRolesPayload")
		case "user":
			out.Values[i] = ec._OptOutForRolesPayload_user(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "total":
			out.Values[i] = ec._PageInfo_total(ctx, field, obj)
		case "size":
			out.Values[i] = ec._PageInfo_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pdfMediaImplementors = []string{"PdfMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _PdfMedia(ctx context.Context, sel ast.SelectionSet, obj *model.PDFMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pdfMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PdfMedia")
		case "previewURLs":
			out.Values[i] = ec._PdfMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._PdfMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._PdfMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._PdfMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._PdfMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var preverifyEmailPayloadImplementors = []string{"PreverifyEmailPayload", "PreverifyEmailPayloadOrError"}

func (ec *executionContext) _PreverifyEmailPayload(ctx context.Context, sel ast.SelectionSet, obj *model.PreverifyEmailPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preverifyEmailPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreverifyEmailPayload")
		case "email":
			out.Values[i] = ec._PreverifyEmailPayload_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "result":
			out.Values[i] = ec._PreverifyEmailPayload_result(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var previewURLSetImplementors = []string{"PreviewURLSet"}

func (ec *executionContext) _PreviewURLSet(ctx context.Context, sel ast.SelectionSet, obj *model.PreviewURLSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, previewURLSetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreviewURLSet")
		case "raw":
			out.Values[i] = ec._PreviewURLSet_raw(ctx, field, obj)
		case "thumbnail":
			out.Values[i] = ec._PreviewURLSet_thumbnail(ctx, field, obj)
		case "small":
			out.Values[i] = ec._PreviewURLSet_small(ctx, field, obj)
		case "medium":
			out.Values[i] = ec._PreviewURLSet_medium(ctx, field, obj)
		case "large":
			out.Values[i] = ec._PreviewURLSet_large(ctx, field, obj)
		case "srcSet":
			out.Values[i] = ec._PreviewURLSet_srcSet(ctx, field, obj)
		case "liveRender":
			out.Values[i] = ec._PreviewURLSet_liveRender(ctx, field, obj)
		case "blurhash":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PreviewURLSet_blurhash(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var publishSplitPayloadImplementors = []string{"PublishSplitPayload", "PublishSplitPayloadOrError"}

func (ec *executionContext) _PublishSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.PublishSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publishSplitPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublishSplitPayload")
		case "split":
			out.Values[i] = ec._PublishSplitPayload_split(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "viewer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userByUsername":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userByUsername(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userById":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userByAddress":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userByAddress(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "usersWithTrait":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_usersWithTrait(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "splitById":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_splitById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "viewerSplitById":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewerSplitById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchUsers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchUsers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "searchSplits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchSplits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "usersByRole":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_usersByRole(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "_service":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var recipientImplementors = []string{"Recipient", "Node"}

func (ec *executionContext) _Recipient(ctx context.Context, sel ast.SelectionSet, obj *model.Recipient) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, recipientImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Recipient")
		case "id":
			out.Values[i] = ec._Recipient_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dbid":
			out.Values[i] = ec._Recipient_dbid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._Recipient_version(ctx, field, obj)
		case "creationTime":
			out.Values[i] = ec._Recipient_creationTime(ctx, field, obj)
		case "lastUpdated":
			out.Values[i] = ec._Recipient_lastUpdated(ctx, field, obj)
		case "address":
			out.Values[i] = ec._Recipient_address(ctx, field, obj)
		case "split":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Recipient_split(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ownership":
			out.Values[i] = ec._Recipient_ownership(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var registerUserPushTokenPayloadImplementors = []string{"RegisterUserPushTokenPayload", "RegisterUserPushTokenPayloadOrError"}

func (ec *executionContext) _RegisterUserPushTokenPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RegisterUserPushTokenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registerUserPushTokenPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegisterUserPushTokenPayload")
		case "viewer":
			out.Values[i] = ec._RegisterUserPushTokenPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var removeUserWalletsPayloadImplementors = []string{"RemoveUserWalletsPayload", "RemoveUserWalletsPayloadOrError"}

func (ec *executionContext) _RemoveUserWalletsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RemoveUserWalletsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeUserWalletsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveUserWalletsPayload")
		case "viewer":
			out.Values[i] = ec._RemoveUserWalletsPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resendVerificationEmailPayloadImplementors = []string{"ResendVerificationEmailPayload", "ResendVerificationEmailPayloadOrError"}

func (ec *executionContext) _ResendVerificationEmailPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ResendVerificationEmailPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resendVerificationEmailPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResendVerificationEmailPayload")
		case "viewer":
			out.Values[i] = ec._ResendVerificationEmailPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchSplitsPayloadImplementors = []string{"SearchSplitsPayload", "SearchSplitsPayloadOrError"}

func (ec *executionContext) _SearchSplitsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.SearchSplitsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchSplitsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchSplitsPayload")
		case "results":
			out.Values[i] = ec._SearchSplitsPayload_results(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchUsersPayloadImplementors = []string{"SearchUsersPayload", "SearchUsersPayloadOrError"}

func (ec *executionContext) _SearchUsersPayload(ctx context.Context, sel ast.SelectionSet, obj *model.SearchUsersPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchUsersPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchUsersPayload")
		case "results":
			out.Values[i] = ec._SearchUsersPayload_results(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var splitImplementors = []string{"Split", "Node", "SplitByIdPayloadOrError"}

func (ec *executionContext) _Split(ctx context.Context, sel ast.SelectionSet, obj *model.Split) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splitImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Split")
		case "id":
			out.Values[i] = ec._Split_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dbid":
			out.Values[i] = ec._Split_dbid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._Split_version(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Split_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Split_description(ctx, field, obj)
		case "chain":
			out.Values[i] = ec._Split_chain(ctx, field, obj)
		case "logoURL":
			out.Values[i] = ec._Split_logoURL(ctx, field, obj)
		case "bannerURL":
			out.Values[i] = ec._Split_bannerURL(ctx, field, obj)
		case "badgeURL":
			out.Values[i] = ec._Split_badgeURL(ctx, field, obj)
		case "assets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Split_assets(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "shares":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Split_shares(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var splitFiUserImplementors = []string{"SplitFiUser", "Node", "SplitFiUserOrWallet", "SplitFiUserOrAddress", "UserByUsernameOrError", "UserByIdOrError", "UserByAddressOrError", "AddRolesToUserPayloadOrError", "RevokeRolesFromUserPayloadOrError"}

func (ec *executionContext) _SplitFiUser(ctx context.Context, sel ast.SelectionSet, obj *model.SplitFiUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splitFiUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SplitFiUser")
		case "id":
			out.Values[i] = ec._SplitFiUser_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dbid":
			out.Values[i] = ec._SplitFiUser_dbid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "username":
			out.Values[i] = ec._SplitFiUser_username(ctx, field, obj)
		case "bio":
			out.Values[i] = ec._SplitFiUser_bio(ctx, field, obj)
		case "traits":
			out.Values[i] = ec._SplitFiUser_traits(ctx, field, obj)
		case "universal":
			out.Values[i] = ec._SplitFiUser_universal(ctx, field, obj)
		case "roles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_roles(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "wallets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_wallets(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "primaryWallet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_primaryWallet(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "splits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_splits(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "splitsByChain":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_splitsByChain(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "isAuthenticatedUser":
			out.Values[i] = ec._SplitFiUser_isAuthenticatedUser(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var splitSearchResultImplementors = []string{"SplitSearchResult"}

func (ec *executionContext) _SplitSearchResult(ctx context.Context, sel ast.SelectionSet, obj *model.SplitSearchResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splitSearchResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SplitSearchResult")
		case "split":
			out.Values[i] = ec._SplitSearchResult_split(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "newNotification":
		return ec._Subscription_newNotification(ctx, fields[0])
	case "notificationUpdated":
		return ec._Subscription_notificationUpdated(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var textMediaImplementors = []string{"TextMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _TextMedia(ctx context.Context, sel ast.SelectionSet, obj *model.TextMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, textMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TextMedia")
		case "previewURLs":
			out.Values[i] = ec._TextMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._TextMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._TextMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._TextMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._TextMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tokenImplementors = []string{"Token", "Node"}

func (ec *executionContext) _Token(ctx context.Context, sel ast.SelectionSet, obj *model.Token) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Token")
		case "id":
			out.Values[i] = ec._Token_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dbid":
			out.Values[i] = ec._Token_dbid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Token_version(ctx, field, obj)
		case "creationTime":
			out.Values[i] = ec._Token_creationTime(ctx, field, obj)
		case "lastUpdated":
			out.Values[i] = ec._Token_lastUpdated(ctx, field, obj)
		case "tokenType":
			out.Values[i] = ec._Token_tokenType(ctx, field, obj)
		case "chain":
			out.Values[i] = ec._Token_chain(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Token_name(ctx, field, obj)
		case "symbol":
			out.Values[i] = ec._Token_symbol(ctx, field, obj)
		case "decimals":
			out.Values[i] = ec._Token_decimals(ctx, field, obj)
		case "logo":
			out.Values[i] = ec._Token_logo(ctx, field, obj)
		case "totalSupply":
			out.Values[i] = ec._Token_totalSupply(ctx, field, obj)
		case "contractAddress":
			out.Values[i] = ec._Token_contractAddress(ctx, field, obj)
		case "blockNumber":
			out.Values[i] = ec._Token_blockNumber(ctx, field, obj)
		case "isSpam":
			out.Values[i] = ec._Token_isSpam(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unknownMediaImplementors = []string{"UnknownMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _UnknownMedia(ctx context.Context, sel ast.SelectionSet, obj *model.UnknownMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unknownMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnknownMedia")
		case "previewURLs":
			out.Values[i] = ec._UnknownMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._UnknownMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._UnknownMedia_mediaType(ctx, field, obj)
		case "contentRenderURL":
			out.Values[i] = ec._UnknownMedia_contentRenderURL(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._UnknownMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unregisterUserPushTokenPayloadImplementors = []string{"UnregisterUserPushTokenPayload", "UnregisterUserPushTokenPayloadOrError"}

func (ec *executionContext) _UnregisterUserPushTokenPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UnregisterUserPushTokenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unregisterUserPushTokenPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnregisterUserPushTokenPayload")
		case "viewer":
			out.Values[i] = ec._UnregisterUserPushTokenPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unsubscribeFromEmailTypePayloadImplementors = []string{"UnsubscribeFromEmailTypePayload", "UnsubscribeFromEmailTypePayloadOrError"}

func (ec *executionContext) _UnsubscribeFromEmailTypePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UnsubscribeFromEmailTypePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unsubscribeFromEmailTypePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnsubscribeFromEmailTypePayload")
		case "viewer":
			out.Values[i] = ec._UnsubscribeFromEmailTypePayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateEmailNotificationSettingsPayloadImplementors = []string{"UpdateEmailNotificationSettingsPayload", "UpdateEmailNotificationSettingsPayloadOrError"}

func (ec *executionContext) _UpdateEmailNotificationSettingsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateEmailNotificationSettingsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEmailNotificationSettingsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEmailNotificationSettingsPayload")
		case "viewer":
			out.Values[i] = ec._UpdateEmailNotificationSettingsPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateEmailPayloadImplementors = []string{"UpdateEmailPayload", "UpdateEmailPayloadOrError"}

func (ec *executionContext) _UpdateEmailPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateEmailPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEmailPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEmailPayload")
		case "viewer":
			out.Values[i] = ec._UpdateEmailPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updatePrimaryWalletPayloadImplementors = []string{"UpdatePrimaryWalletPayload", "UpdatePrimaryWalletPayloadOrError"}

func (ec *executionContext) _UpdatePrimaryWalletPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdatePrimaryWalletPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updatePrimaryWalletPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdatePrimaryWalletPayload")
		case "viewer":
			out.Values[i] = ec._UpdatePrimaryWalletPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateSplitHiddenPayloadImplementors = []string{"UpdateSplitHiddenPayload", "UpdateSplitHiddenPayloadOrError"}

func (ec *executionContext) _UpdateSplitHiddenPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitHiddenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitHiddenPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitHiddenPayload")
		case "split":
			out.Values[i] = ec._UpdateSplitHiddenPayload_split(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateSplitInfoPayloadImplementors = []string{"UpdateSplitInfoPayload", "UpdateSplitInfoPayloadOrError"}

func (ec *executionContext) _UpdateSplitInfoPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitInfoPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitInfoPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitInfoPayload")
		case "split":
			out.Values[i] = ec._UpdateSplitInfoPayload_split(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateSplitOrderPayloadImplementors = []string{"UpdateSplitOrderPayload", "UpdateSplitOrderPayloadOrError"}

func (ec *executionContext) _UpdateSplitOrderPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitOrderPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitOrderPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitOrderPayload")
		case "viewer":
			out.Values[i] = ec._UpdateSplitOrderPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateSplitPayloadImplementors = []string{"UpdateSplitPayload", "UpdateSplitPayloadOrError"}

func (ec *executionContext) _UpdateSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitPayload")
		case "split":
			out.Values[i] = ec._UpdateSplitPayload_split(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateUserExperiencePayloadImplementors = []string{"UpdateUserExperiencePayload", "UpdateUserExperiencePayloadOrError"}

func (ec *executionContext) _UpdateUserExperiencePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateUserExperiencePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateUserExperiencePayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateUserExperiencePayload")
		case "viewer":
			out.Values[i] = ec._UpdateUserExperiencePayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateUserInfoPayloadImplementors = []string{"UpdateUserInfoPayload", "UpdateUserInfoPayloadOrError"}

func (ec *executionContext) _UpdateUserInfoPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateUserInfoPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateUserInfoPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateUserInfoPayload")
		case "viewer":
			out.Values[i] = ec._UpdateUserInfoPayload_viewer(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uploadPersistedQueriesPayloadImplementors = []string{"UploadPersistedQueriesPayload", "UploadPersistedQueriesPayloadOrError"}

func (ec *executionContext) _UploadPersistedQueriesPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UploadPersistedQueriesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uploadPersistedQueriesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UploadPersistedQueriesPayload")
		case "message":
			out.Values[i] = ec._UploadPersistedQueriesPayload_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (ec *executionContext) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *model.UserEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEdge")
		case "node":
			out.Values[i] = ec._UserEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._UserEdge_cursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userEmailImplementors = []string{"UserEmail"}

func (ec *executionContext) _UserEmail(ctx context.Context, sel ast.SelectionSet, obj *model.UserEmail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEmailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEmail")
		case "email":
			out.Values[i] = ec._UserEmail_email(ctx, field, obj)
		case "verificationStatus":
			out.Values[i] = ec._UserEmail_verificationStatus(ctx, field, obj)
		case "emailNotificationSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserEmail_emailNotificationSettings(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userExperienceImplementors = []string{"UserExperience"}

func (ec *executionContext) _UserExperience(ctx context.Context, sel ast.SelectionSet, obj *model.UserExperience) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userExperienceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserExperience")
		case "type":
			out.Values[i] = ec._UserExperience_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "experienced":
			out.Values[i] = ec._UserExperience_experienced(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSearchResultImplementors = []string{"UserSearchResult"}

func (ec *executionContext) _UserSearchResult(ctx context.Context, sel ast.SelectionSet, obj *model.UserSearchResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSearchResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSearchResult")
		case "user":
			out.Values[i] = ec._UserSearchResult_user(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var usersConnectionImplementors = []string{"UsersConnection"}

func (ec *executionContext) _UsersConnection(ctx context.Context, sel ast.SelectionSet, obj *model.UsersConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, usersConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UsersConnection")
		case "edges":
			out.Values[i] = ec._UsersConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._UsersConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var verifyEmailMagicLinkPayloadImplementors = []string{"VerifyEmailMagicLinkPayload", "VerifyEmailMagicLinkPayloadOrError"}

func (ec *executionContext) _VerifyEmailMagicLinkPayload(ctx context.Context, sel ast.SelectionSet, obj *model.VerifyEmailMagicLinkPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, verifyEmailMagicLinkPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VerifyEmailMagicLinkPayload")
		case "canSend":
			out.Values[i] = ec._VerifyEmailMagicLinkPayload_canSend(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var verifyEmailPayloadImplementors = []string{"VerifyEmailPayload", "VerifyEmailPayloadOrError"}

func (ec *executionContext) _VerifyEmailPayload(ctx context.Context, sel ast.SelectionSet, obj *model.VerifyEmailPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, verifyEmailPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VerifyEmailPayload")
		case "email":
			out.Values[i] = ec._VerifyEmailPayload_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var videoMediaImplementors = []string{"VideoMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _VideoMedia(ctx context.Context, sel ast.SelectionSet, obj *model.VideoMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, videoMediaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VideoMedia")
		case "previewURLs":
			out.Values[i] = ec._VideoMedia_previewURLs(ctx, field, obj)
		case "mediaURL":
			out.Values[i] = ec._VideoMedia_mediaURL(ctx, field, obj)
		case "mediaType":
			out.Values[i] = ec._VideoMedia_mediaType(ctx, field, obj)
		case "contentRenderURLs":
			out.Values[i] = ec._VideoMedia_contentRenderURLs(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._VideoMedia_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var videoURLSetImplementors = []string{"VideoURLSet"}

func (ec *executionContext) _VideoURLSet(ctx context.Context, sel ast.SelectionSet, obj *model.VideoURLSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, videoURLSetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VideoURLSet")
		case "raw":
			out.Values[i] = ec._VideoURLSet_raw(ctx, field, obj)
		case "small":
			out.Values[i] = ec._VideoURLSet_small(ctx, field, obj)
		case "medium":
			out.Values[i] = ec._VideoURLSet_medium(ctx, field, obj)
		case "large":
			out.Values[i] = ec._VideoURLSet_large(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var viewSplitPayloadImplementors = []string{"ViewSplitPayload", "ViewSplitPayloadOrError"}

func (ec *executionContext) _ViewSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ViewSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, viewSplitPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ViewSplitPayload")
		case "split":
			out.Values[i] = ec._ViewSplitPayload_split(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var viewerImplementors = []string{"Viewer", "Node", "ViewerOrError"}

func (ec *executionContext) _Viewer(ctx context.Context, sel ast.SelectionSet, obj *model.Viewer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, viewerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Viewer")
		case "id":
			out.Values[i] = ec._Viewer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "viewerSplits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_viewerSplits(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "email":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_email(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "notifications":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_notifications(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "notificationSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_notificationSettings(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userExperiences":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_userExperiences(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var viewerSplitImplementors = []string{"ViewerSplit", "ViewerSplitByIdPayloadOrError"}

func (ec *executionContext) _ViewerSplit(ctx context.Context, sel ast.SelectionSet, obj *model.ViewerSplit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, viewerSplitImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ViewerSplit")
		case "split":
			out.Values[i] = ec._ViewerSplit_split(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var walletImplementors = []string{"Wallet", "Node", "SplitFiUserOrWallet"}

func (ec *executionContext) _Wallet(ctx context.Context, sel ast.SelectionSet, obj *model.Wallet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Wallet")
		case "id":
			out.Values[i] = ec._Wallet_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dbid":
			out.Values[i] = ec._Wallet_dbid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "chainAddress":
			out.Values[i] = ec._Wallet_chainAddress(ctx, field, obj)
		case "chain":
			out.Values[i] = ec._Wallet_chain(ctx, field, obj)
		case "walletType":
			out.Values[i] = ec._Wallet_walletType(ctx, field, obj)
		case "splits":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Wallet_splits(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":
			out.Values[i] = ec.__Service_sdl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddress2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx context.Context, v interface{}) (persist.Address, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Address(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddress2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx context.Context, sel ast.SelectionSet, v persist.Address) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNAdminAddWalletInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAdminAddWalletInput(ctx context.Context, v interface{}) (model.AdminAddWalletInput, error) {
	res, err := ec.unmarshalInputAdminAddWalletInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAuthMechanism2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAuthMechanism(ctx context.Context, v interface{}) (model.AuthMechanism, error) {
	res, err := ec.unmarshalInputAuthMechanism(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAuthorizationError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAuthorizationError(ctx context.Context, sel ast.SelectionSet, v model.AuthorizationError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthorizationError(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBasicAuthType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenType(ctx context.Context, v interface{}) (basicauth.AuthTokenType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := basicauth.AuthTokenType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBasicAuthType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenType(ctx context.Context, sel ast.SelectionSet, v basicauth.AuthTokenType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBasicAuthType2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenTypeᚄ(ctx context.Context, v interface{}) ([]basicauth.AuthTokenType, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]basicauth.AuthTokenType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBasicAuthType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNBasicAuthType2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []basicauth.AuthTokenType) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBasicAuthType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋauthᚋbasicauthᚐAuthTokenType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx context.Context, v interface{}) (persist.Chain, error) {
	var res persist.Chain
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx context.Context, sel ast.SelectionSet, v persist.Chain) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNChainAddressInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx context.Context, v interface{}) (persist.ChainAddress, error) {
	res, err := ec.unmarshalInputChainAddressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChainAddressInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx context.Context, v interface{}) (*persist.ChainAddress, error) {
	res, err := ec.unmarshalInputChainAddressInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChainPubKeyInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainPubKey(ctx context.Context, v interface{}) (*persist.ChainPubKey, error) {
	res, err := ec.unmarshalInputChainPubKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSplitInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐCreateSplitInput(ctx context.Context, v interface{}) (model.CreateSplitInput, error) {
	res, err := ec.unmarshalInputCreateSplitInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUserInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐCreateUserInput(ctx context.Context, v interface{}) (model.CreateUserInput, error) {
	res, err := ec.unmarshalInputCreateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx context.Context, v interface{}) (persist.DBID, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.DBID(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx context.Context, sel ast.SelectionSet, v persist.DBID) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDBID2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBIDᚄ(ctx context.Context, v interface{}) ([]persist.DBID, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]persist.DBID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDBID2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBIDᚄ(ctx context.Context, sel ast.SelectionSet, v []persist.DBID) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEmail2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx context.Context, v interface{}) (persist.Email, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Email(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEmail2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx context.Context, sel ast.SelectionSet, v persist.Email) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNEmailUnsubscriptionType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐEmailUnsubscriptionType(ctx context.Context, v interface{}) (model.EmailUnsubscriptionType, error) {
	var res model.EmailUnsubscriptionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEmailUnsubscriptionType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐEmailUnsubscriptionType(ctx context.Context, sel ast.SelectionSet, v model.EmailUnsubscriptionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFieldSet2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx context.Context, v interface{}) (model.GqlID, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model.GqlID(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGqlID(ctx context.Context, sel ast.SelectionSet, v model.GqlID) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPageInfo2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPreverifyEmailInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreverifyEmailInput(ctx context.Context, v interface{}) (model.PreverifyEmailInput, error) {
	res, err := ec.unmarshalInputPreverifyEmailInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPreverifyEmailResult2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreverifyEmailResult(ctx context.Context, v interface{}) (model.PreverifyEmailResult, error) {
	var res model.PreverifyEmailResult
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPreverifyEmailResult2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreverifyEmailResult(ctx context.Context, sel ast.SelectionSet, v model.PreverifyEmailResult) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPubKey2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐPubKey(ctx context.Context, v interface{}) (persist.PubKey, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.PubKey(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPubKey2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐPubKey(ctx context.Context, sel ast.SelectionSet, v persist.PubKey) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNPublishSplitInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPublishSplitInput(ctx context.Context, v interface{}) (model.PublishSplitInput, error) {
	res, err := ec.unmarshalInputPublishSplitInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRole2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx context.Context, v interface{}) (persist.Role, error) {
	var res persist.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRole2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx context.Context, sel ast.SelectionSet, v persist.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRole2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRoleᚄ(ctx context.Context, v interface{}) ([]persist.Role, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]persist.Role, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRole2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNRole2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRoleᚄ(ctx context.Context, sel ast.SelectionSet, v []persist.Role) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRole2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSplitPositionInput2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitPositionInputᚄ(ctx context.Context, v interface{}) ([]*model.SplitPositionInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.SplitPositionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSplitPositionInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitPositionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSplitPositionInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitPositionInput(ctx context.Context, v interface{}) (*model.SplitPositionInput, error) {
	res, err := ec.unmarshalInputSplitPositionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSplitSearchResult2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitSearchResult(ctx context.Context, sel ast.SelectionSet, v *model.SplitSearchResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SplitSearchResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUnsubscribeFromEmailTypeInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUnsubscribeFromEmailTypeInput(ctx context.Context, v interface{}) (model.UnsubscribeFromEmailTypeInput, error) {
	res, err := ec.unmarshalInputUnsubscribeFromEmailTypeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEmailInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateEmailInput(ctx context.Context, v interface{}) (model.UpdateEmailInput, error) {
	res, err := ec.unmarshalInputUpdateEmailInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEmailNotificationSettingsInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateEmailNotificationSettingsInput(ctx context.Context, v interface{}) (model.UpdateEmailNotificationSettingsInput, error) {
	res, err := ec.unmarshalInputUpdateEmailNotificationSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitHiddenInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitHiddenInput(ctx context.Context, v interface{}) (model.UpdateSplitHiddenInput, error) {
	res, err := ec.unmarshalInputUpdateSplitHiddenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitInfoInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitInfoInput(ctx context.Context, v interface{}) (model.UpdateSplitInfoInput, error) {
	res, err := ec.unmarshalInputUpdateSplitInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitInput(ctx context.Context, v interface{}) (model.UpdateSplitInput, error) {
	res, err := ec.unmarshalInputUpdateSplitInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitOrderInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitOrderInput(ctx context.Context, v interface{}) (model.UpdateSplitOrderInput, error) {
	res, err := ec.unmarshalInputUpdateSplitOrderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserExperienceInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateUserExperienceInput(ctx context.Context, v interface{}) (model.UpdateUserExperienceInput, error) {
	res, err := ec.unmarshalInputUpdateUserExperienceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserInfoInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateUserInfoInput(ctx context.Context, v interface{}) (model.UpdateUserInfoInput, error) {
	res, err := ec.unmarshalInputUpdateUserInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserExperience2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserExperience(ctx context.Context, sel ast.SelectionSet, v *model.UserExperience) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserExperience(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserExperienceType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserExperienceType(ctx context.Context, v interface{}) (model.UserExperienceType, error) {
	var res model.UserExperienceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserExperienceType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserExperienceType(ctx context.Context, sel ast.SelectionSet, v model.UserExperienceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUserSearchResult2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserSearchResult(ctx context.Context, sel ast.SelectionSet, v *model.UserSearchResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSearchResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVerifyEmailInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVerifyEmailInput(ctx context.Context, v interface{}) (model.VerifyEmailInput, error) {
	res, err := ec.unmarshalInputVerifyEmailInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNVerifyEmailMagicLinkInput2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVerifyEmailMagicLinkInput(ctx context.Context, v interface{}) (model.VerifyEmailMagicLinkInput, error) {
	res, err := ec.unmarshalInputVerifyEmailMagicLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWalletType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐWalletType(ctx context.Context, v interface{}) (persist.WalletType, error) {
	var res persist.WalletType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWalletType2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐWalletType(ctx context.Context, sel ast.SelectionSet, v persist.WalletType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN_Service2githubᚗcomᚋ99designsᚋgqlgenᚋpluginᚋfederationᚋfedruntimeᚐService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNfederation__Policy2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNfederation__Policy2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNfederation__Policy2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNfederation__Policy2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfederation__Policy2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNfederation__Policy2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNfederation__Policy2ᚕᚕstringᚄ(ctx context.Context, v interface{}) ([][]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([][]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNfederation__Policy2ᚕstringᚄ(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfederation__Policy2ᚕᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v [][]string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNfederation__Policy2ᚕstringᚄ(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNfederation__Scope2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNfederation__Scope2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNfederation__Scope2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNfederation__Scope2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfederation__Scope2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNfederation__Scope2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNfederation__Scope2ᚕᚕstringᚄ(ctx context.Context, v interface{}) ([][]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([][]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNfederation__Scope2ᚕstringᚄ(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNfederation__Scope2ᚕᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v [][]string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNfederation__Scope2ᚕstringᚄ(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAddRolesToUserPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAddRolesToUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.AddRolesToUserPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddRolesToUserPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOAddUserWalletPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAddUserWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.AddUserWalletPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddUserWalletPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAddress2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx context.Context, v interface{}) (persist.Address, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Address(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAddress2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx context.Context, sel ast.SelectionSet, v persist.Address) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalOAddress2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx context.Context, v interface{}) (*persist.Address, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Address(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAddress2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐAddress(ctx context.Context, sel ast.SelectionSet, v *persist.Address) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOAdminAddWalletPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAdminAddWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.AdminAddWalletPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdminAddWalletPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOAsset2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAsset(ctx context.Context, sel ast.SelectionSet, v []*model.Asset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAsset2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAsset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAsset2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAsset(ctx context.Context, sel ast.SelectionSet, v *model.Asset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Asset(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthMechanism2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐAuthMechanism(ctx context.Context, v interface{}) (*model.AuthMechanism, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAuthMechanism(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx context.Context, v interface{}) (persist.Chain, error) {
	var res persist.Chain
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChain2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx context.Context, sel ast.SelectionSet, v persist.Chain) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOChain2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx context.Context, v interface{}) (*persist.Chain, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(persist.Chain)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChain2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChain(ctx context.Context, sel ast.SelectionSet, v *persist.Chain) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOChainAddress2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx context.Context, sel ast.SelectionSet, v *persist.ChainAddress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChainAddress(ctx, sel, v)
}

func (ec *executionContext) unmarshalOChainAddressInput2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddressᚄ(ctx context.Context, v interface{}) ([]*persist.ChainAddress, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*persist.ChainAddress, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChainAddressInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐChainAddress(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOChainSplits2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐChainSplits(ctx context.Context, sel ast.SelectionSet, v *model.ChainSplits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChainSplits(ctx, sel, v)
}

func (ec *executionContext) marshalOClearAllNotificationsPayload2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐClearAllNotificationsPayload(ctx context.Context, sel ast.SelectionSet, v *model.ClearAllNotificationsPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ClearAllNotificationsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOCreateSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐCreateSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.CreateSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CreateSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOCreateUserPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐCreateUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.CreateUserPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CreateUserPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalODBID2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBIDᚄ(ctx context.Context, v interface{}) ([]persist.DBID, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]persist.DBID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODBID2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBIDᚄ(ctx context.Context, sel ast.SelectionSet, v []persist.DBID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNDBID2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODBID2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx context.Context, v interface{}) (*persist.DBID, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := persist.DBID(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODBID2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐDBID(ctx context.Context, sel ast.SelectionSet, v *persist.DBID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalODebugAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐDebugAuth(ctx context.Context, v interface{}) (*model.DebugAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDebugAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeleteSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐDeleteSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.DeleteSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalODeletedNode2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐDeletedNode(ctx context.Context, sel ast.SelectionSet, v *model.DeletedNode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeletedNode(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEmail2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx context.Context, v interface{}) (*persist.Email, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Email(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEmail2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmail(ctx context.Context, sel ast.SelectionSet, v *persist.Email) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOEmailNotificationSettings2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐEmailNotificationSettings(ctx context.Context, sel ast.SelectionSet, v *model.EmailNotificationSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EmailNotificationSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEmailVerificationStatus2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmailVerificationStatus(ctx context.Context, v interface{}) (*persist.EmailVerificationStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(persist.EmailVerificationStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEmailVerificationStatus2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐEmailVerificationStatus(ctx context.Context, sel ast.SelectionSet, v *persist.EmailVerificationStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEoaAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐEoaAuth(ctx context.Context, v interface{}) (*model.EoaAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEoaAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGetAuthNoncePayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGetAuthNoncePayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.GetAuthNoncePayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GetAuthNoncePayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGnosisSafeAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGnosisSafeAuth(ctx context.Context, v interface{}) (*model.GnosisSafeAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGnosisSafeAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupNotificationUserEdge2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGroupNotificationUserEdge(ctx context.Context, sel ast.SelectionSet, v []*model.GroupNotificationUserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGroupNotificationUserEdge2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGroupNotificationUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGroupNotificationUserEdge2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐGroupNotificationUserEdge(ctx context.Context, sel ast.SelectionSet, v *model.GroupNotificationUserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupNotificationUserEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLoginPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐLoginPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.LoginPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoginPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOLogoutPayload2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐLogoutPayload(ctx context.Context, sel ast.SelectionSet, v *model.LogoutPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LogoutPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMagicLinkAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMagicLinkAuth(ctx context.Context, v interface{}) (*model.MagicLinkAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMagicLinkAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMediaDimensions2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐMediaDimensions(ctx context.Context, sel ast.SelectionSet, v *model.MediaDimensions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MediaDimensions(ctx, sel, v)
}

func (ec *executionContext) marshalONode2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNode(ctx context.Context, sel ast.SelectionSet, v model.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalONotification2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotification(ctx context.Context, sel ast.SelectionSet, v model.Notification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Notification(ctx, sel, v)
}

func (ec *executionContext) marshalONotification2ᚕgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotification(ctx context.Context, sel ast.SelectionSet, v []model.Notification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONotification2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONotificationEdge2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationEdge(ctx context.Context, sel ast.SelectionSet, v []*model.NotificationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONotificationEdge2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONotificationEdge2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationEdge(ctx context.Context, sel ast.SelectionSet, v *model.NotificationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotificationEdge(ctx, sel, v)
}

func (ec *executionContext) marshalONotificationSettings2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationSettings(ctx context.Context, sel ast.SelectionSet, v *model.NotificationSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotificationSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotificationSettingsInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationSettingsInput(ctx context.Context, v interface{}) (*model.NotificationSettingsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotificationSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotificationsConnection2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐNotificationsConnection(ctx context.Context, sel ast.SelectionSet, v *model.NotificationsConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotificationsConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOneTimeLoginTokenAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐOneTimeLoginTokenAuth(ctx context.Context, v interface{}) (*model.OneTimeLoginTokenAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOneTimeLoginTokenAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOptInForRolesPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐOptInForRolesPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.OptInForRolesPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OptInForRolesPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOOptOutForRolesPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐOptOutForRolesPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.OptOutForRolesPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OptOutForRolesPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOPageInfo2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOPreverifyEmailPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreverifyEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.PreverifyEmailPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PreverifyEmailPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOPreviewURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPreviewURLSet(ctx context.Context, sel ast.SelectionSet, v *model.PreviewURLSet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PreviewURLSet(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPrivyAuth2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPrivyAuth(ctx context.Context, v interface{}) (*model.PrivyAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPrivyAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPubKey2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐPubKey(ctx context.Context, v interface{}) (persist.PubKey, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.PubKey(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPubKey2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐPubKey(ctx context.Context, sel ast.SelectionSet, v persist.PubKey) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) marshalOPublishSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐPublishSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.PublishSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PublishSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalORecipient2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRecipient(ctx context.Context, sel ast.SelectionSet, v []*model.Recipient) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORecipient2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRecipient(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalORecipient2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRecipient(ctx context.Context, sel ast.SelectionSet, v *model.Recipient) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Recipient(ctx, sel, v)
}

func (ec *executionContext) marshalORegisterUserPushTokenPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRegisterUserPushTokenPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.RegisterUserPushTokenPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RegisterUserPushTokenPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalORemoveUserWalletsPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRemoveUserWalletsPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.RemoveUserWalletsPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RemoveUserWalletsPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOResendVerificationEmailPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐResendVerificationEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.ResendVerificationEmailPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResendVerificationEmailPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalORevokeRolesFromUserPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐRevokeRolesFromUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.RevokeRolesFromUserPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RevokeRolesFromUserPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalORole2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx context.Context, v interface{}) ([]*persist.Role, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*persist.Role, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalORole2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORole2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx context.Context, sel ast.SelectionSet, v []*persist.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORole2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalORole2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx context.Context, v interface{}) (*persist.Role, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(persist.Role)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORole2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐRole(ctx context.Context, sel ast.SelectionSet, v *persist.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSearchSplitsPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSearchSplitsPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SearchSplitsPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchSplitsPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSearchUsersPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSearchUsersPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SearchUsersPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchUsersPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSplit2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx context.Context, sel ast.SelectionSet, v []*model.Split) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplit(ctx context.Context, sel ast.SelectionSet, v *model.Split) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Split(ctx, sel, v)
}

func (ec *executionContext) marshalOSplitByIdPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitByIDPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SplitByIDPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SplitByIdPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSplitFiUser2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx context.Context, sel ast.SelectionSet, v []*model.SplitFiUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSplitFiUser2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitFiUser(ctx context.Context, sel ast.SelectionSet, v *model.SplitFiUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SplitFiUser(ctx, sel, v)
}

func (ec *executionContext) marshalOSplitSearchResult2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitSearchResultᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.SplitSearchResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSplitSearchResult2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐSplitSearchResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOToken2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐToken(ctx context.Context, sel ast.SelectionSet, v []*model.Token) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOToken2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐToken(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOToken2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐToken(ctx context.Context, sel ast.SelectionSet, v *model.Token) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Token(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTokenType2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐTokenType(ctx context.Context, v interface{}) (*model.TokenType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.TokenType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTokenType2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐTokenType(ctx context.Context, sel ast.SelectionSet, v *model.TokenType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOUnregisterUserPushTokenPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUnregisterUserPushTokenPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UnregisterUserPushTokenPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UnregisterUserPushTokenPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUnsubscribeFromEmailTypePayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUnsubscribeFromEmailTypePayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UnsubscribeFromEmailTypePayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UnsubscribeFromEmailTypePayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateEmailNotificationSettingsPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateEmailNotificationSettingsPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEmailNotificationSettingsPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateEmailNotificationSettingsPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateEmailPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEmailPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateEmailPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdatePrimaryWalletPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdatePrimaryWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdatePrimaryWalletPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdatePrimaryWalletPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitHiddenPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitHiddenPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitHiddenPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitHiddenPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitInfoPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitInfoPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitInfoPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitOrderPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitOrderPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitOrderPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitOrderPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateUserExperiencePayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateUserExperiencePayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateUserExperiencePayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateUserExperiencePayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateUserInfoPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUpdateUserInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateUserInfoPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateUserInfoPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUploadPersistedQueriesInput2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUploadPersistedQueriesInput(ctx context.Context, v interface{}) (*model.UploadPersistedQueriesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUploadPersistedQueriesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUploadPersistedQueriesPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUploadPersistedQueriesPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UploadPersistedQueriesPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UploadPersistedQueriesPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUserByAddressOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserByAddressOrError(ctx context.Context, sel ast.SelectionSet, v model.UserByAddressOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserByAddressOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUserByIdOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserByIDOrError(ctx context.Context, sel ast.SelectionSet, v model.UserByIDOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserByIdOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUserByUsernameOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserByUsernameOrError(ctx context.Context, sel ast.SelectionSet, v model.UserByUsernameOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserByUsernameOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUserEdge2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserEdge(ctx context.Context, sel ast.SelectionSet, v []*model.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserEdge2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUserEdge2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserEdge(ctx context.Context, sel ast.SelectionSet, v *model.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOUserEmail2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserEmail(ctx context.Context, sel ast.SelectionSet, v *model.UserEmail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserEmail(ctx, sel, v)
}

func (ec *executionContext) marshalOUserExperience2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserExperienceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.UserExperience) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserExperience2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserExperience(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUserSearchResult2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserSearchResultᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.UserSearchResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserSearchResult2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUserSearchResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUsersConnection2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐUsersConnection(ctx context.Context, sel ast.SelectionSet, v *model.UsersConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UsersConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOVerifyEmailMagicLinkPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVerifyEmailMagicLinkPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.VerifyEmailMagicLinkPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VerifyEmailMagicLinkPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOVerifyEmailPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVerifyEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.VerifyEmailPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VerifyEmailPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOVideoURLSet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐVideoURLSet(ctx context.Context, sel ast.SelectionSet, v *model.VideoURLSet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VideoURLSet(ctx, sel, v)
}

func (ec *executionContext) marshalOViewSplitPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.ViewSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ViewSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOViewer2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewer(ctx context.Context, sel ast.SelectionSet, v *model.Viewer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Viewer(ctx, sel, v)
}

func (ec *executionContext) marshalOViewerOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewerOrError(ctx context.Context, sel ast.SelectionSet, v model.ViewerOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ViewerOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOViewerSplit2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewerSplit(ctx context.Context, sel ast.SelectionSet, v []*model.ViewerSplit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOViewerSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewerSplit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOViewerSplit2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewerSplit(ctx context.Context, sel ast.SelectionSet, v *model.ViewerSplit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ViewerSplit(ctx, sel, v)
}

func (ec *executionContext) marshalOViewerSplitByIdPayloadOrError2githubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐViewerSplitByIDPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.ViewerSplitByIDPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ViewerSplitByIdPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOWallet2ᚕᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐWallet(ctx context.Context, sel ast.SelectionSet, v []*model.Wallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWallet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐWallet(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOWallet2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋgraphqlᚋmodelᚐWallet(ctx context.Context, sel ast.SelectionSet, v *model.Wallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Wallet(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWalletType2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐWalletType(ctx context.Context, v interface{}) (*persist.WalletType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(persist.WalletType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWalletType2ᚖgithubᚗcomᚋSplitFiᚋgoᚑsplitfiᚋserviceᚋpersistᚐWalletType(ctx context.Context, sel ast.SelectionSet, v *persist.WalletType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
