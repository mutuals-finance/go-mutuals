// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	"github.com/SplitFi/go-splitfi/graphql/model"
	"github.com/SplitFi/go-splitfi/service/persist"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Collection() CollectionResolver
	CollectionToken() CollectionTokenResolver
	Community() CommunityResolver
	FollowInfo() FollowInfoResolver
	FollowUserPayload() FollowUserPayloadResolver
	Mutation() MutationResolver
	OwnerAtBlock() OwnerAtBlockResolver
	PreviewURLSet() PreviewURLSetResolver
	Query() QueryResolver
	SetSpamPreferencePayload() SetSpamPreferencePayloadResolver
	SocialConnection() SocialConnectionResolver
	SocialQueries() SocialQueriesResolver
	SomeoneFollowedYouBackNotification() SomeoneFollowedYouBackNotificationResolver
	SomeoneFollowedYouNotification() SomeoneFollowedYouNotificationResolver
	SomeoneViewedYourSplitNotification() SomeoneViewedYourSplitNotificationResolver
	Split() SplitResolver
	SplitFiUser() SplitFiUserResolver
	Subscription() SubscriptionResolver
	Token() TokenResolver
	TokenHolder() TokenHolderResolver
	UnfollowUserPayload() UnfollowUserPayloadResolver
	Viewer() ViewerResolver
	Wallet() WalletResolver
	ChainAddressInput() ChainAddressInputResolver
	ChainPubKeyInput() ChainPubKeyInputResolver
}

type DirectiveRoot struct {
	AuthRequired        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	Experimental        func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	FrontendBuildAuth   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	RestrictEnvironment func(ctx context.Context, obj interface{}, next graphql.Resolver, allowed []string) (res interface{}, err error)
	RetoolAuth          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	AddUserWalletPayload struct {
		Viewer func(childComplexity int) int
	}

	AdminAddWalletPayload struct {
		User func(childComplexity int) int
	}

	AudioMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	AuthNonce struct {
		Nonce      func(childComplexity int) int
		UserExists func(childComplexity int) int
	}

	Badge struct {
		Contract func(childComplexity int) int
		ImageURL func(childComplexity int) int
		Name     func(childComplexity int) int
	}

	ChainAddress struct {
		Address func(childComplexity int) int
		Chain   func(childComplexity int) int
	}

	ChainPubKey struct {
		Chain  func(childComplexity int) int
		PubKey func(childComplexity int) int
	}

	ChainTokens struct {
		Chain  func(childComplexity int) int
		Tokens func(childComplexity int) int
	}

	ClearAllNotificationsPayload struct {
		Notifications func(childComplexity int) int
	}

	Collection struct {
		CollectorsNote func(childComplexity int) int
		Dbid           func(childComplexity int) int
		Hidden         func(childComplexity int) int
		ID             func(childComplexity int) int
		Layout         func(childComplexity int) int
		Name           func(childComplexity int) int
		Split          func(childComplexity int) int
		Tokens         func(childComplexity int, limit *int) int
		Version        func(childComplexity int) int
	}

	CollectionLayout struct {
		SectionLayout func(childComplexity int) int
		Sections      func(childComplexity int) int
	}

	CollectionSectionLayout struct {
		Columns    func(childComplexity int) int
		Whitespace func(childComplexity int) int
	}

	CollectionToken struct {
		Collection    func(childComplexity int) int
		ID            func(childComplexity int) int
		Token         func(childComplexity int) int
		TokenSettings func(childComplexity int) int
	}

	CollectionTokenSettings struct {
		RenderLive func(childComplexity int) int
	}

	CommunitiesConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	Community struct {
		BadgeURL          func(childComplexity int) int
		Chain             func(childComplexity int) int
		ContractAddress   func(childComplexity int) int
		CreatorAddress    func(childComplexity int) int
		Dbid              func(childComplexity int) int
		Description       func(childComplexity int) int
		ID                func(childComplexity int) int
		LastUpdated       func(childComplexity int) int
		Name              func(childComplexity int) int
		Owners            func(childComplexity int, before *string, after *string, first *int, last *int, onlySplitFiUsers *bool) int
		PreviewImage      func(childComplexity int) int
		ProfileBannerURL  func(childComplexity int) int
		ProfileImageURL   func(childComplexity int) int
		TokensInCommunity func(childComplexity int, before *string, after *string, first *int, last *int, onlySplitFiUsers *bool) int
	}

	CommunityEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CommunitySearchResult struct {
		Community func(childComplexity int) int
	}

	ConnectSocialAccountPayload struct {
		Viewer func(childComplexity int) int
	}

	Contract struct {
		BadgeURL         func(childComplexity int) int
		Chain            func(childComplexity int) int
		ContractAddress  func(childComplexity int) int
		CreatorAddress   func(childComplexity int) int
		Dbid             func(childComplexity int) int
		ID               func(childComplexity int) int
		LastUpdated      func(childComplexity int) int
		Name             func(childComplexity int) int
		ProfileBannerURL func(childComplexity int) int
		ProfileImageURL  func(childComplexity int) int
	}

	CreateCollectionPayload struct {
		Collection func(childComplexity int) int
	}

	CreateSplitPayload struct {
		Split func(childComplexity int) int
	}

	CreateUserPayload struct {
		SplitID func(childComplexity int) int
		UserID  func(childComplexity int) int
		Viewer  func(childComplexity int) int
	}

	DeepRefreshPayload struct {
		Chain     func(childComplexity int) int
		Submitted func(childComplexity int) int
	}

	DeleteCollectionPayload struct {
		Split func(childComplexity int) int
	}

	DeleteSplitPayload struct {
		DeletedID func(childComplexity int) int
	}

	DeletedNode struct {
		Dbid func(childComplexity int) int
		ID   func(childComplexity int) int
	}

	DisconnectSocialAccountPayload struct {
		Viewer func(childComplexity int) int
	}

	EmailNotificationSettings struct {
		UnsubscribedFromAll           func(childComplexity int) int
		UnsubscribedFromNotifications func(childComplexity int) int
	}

	ErrAddressOwnedByUser struct {
		Message func(childComplexity int) int
	}

	ErrAuthenticationFailed struct {
		Message func(childComplexity int) int
	}

	ErrCollectionNotFound struct {
		Message func(childComplexity int) int
	}

	ErrCommunityNotFound struct {
		Message func(childComplexity int) int
	}

	ErrDoesNotOwnRequiredToken struct {
		Message func(childComplexity int) int
	}

	ErrInvalidInput struct {
		Message    func(childComplexity int) int
		Parameters func(childComplexity int) int
		Reasons    func(childComplexity int) int
	}

	ErrInvalidToken struct {
		Message func(childComplexity int) int
	}

	ErrNeedsToReconnectSocial struct {
		Message           func(childComplexity int) int
		SocialAccountType func(childComplexity int) int
	}

	ErrNoCookie struct {
		Message func(childComplexity int) int
	}

	ErrNotAuthorized struct {
		Cause   func(childComplexity int) int
		Message func(childComplexity int) int
	}

	ErrSplitNotFound struct {
		Message func(childComplexity int) int
	}

	ErrSyncFailed struct {
		Message func(childComplexity int) int
	}

	ErrTokenNotFound struct {
		Message func(childComplexity int) int
	}

	ErrUserAlreadyExists struct {
		Message func(childComplexity int) int
	}

	ErrUserNotFound struct {
		Message func(childComplexity int) int
	}

	ErrUsernameNotAvailable struct {
		Message func(childComplexity int) int
	}

	FollowAllSocialConnectionsPayload struct {
		Viewer func(childComplexity int) int
	}

	FollowInfo struct {
		FollowedBack func(childComplexity int) int
		User         func(childComplexity int) int
	}

	FollowUserPayload struct {
		User   func(childComplexity int) int
		Viewer func(childComplexity int) int
	}

	GIFMedia struct {
		ContentRenderURL  func(childComplexity int) int
		Dimensions        func(childComplexity int) int
		MediaType         func(childComplexity int) int
		MediaURL          func(childComplexity int) int
		PreviewURLs       func(childComplexity int) int
		StaticPreviewURLs func(childComplexity int) int
	}

	GltfMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	GroupNotificationUserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	GroupNotificationUsersConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	HtmlMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	ImageMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	InvalidMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	JsonMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	LoginPayload struct {
		UserID func(childComplexity int) int
		Viewer func(childComplexity int) int
	}

	LogoutPayload struct {
		Viewer func(childComplexity int) int
	}

	MediaDimensions struct {
		AspectRatio func(childComplexity int) int
		Height      func(childComplexity int) int
		Width       func(childComplexity int) int
	}

	MembershipTier struct {
		AssetURL func(childComplexity int) int
		Dbid     func(childComplexity int) int
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Owners   func(childComplexity int) int
		TokenID  func(childComplexity int) int
	}

	MintPremiumCardToWalletPayload struct {
		Tx func(childComplexity int) int
	}

	MoveCollectionToSplitPayload struct {
		NewSplit func(childComplexity int) int
		OldSplit func(childComplexity int) int
	}

	Mutation struct {
		AddRolesToUser                  func(childComplexity int, username string, roles []*persist.Role) int
		AddUserWallet                   func(childComplexity int, chainAddress persist.ChainAddress, authMechanism model.AuthMechanism) int
		AddWalletToUserUnchecked        func(childComplexity int, input model.AdminAddWalletInput) int
		ClearAllNotifications           func(childComplexity int) int
		ConnectSocialAccount            func(childComplexity int, input model.SocialAuthMechanism, display bool) int
		CreateCollection                func(childComplexity int, input model.CreateCollectionInput) int
		CreateSplit                     func(childComplexity int, input model.CreateSplitInput) int
		CreateUser                      func(childComplexity int, authMechanism model.AuthMechanism, input model.CreateUserInput) int
		DeepRefresh                     func(childComplexity int, input model.DeepRefreshInput) int
		DeleteCollection                func(childComplexity int, collectionID persist.DBID) int
		DeleteSplit                     func(childComplexity int, splitID persist.DBID) int
		DisconnectSocialAccount         func(childComplexity int, accountType persist.SocialProvider) int
		FollowAllSocialConnections      func(childComplexity int, accountType persist.SocialProvider) int
		FollowUser                      func(childComplexity int, userID persist.DBID) int
		GetAuthNonce                    func(childComplexity int, chainAddress persist.ChainAddress) int
		Login                           func(childComplexity int, authMechanism model.AuthMechanism) int
		Logout                          func(childComplexity int) int
		MintPremiumCardToWallet         func(childComplexity int, input model.MintPremiumCardToWalletInput) int
		MoveCollectionToSplit           func(childComplexity int, input *model.MoveCollectionToSplitInput) int
		PreverifyEmail                  func(childComplexity int, input model.PreverifyEmailInput) int
		PublishSplit                    func(childComplexity int, input model.PublishSplitInput) int
		RefreshCollection               func(childComplexity int, collectionID persist.DBID) int
		RefreshContract                 func(childComplexity int, contractID persist.DBID) int
		RefreshToken                    func(childComplexity int, tokenID persist.DBID) int
		RemoveUserWallets               func(childComplexity int, walletIds []persist.DBID) int
		ResendVerificationEmail         func(childComplexity int) int
		RevokeRolesFromUser             func(childComplexity int, username string, roles []*persist.Role) int
		SetSpamPreference               func(childComplexity int, input model.SetSpamPreferenceInput) int
		SyncTokens                      func(childComplexity int, chains []persist.Chain) int
		SyncTokensForUsername           func(childComplexity int, username string, chains []persist.Chain) int
		UnfollowUser                    func(childComplexity int, userID persist.DBID) int
		UnsubscribeFromEmailType        func(childComplexity int, input model.UnsubscribeFromEmailTypeInput) int
		UpdateCollectionHidden          func(childComplexity int, input model.UpdateCollectionHiddenInput) int
		UpdateCollectionInfo            func(childComplexity int, input model.UpdateCollectionInfoInput) int
		UpdateCollectionTokens          func(childComplexity int, input model.UpdateCollectionTokensInput) int
		UpdateEmail                     func(childComplexity int, input model.UpdateEmailInput) int
		UpdateEmailNotificationSettings func(childComplexity int, input model.UpdateEmailNotificationSettingsInput) int
		UpdateFeaturedSplit             func(childComplexity int, splitID persist.DBID) int
		UpdateNotificationSettings      func(childComplexity int, settings *model.NotificationSettingsInput) int
		UpdatePrimaryWallet             func(childComplexity int, walletID persist.DBID) int
		UpdateSocialAccountDisplayed    func(childComplexity int, input model.UpdateSocialAccountDisplayedInput) int
		UpdateSplit                     func(childComplexity int, input model.UpdateSplitInput) int
		UpdateSplitCollections          func(childComplexity int, input model.UpdateSplitCollectionsInput) int
		UpdateSplitHidden               func(childComplexity int, input model.UpdateSplitHiddenInput) int
		UpdateSplitInfo                 func(childComplexity int, input model.UpdateSplitInfoInput) int
		UpdateSplitOrder                func(childComplexity int, input model.UpdateSplitOrderInput) int
		UpdateTokenInfo                 func(childComplexity int, input model.UpdateTokenInfoInput) int
		UpdateUserExperience            func(childComplexity int, input model.UpdateUserExperienceInput) int
		UpdateUserInfo                  func(childComplexity int, input model.UpdateUserInfoInput) int
		UploadPersistedQueries          func(childComplexity int, input *model.UploadPersistedQueriesInput) int
		VerifyEmail                     func(childComplexity int, input model.VerifyEmailInput) int
		ViewSplit                       func(childComplexity int, splitID persist.DBID) int
	}

	NotificationEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	NotificationSettings struct {
		SomeoneFollowedYou     func(childComplexity int) int
		SomeoneViewedYourSplit func(childComplexity int) int
	}

	NotificationsConnection struct {
		Edges       func(childComplexity int) int
		PageInfo    func(childComplexity int) int
		UnseenCount func(childComplexity int) int
	}

	OwnerAtBlock struct {
		BlockNumber func(childComplexity int) int
		Owner       func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		Size            func(childComplexity int) int
		StartCursor     func(childComplexity int) int
		Total           func(childComplexity int) int
	}

	PdfMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	PreverifyEmailPayload struct {
		Email  func(childComplexity int) int
		Result func(childComplexity int) int
	}

	PreviewURLSet struct {
		Blurhash   func(childComplexity int) int
		Large      func(childComplexity int) int
		LiveRender func(childComplexity int) int
		Medium     func(childComplexity int) int
		Raw        func(childComplexity int) int
		Small      func(childComplexity int) int
		SrcSet     func(childComplexity int) int
		Thumbnail  func(childComplexity int) int
	}

	PublishSplitPayload struct {
		Split func(childComplexity int) int
	}

	Query struct {
		CollectionByID      func(childComplexity int, id persist.DBID) int
		CollectionTokenByID func(childComplexity int, tokenID persist.DBID, collectionID persist.DBID) int
		CollectionsByIds    func(childComplexity int, ids []persist.DBID) int
		CommunityByAddress  func(childComplexity int, communityAddress persist.ChainAddress, forceRefresh *bool) int
		GeneralAllowlist    func(childComplexity int) int
		MembershipTiers     func(childComplexity int, forceRefresh *bool) int
		Node                func(childComplexity int, id model.GqlID) int
		SearchCommunities   func(childComplexity int, query string, limit *int, nameWeight *float64, descriptionWeight *float64, poapAddressWeight *float64) int
		SearchSplits        func(childComplexity int, query string, limit *int, nameWeight *float64, descriptionWeight *float64) int
		SearchUsers         func(childComplexity int, query string, limit *int, usernameWeight *float64, bioWeight *float64) int
		SocialConnections   func(childComplexity int, socialAccountType persist.SocialProvider, excludeAlreadyFollowing *bool, before *string, after *string, first *int, last *int) int
		SocialQueries       func(childComplexity int) int
		SplitByID           func(childComplexity int, id persist.DBID) int
		TokenByID           func(childComplexity int, id persist.DBID) int
		UserByAddress       func(childComplexity int, chainAddress persist.ChainAddress) int
		UserByID            func(childComplexity int, id persist.DBID) int
		UserByUsername      func(childComplexity int, username string) int
		UsersByRole         func(childComplexity int, role persist.Role, before *string, after *string, first *int, last *int) int
		UsersWithTrait      func(childComplexity int, trait string) int
		Viewer              func(childComplexity int) int
		ViewerSplitByID     func(childComplexity int, id persist.DBID) int
		__resolve__service  func(childComplexity int) int
	}

	RefreshCollectionPayload struct {
		Collection func(childComplexity int) int
	}

	RefreshContractPayload struct {
		Contract func(childComplexity int) int
	}

	RefreshTokenPayload struct {
		Token func(childComplexity int) int
	}

	RemoveUserWalletsPayload struct {
		Viewer func(childComplexity int) int
	}

	ResendVerificationEmailPayload struct {
		Viewer func(childComplexity int) int
	}

	SearchCommunitiesPayload struct {
		Results func(childComplexity int) int
	}

	SearchSplitsPayload struct {
		Results func(childComplexity int) int
	}

	SearchUsersPayload struct {
		Results func(childComplexity int) int
	}

	SetSpamPreferencePayload struct {
		Tokens func(childComplexity int) int
	}

	SocialAccounts struct {
		Twitter func(childComplexity int) int
	}

	SocialConnection struct {
		CurrentlyFollowing func(childComplexity int) int
		DisplayName        func(childComplexity int) int
		ID                 func(childComplexity int) int
		ProfileImage       func(childComplexity int) int
		SocialID           func(childComplexity int) int
		SocialType         func(childComplexity int) int
		SocialUsername     func(childComplexity int) int
		SplitFiUser        func(childComplexity int) int
	}

	SocialConnectionsConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	SocialConnectionsEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SocialQueries struct {
		SocialConnections func(childComplexity int, socialAccountType persist.SocialProvider, excludeAlreadyFollowing *bool, before *string, after *string, first *int, last *int) int
	}

	SomeoneFollowedYouBackNotification struct {
		Count        func(childComplexity int) int
		CreationTime func(childComplexity int) int
		Dbid         func(childComplexity int) int
		Followers    func(childComplexity int, before *string, after *string, first *int, last *int) int
		ID           func(childComplexity int) int
		Seen         func(childComplexity int) int
		UpdatedTime  func(childComplexity int) int
	}

	SomeoneFollowedYouNotification struct {
		Count        func(childComplexity int) int
		CreationTime func(childComplexity int) int
		Dbid         func(childComplexity int) int
		Followers    func(childComplexity int, before *string, after *string, first *int, last *int) int
		ID           func(childComplexity int) int
		Seen         func(childComplexity int) int
		UpdatedTime  func(childComplexity int) int
	}

	SomeoneViewedYourSplitNotification struct {
		Count              func(childComplexity int) int
		CreationTime       func(childComplexity int) int
		Dbid               func(childComplexity int) int
		ID                 func(childComplexity int) int
		NonUserViewerCount func(childComplexity int) int
		Seen               func(childComplexity int) int
		Split              func(childComplexity int) int
		UpdatedTime        func(childComplexity int) int
		UserViewers        func(childComplexity int, before *string, after *string, first *int, last *int) int
	}

	Split struct {
		Collections   func(childComplexity int) int
		Dbid          func(childComplexity int) int
		Description   func(childComplexity int) int
		Hidden        func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Owner         func(childComplexity int) int
		Position      func(childComplexity int) int
		TokenPreviews func(childComplexity int) int
	}

	SplitFiUser struct {
		Badges              func(childComplexity int) int
		Bio                 func(childComplexity int) int
		Dbid                func(childComplexity int) int
		FeaturedSplit       func(childComplexity int) int
		Followers           func(childComplexity int) int
		Following           func(childComplexity int) int
		ID                  func(childComplexity int) int
		IsAuthenticatedUser func(childComplexity int) int
		PrimaryWallet       func(childComplexity int) int
		Roles               func(childComplexity int) int
		SharedCommunities   func(childComplexity int, before *string, after *string, first *int, last *int) int
		SharedFollowers     func(childComplexity int, before *string, after *string, first *int, last *int) int
		SocialAccounts      func(childComplexity int) int
		Splits              func(childComplexity int) int
		Tokens              func(childComplexity int) int
		TokensByChain       func(childComplexity int, chain persist.Chain) int
		Traits              func(childComplexity int) int
		Universal           func(childComplexity int) int
		Username            func(childComplexity int) int
		Wallets             func(childComplexity int) int
	}

	SplitSearchResult struct {
		Split func(childComplexity int) int
	}

	Subscription struct {
		NewNotification     func(childComplexity int) int
		NotificationUpdated func(childComplexity int) int
	}

	SyncTokensForUsernamePayload struct {
		Message func(childComplexity int) int
	}

	SyncTokensPayload struct {
		Viewer func(childComplexity int) int
	}

	SyncingMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	TextMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	Token struct {
		BlockNumber      func(childComplexity int) int
		Chain            func(childComplexity int) int
		CollectorsNote   func(childComplexity int) int
		Contract         func(childComplexity int) int
		CreationTime     func(childComplexity int) int
		CreatorAddress   func(childComplexity int) int
		Dbid             func(childComplexity int) int
		Description      func(childComplexity int) int
		ExternalURL      func(childComplexity int) int
		ID               func(childComplexity int) int
		IsSpamByProvider func(childComplexity int) int
		IsSpamByUser     func(childComplexity int) int
		LastUpdated      func(childComplexity int) int
		Media            func(childComplexity int) int
		Name             func(childComplexity int) int
		OwnedByWallets   func(childComplexity int) int
		Owner            func(childComplexity int) int
		OwnershipHistory func(childComplexity int) int
		Quantity         func(childComplexity int) int
		TokenID          func(childComplexity int) int
		TokenMetadata    func(childComplexity int) int
		TokenType        func(childComplexity int) int
	}

	TokenEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TokenHolder struct {
		DisplayName   func(childComplexity int) int
		PreviewTokens func(childComplexity int) int
		User          func(childComplexity int) int
		Wallets       func(childComplexity int) int
	}

	TokenHolderEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TokenHoldersConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	TokensConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	TwitterSocialAccount struct {
		Display         func(childComplexity int) int
		Name            func(childComplexity int) int
		ProfileImageURL func(childComplexity int) int
		SocialID        func(childComplexity int) int
		Type            func(childComplexity int) int
		Username        func(childComplexity int) int
	}

	UnfollowUserPayload struct {
		User   func(childComplexity int) int
		Viewer func(childComplexity int) int
	}

	UnknownMedia struct {
		ContentRenderURL func(childComplexity int) int
		Dimensions       func(childComplexity int) int
		MediaType        func(childComplexity int) int
		MediaURL         func(childComplexity int) int
		PreviewURLs      func(childComplexity int) int
	}

	UnsubscribeFromEmailTypePayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateCollectionHiddenPayload struct {
		Collection func(childComplexity int) int
	}

	UpdateCollectionInfoPayload struct {
		Collection func(childComplexity int) int
	}

	UpdateCollectionTokensPayload struct {
		Collection func(childComplexity int) int
	}

	UpdateEmailNotificationSettingsPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateEmailPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateFeaturedSplitPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdatePrimaryWalletPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateSocialAccountDisplayedPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateSplitCollectionsPayload struct {
		Split func(childComplexity int) int
	}

	UpdateSplitHiddenPayload struct {
		Split func(childComplexity int) int
	}

	UpdateSplitInfoPayload struct {
		Split func(childComplexity int) int
	}

	UpdateSplitOrderPayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateSplitPayload struct {
		Split func(childComplexity int) int
	}

	UpdateTokenInfoPayload struct {
		Token func(childComplexity int) int
	}

	UpdateUserExperiencePayload struct {
		Viewer func(childComplexity int) int
	}

	UpdateUserInfoPayload struct {
		Viewer func(childComplexity int) int
	}

	UploadPersistedQueriesPayload struct {
		Message func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserEmail struct {
		Email                     func(childComplexity int) int
		EmailNotificationSettings func(childComplexity int) int
		VerificationStatus        func(childComplexity int) int
	}

	UserExperience struct {
		Experienced func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	UserSearchResult struct {
		User func(childComplexity int) int
	}

	UsersConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	VerifyEmailPayload struct {
		Email func(childComplexity int) int
	}

	VideoMedia struct {
		ContentRenderURLs func(childComplexity int) int
		Dimensions        func(childComplexity int) int
		MediaType         func(childComplexity int) int
		MediaURL          func(childComplexity int) int
		PreviewURLs       func(childComplexity int) int
	}

	VideoURLSet struct {
		Large  func(childComplexity int) int
		Medium func(childComplexity int) int
		Raw    func(childComplexity int) int
		Small  func(childComplexity int) int
	}

	ViewSplitPayload struct {
		Split func(childComplexity int) int
	}

	Viewer struct {
		Email                func(childComplexity int) int
		ID                   func(childComplexity int) int
		NotificationSettings func(childComplexity int) int
		Notifications        func(childComplexity int, before *string, after *string, first *int, last *int) int
		SocialAccounts       func(childComplexity int) int
		User                 func(childComplexity int) int
		UserExperiences      func(childComplexity int) int
		ViewerSplits         func(childComplexity int) int
	}

	ViewerSplit struct {
		Split func(childComplexity int) int
	}

	Wallet struct {
		Chain        func(childComplexity int) int
		ChainAddress func(childComplexity int) int
		Dbid         func(childComplexity int) int
		ID           func(childComplexity int) int
		Tokens       func(childComplexity int) int
		WalletType   func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type CollectionResolver interface {
	Split(ctx context.Context, obj *model.Collection) (*model.Split, error)

	Tokens(ctx context.Context, obj *model.Collection, limit *int) ([]*model.CollectionToken, error)
}
type CollectionTokenResolver interface {
	Token(ctx context.Context, obj *model.CollectionToken) (*model.Token, error)
	Collection(ctx context.Context, obj *model.CollectionToken) (*model.Collection, error)
	TokenSettings(ctx context.Context, obj *model.CollectionToken) (*model.CollectionTokenSettings, error)
}
type CommunityResolver interface {
	TokensInCommunity(ctx context.Context, obj *model.Community, before *string, after *string, first *int, last *int, onlySplitFiUsers *bool) (*model.TokensConnection, error)
	Owners(ctx context.Context, obj *model.Community, before *string, after *string, first *int, last *int, onlySplitFiUsers *bool) (*model.TokenHoldersConnection, error)
}
type FollowInfoResolver interface {
	User(ctx context.Context, obj *model.FollowInfo) (*model.SplitFiUser, error)
}
type FollowUserPayloadResolver interface {
	User(ctx context.Context, obj *model.FollowUserPayload) (*model.SplitFiUser, error)
}
type MutationResolver interface {
	AddUserWallet(ctx context.Context, chainAddress persist.ChainAddress, authMechanism model.AuthMechanism) (model.AddUserWalletPayloadOrError, error)
	RemoveUserWallets(ctx context.Context, walletIds []persist.DBID) (model.RemoveUserWalletsPayloadOrError, error)
	UpdateUserInfo(ctx context.Context, input model.UpdateUserInfoInput) (model.UpdateUserInfoPayloadOrError, error)
	UpdateSplitCollections(ctx context.Context, input model.UpdateSplitCollectionsInput) (model.UpdateSplitCollectionsPayloadOrError, error)
	CreateCollection(ctx context.Context, input model.CreateCollectionInput) (model.CreateCollectionPayloadOrError, error)
	DeleteCollection(ctx context.Context, collectionID persist.DBID) (model.DeleteCollectionPayloadOrError, error)
	UpdateCollectionInfo(ctx context.Context, input model.UpdateCollectionInfoInput) (model.UpdateCollectionInfoPayloadOrError, error)
	UpdateCollectionTokens(ctx context.Context, input model.UpdateCollectionTokensInput) (model.UpdateCollectionTokensPayloadOrError, error)
	UpdateCollectionHidden(ctx context.Context, input model.UpdateCollectionHiddenInput) (model.UpdateCollectionHiddenPayloadOrError, error)
	UpdateTokenInfo(ctx context.Context, input model.UpdateTokenInfoInput) (model.UpdateTokenInfoPayloadOrError, error)
	SetSpamPreference(ctx context.Context, input model.SetSpamPreferenceInput) (model.SetSpamPreferencePayloadOrError, error)
	SyncTokens(ctx context.Context, chains []persist.Chain) (model.SyncTokensPayloadOrError, error)
	RefreshToken(ctx context.Context, tokenID persist.DBID) (model.RefreshTokenPayloadOrError, error)
	RefreshCollection(ctx context.Context, collectionID persist.DBID) (model.RefreshCollectionPayloadOrError, error)
	RefreshContract(ctx context.Context, contractID persist.DBID) (model.RefreshContractPayloadOrError, error)
	DeepRefresh(ctx context.Context, input model.DeepRefreshInput) (model.DeepRefreshPayloadOrError, error)
	GetAuthNonce(ctx context.Context, chainAddress persist.ChainAddress) (model.GetAuthNoncePayloadOrError, error)
	CreateUser(ctx context.Context, authMechanism model.AuthMechanism, input model.CreateUserInput) (model.CreateUserPayloadOrError, error)
	UpdateEmail(ctx context.Context, input model.UpdateEmailInput) (model.UpdateEmailPayloadOrError, error)
	ResendVerificationEmail(ctx context.Context) (model.ResendVerificationEmailPayloadOrError, error)
	UpdateEmailNotificationSettings(ctx context.Context, input model.UpdateEmailNotificationSettingsInput) (model.UpdateEmailNotificationSettingsPayloadOrError, error)
	UnsubscribeFromEmailType(ctx context.Context, input model.UnsubscribeFromEmailTypeInput) (model.UnsubscribeFromEmailTypePayloadOrError, error)
	Login(ctx context.Context, authMechanism model.AuthMechanism) (model.LoginPayloadOrError, error)
	Logout(ctx context.Context) (*model.LogoutPayload, error)
	ConnectSocialAccount(ctx context.Context, input model.SocialAuthMechanism, display bool) (model.ConnectSocialAccountPayloadOrError, error)
	DisconnectSocialAccount(ctx context.Context, accountType persist.SocialProvider) (model.DisconnectSocialAccountPayloadOrError, error)
	UpdateSocialAccountDisplayed(ctx context.Context, input model.UpdateSocialAccountDisplayedInput) (model.UpdateSocialAccountDisplayedPayloadOrError, error)
	FollowUser(ctx context.Context, userID persist.DBID) (model.FollowUserPayloadOrError, error)
	FollowAllSocialConnections(ctx context.Context, accountType persist.SocialProvider) (model.FollowAllSocialConnectionsPayloadOrError, error)
	UnfollowUser(ctx context.Context, userID persist.DBID) (model.UnfollowUserPayloadOrError, error)
	ViewSplit(ctx context.Context, splitID persist.DBID) (model.ViewSplitPayloadOrError, error)
	UpdateSplit(ctx context.Context, input model.UpdateSplitInput) (model.UpdateSplitPayloadOrError, error)
	PublishSplit(ctx context.Context, input model.PublishSplitInput) (model.PublishSplitPayloadOrError, error)
	CreateSplit(ctx context.Context, input model.CreateSplitInput) (model.CreateSplitPayloadOrError, error)
	UpdateSplitHidden(ctx context.Context, input model.UpdateSplitHiddenInput) (model.UpdateSplitHiddenPayloadOrError, error)
	DeleteSplit(ctx context.Context, splitID persist.DBID) (model.DeleteSplitPayloadOrError, error)
	UpdateSplitOrder(ctx context.Context, input model.UpdateSplitOrderInput) (model.UpdateSplitOrderPayloadOrError, error)
	UpdateSplitInfo(ctx context.Context, input model.UpdateSplitInfoInput) (model.UpdateSplitInfoPayloadOrError, error)
	UpdateFeaturedSplit(ctx context.Context, splitID persist.DBID) (model.UpdateFeaturedSplitPayloadOrError, error)
	ClearAllNotifications(ctx context.Context) (*model.ClearAllNotificationsPayload, error)
	UpdateNotificationSettings(ctx context.Context, settings *model.NotificationSettingsInput) (*model.NotificationSettings, error)
	PreverifyEmail(ctx context.Context, input model.PreverifyEmailInput) (model.PreverifyEmailPayloadOrError, error)
	VerifyEmail(ctx context.Context, input model.VerifyEmailInput) (model.VerifyEmailPayloadOrError, error)
	AddRolesToUser(ctx context.Context, username string, roles []*persist.Role) (model.AddRolesToUserPayloadOrError, error)
	AddWalletToUserUnchecked(ctx context.Context, input model.AdminAddWalletInput) (model.AdminAddWalletPayloadOrError, error)
	RevokeRolesFromUser(ctx context.Context, username string, roles []*persist.Role) (model.RevokeRolesFromUserPayloadOrError, error)
	SyncTokensForUsername(ctx context.Context, username string, chains []persist.Chain) (model.SyncTokensForUsernamePayloadOrError, error)
	MintPremiumCardToWallet(ctx context.Context, input model.MintPremiumCardToWalletInput) (model.MintPremiumCardToWalletPayloadOrError, error)
	UploadPersistedQueries(ctx context.Context, input *model.UploadPersistedQueriesInput) (model.UploadPersistedQueriesPayloadOrError, error)
	UpdatePrimaryWallet(ctx context.Context, walletID persist.DBID) (model.UpdatePrimaryWalletPayloadOrError, error)
	UpdateUserExperience(ctx context.Context, input model.UpdateUserExperienceInput) (model.UpdateUserExperiencePayloadOrError, error)
	MoveCollectionToSplit(ctx context.Context, input *model.MoveCollectionToSplitInput) (model.MoveCollectionToSplitPayloadOrError, error)
}
type OwnerAtBlockResolver interface {
	Owner(ctx context.Context, obj *model.OwnerAtBlock) (model.SplitFiUserOrAddress, error)
}
type PreviewURLSetResolver interface {
	Blurhash(ctx context.Context, obj *model.PreviewURLSet) (*string, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id model.GqlID) (model.Node, error)
	Viewer(ctx context.Context) (model.ViewerOrError, error)
	UserByUsername(ctx context.Context, username string) (model.UserByUsernameOrError, error)
	UserByID(ctx context.Context, id persist.DBID) (model.UserByIDOrError, error)
	UserByAddress(ctx context.Context, chainAddress persist.ChainAddress) (model.UserByAddressOrError, error)
	UsersWithTrait(ctx context.Context, trait string) ([]*model.SplitFiUser, error)
	MembershipTiers(ctx context.Context, forceRefresh *bool) ([]*model.MembershipTier, error)
	CollectionByID(ctx context.Context, id persist.DBID) (model.CollectionByIDOrError, error)
	CollectionsByIds(ctx context.Context, ids []persist.DBID) ([]model.CollectionByIDOrError, error)
	TokenByID(ctx context.Context, id persist.DBID) (model.TokenByIDOrError, error)
	CollectionTokenByID(ctx context.Context, tokenID persist.DBID, collectionID persist.DBID) (model.CollectionTokenByIDOrError, error)
	CommunityByAddress(ctx context.Context, communityAddress persist.ChainAddress, forceRefresh *bool) (model.CommunityByAddressOrError, error)
	GeneralAllowlist(ctx context.Context) ([]*persist.ChainAddress, error)
	SplitByID(ctx context.Context, id persist.DBID) (model.SplitByIDPayloadOrError, error)
	ViewerSplitByID(ctx context.Context, id persist.DBID) (model.ViewerSplitByIDPayloadOrError, error)
	SearchUsers(ctx context.Context, query string, limit *int, usernameWeight *float64, bioWeight *float64) (model.SearchUsersPayloadOrError, error)
	SearchSplits(ctx context.Context, query string, limit *int, nameWeight *float64, descriptionWeight *float64) (model.SearchSplitsPayloadOrError, error)
	SearchCommunities(ctx context.Context, query string, limit *int, nameWeight *float64, descriptionWeight *float64, poapAddressWeight *float64) (model.SearchCommunitiesPayloadOrError, error)
	UsersByRole(ctx context.Context, role persist.Role, before *string, after *string, first *int, last *int) (*model.UsersConnection, error)
	SocialConnections(ctx context.Context, socialAccountType persist.SocialProvider, excludeAlreadyFollowing *bool, before *string, after *string, first *int, last *int) (*model.SocialConnectionsConnection, error)
	SocialQueries(ctx context.Context) (model.SocialQueriesOrError, error)
}
type SetSpamPreferencePayloadResolver interface {
	Tokens(ctx context.Context, obj *model.SetSpamPreferencePayload) ([]*model.Token, error)
}
type SocialConnectionResolver interface {
	SplitFiUser(ctx context.Context, obj *model.SocialConnection) (*model.SplitFiUser, error)
}
type SocialQueriesResolver interface {
	SocialConnections(ctx context.Context, obj *model.SocialQueries, socialAccountType persist.SocialProvider, excludeAlreadyFollowing *bool, before *string, after *string, first *int, last *int) (*model.SocialConnectionsConnection, error)
}
type SomeoneFollowedYouBackNotificationResolver interface {
	Followers(ctx context.Context, obj *model.SomeoneFollowedYouBackNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error)
}
type SomeoneFollowedYouNotificationResolver interface {
	Followers(ctx context.Context, obj *model.SomeoneFollowedYouNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error)
}
type SomeoneViewedYourSplitNotificationResolver interface {
	UserViewers(ctx context.Context, obj *model.SomeoneViewedYourSplitNotification, before *string, after *string, first *int, last *int) (*model.GroupNotificationUsersConnection, error)

	Split(ctx context.Context, obj *model.SomeoneViewedYourSplitNotification) (*model.Split, error)
}
type SplitResolver interface {
	TokenPreviews(ctx context.Context, obj *model.Split) ([]*model.PreviewURLSet, error)
	Owner(ctx context.Context, obj *model.Split) (*model.SplitFiUser, error)
	Collections(ctx context.Context, obj *model.Split) ([]*model.Collection, error)
}
type SplitFiUserResolver interface {
	Roles(ctx context.Context, obj *model.SplitFiUser) ([]*persist.Role, error)
	SocialAccounts(ctx context.Context, obj *model.SplitFiUser) (*model.SocialAccounts, error)
	Tokens(ctx context.Context, obj *model.SplitFiUser) ([]*model.Token, error)
	TokensByChain(ctx context.Context, obj *model.SplitFiUser, chain persist.Chain) (*model.ChainTokens, error)
	Wallets(ctx context.Context, obj *model.SplitFiUser) ([]*model.Wallet, error)
	PrimaryWallet(ctx context.Context, obj *model.SplitFiUser) (*model.Wallet, error)
	FeaturedSplit(ctx context.Context, obj *model.SplitFiUser) (*model.Split, error)
	Splits(ctx context.Context, obj *model.SplitFiUser) ([]*model.Split, error)
	Badges(ctx context.Context, obj *model.SplitFiUser) ([]*model.Badge, error)

	Followers(ctx context.Context, obj *model.SplitFiUser) ([]*model.SplitFiUser, error)
	Following(ctx context.Context, obj *model.SplitFiUser) ([]*model.SplitFiUser, error)
	SharedFollowers(ctx context.Context, obj *model.SplitFiUser, before *string, after *string, first *int, last *int) (*model.UsersConnection, error)
	SharedCommunities(ctx context.Context, obj *model.SplitFiUser, before *string, after *string, first *int, last *int) (*model.CommunitiesConnection, error)
}
type SubscriptionResolver interface {
	NewNotification(ctx context.Context) (<-chan model.Notification, error)
	NotificationUpdated(ctx context.Context) (<-chan model.Notification, error)
}
type TokenResolver interface {
	Owner(ctx context.Context, obj *model.Token) (*model.SplitFiUser, error)
	OwnedByWallets(ctx context.Context, obj *model.Token) ([]*model.Wallet, error)

	Contract(ctx context.Context, obj *model.Token) (*model.Contract, error)
}
type TokenHolderResolver interface {
	Wallets(ctx context.Context, obj *model.TokenHolder) ([]*model.Wallet, error)
	User(ctx context.Context, obj *model.TokenHolder) (*model.SplitFiUser, error)
}
type UnfollowUserPayloadResolver interface {
	User(ctx context.Context, obj *model.UnfollowUserPayload) (*model.SplitFiUser, error)
}
type ViewerResolver interface {
	User(ctx context.Context, obj *model.Viewer) (*model.SplitFiUser, error)
	SocialAccounts(ctx context.Context, obj *model.Viewer) (*model.SocialAccounts, error)
	ViewerSplits(ctx context.Context, obj *model.Viewer) ([]*model.ViewerSplit, error)
	Email(ctx context.Context, obj *model.Viewer) (*model.UserEmail, error)
	Notifications(ctx context.Context, obj *model.Viewer, before *string, after *string, first *int, last *int) (*model.NotificationsConnection, error)
	NotificationSettings(ctx context.Context, obj *model.Viewer) (*model.NotificationSettings, error)
	UserExperiences(ctx context.Context, obj *model.Viewer) ([]*model.UserExperience, error)
}
type WalletResolver interface {
	Tokens(ctx context.Context, obj *model.Wallet) ([]*model.Token, error)
}

type ChainAddressInputResolver interface {
	Address(ctx context.Context, obj *persist.ChainAddress, data persist.Address) error
	Chain(ctx context.Context, obj *persist.ChainAddress, data persist.Chain) error
}
type ChainPubKeyInputResolver interface {
	PubKey(ctx context.Context, obj *persist.ChainPubKey, data persist.PubKey) error
	Chain(ctx context.Context, obj *persist.ChainPubKey, data persist.Chain) error
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AddUserWalletPayload.viewer":
		if e.complexity.AddUserWalletPayload.Viewer == nil {
			break
		}

		return e.complexity.AddUserWalletPayload.Viewer(childComplexity), true

	case "AdminAddWalletPayload.user":
		if e.complexity.AdminAddWalletPayload.User == nil {
			break
		}

		return e.complexity.AdminAddWalletPayload.User(childComplexity), true

	case "AudioMedia.contentRenderURL":
		if e.complexity.AudioMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.AudioMedia.ContentRenderURL(childComplexity), true

	case "AudioMedia.dimensions":
		if e.complexity.AudioMedia.Dimensions == nil {
			break
		}

		return e.complexity.AudioMedia.Dimensions(childComplexity), true

	case "AudioMedia.mediaType":
		if e.complexity.AudioMedia.MediaType == nil {
			break
		}

		return e.complexity.AudioMedia.MediaType(childComplexity), true

	case "AudioMedia.mediaURL":
		if e.complexity.AudioMedia.MediaURL == nil {
			break
		}

		return e.complexity.AudioMedia.MediaURL(childComplexity), true

	case "AudioMedia.previewURLs":
		if e.complexity.AudioMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.AudioMedia.PreviewURLs(childComplexity), true

	case "AuthNonce.nonce":
		if e.complexity.AuthNonce.Nonce == nil {
			break
		}

		return e.complexity.AuthNonce.Nonce(childComplexity), true

	case "AuthNonce.userExists":
		if e.complexity.AuthNonce.UserExists == nil {
			break
		}

		return e.complexity.AuthNonce.UserExists(childComplexity), true

	case "Badge.contract":
		if e.complexity.Badge.Contract == nil {
			break
		}

		return e.complexity.Badge.Contract(childComplexity), true

	case "Badge.imageURL":
		if e.complexity.Badge.ImageURL == nil {
			break
		}

		return e.complexity.Badge.ImageURL(childComplexity), true

	case "Badge.name":
		if e.complexity.Badge.Name == nil {
			break
		}

		return e.complexity.Badge.Name(childComplexity), true

	case "ChainAddress.address":
		if e.complexity.ChainAddress.Address == nil {
			break
		}

		return e.complexity.ChainAddress.Address(childComplexity), true

	case "ChainAddress.chain":
		if e.complexity.ChainAddress.Chain == nil {
			break
		}

		return e.complexity.ChainAddress.Chain(childComplexity), true

	case "ChainPubKey.chain":
		if e.complexity.ChainPubKey.Chain == nil {
			break
		}

		return e.complexity.ChainPubKey.Chain(childComplexity), true

	case "ChainPubKey.pubKey":
		if e.complexity.ChainPubKey.PubKey == nil {
			break
		}

		return e.complexity.ChainPubKey.PubKey(childComplexity), true

	case "ChainTokens.chain":
		if e.complexity.ChainTokens.Chain == nil {
			break
		}

		return e.complexity.ChainTokens.Chain(childComplexity), true

	case "ChainTokens.tokens":
		if e.complexity.ChainTokens.Tokens == nil {
			break
		}

		return e.complexity.ChainTokens.Tokens(childComplexity), true

	case "ClearAllNotificationsPayload.notifications":
		if e.complexity.ClearAllNotificationsPayload.Notifications == nil {
			break
		}

		return e.complexity.ClearAllNotificationsPayload.Notifications(childComplexity), true

	case "Collection.collectorsNote":
		if e.complexity.Collection.CollectorsNote == nil {
			break
		}

		return e.complexity.Collection.CollectorsNote(childComplexity), true

	case "Collection.dbid":
		if e.complexity.Collection.Dbid == nil {
			break
		}

		return e.complexity.Collection.Dbid(childComplexity), true

	case "Collection.hidden":
		if e.complexity.Collection.Hidden == nil {
			break
		}

		return e.complexity.Collection.Hidden(childComplexity), true

	case "Collection.id":
		if e.complexity.Collection.ID == nil {
			break
		}

		return e.complexity.Collection.ID(childComplexity), true

	case "Collection.layout":
		if e.complexity.Collection.Layout == nil {
			break
		}

		return e.complexity.Collection.Layout(childComplexity), true

	case "Collection.name":
		if e.complexity.Collection.Name == nil {
			break
		}

		return e.complexity.Collection.Name(childComplexity), true

	case "Collection.split":
		if e.complexity.Collection.Split == nil {
			break
		}

		return e.complexity.Collection.Split(childComplexity), true

	case "Collection.tokens":
		if e.complexity.Collection.Tokens == nil {
			break
		}

		args, err := ec.field_Collection_tokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Collection.Tokens(childComplexity, args["limit"].(*int)), true

	case "Collection.version":
		if e.complexity.Collection.Version == nil {
			break
		}

		return e.complexity.Collection.Version(childComplexity), true

	case "CollectionLayout.sectionLayout":
		if e.complexity.CollectionLayout.SectionLayout == nil {
			break
		}

		return e.complexity.CollectionLayout.SectionLayout(childComplexity), true

	case "CollectionLayout.sections":
		if e.complexity.CollectionLayout.Sections == nil {
			break
		}

		return e.complexity.CollectionLayout.Sections(childComplexity), true

	case "CollectionSectionLayout.columns":
		if e.complexity.CollectionSectionLayout.Columns == nil {
			break
		}

		return e.complexity.CollectionSectionLayout.Columns(childComplexity), true

	case "CollectionSectionLayout.whitespace":
		if e.complexity.CollectionSectionLayout.Whitespace == nil {
			break
		}

		return e.complexity.CollectionSectionLayout.Whitespace(childComplexity), true

	case "CollectionToken.collection":
		if e.complexity.CollectionToken.Collection == nil {
			break
		}

		return e.complexity.CollectionToken.Collection(childComplexity), true

	case "CollectionToken.id":
		if e.complexity.CollectionToken.ID == nil {
			break
		}

		return e.complexity.CollectionToken.ID(childComplexity), true

	case "CollectionToken.token":
		if e.complexity.CollectionToken.Token == nil {
			break
		}

		return e.complexity.CollectionToken.Token(childComplexity), true

	case "CollectionToken.tokenSettings":
		if e.complexity.CollectionToken.TokenSettings == nil {
			break
		}

		return e.complexity.CollectionToken.TokenSettings(childComplexity), true

	case "CollectionTokenSettings.renderLive":
		if e.complexity.CollectionTokenSettings.RenderLive == nil {
			break
		}

		return e.complexity.CollectionTokenSettings.RenderLive(childComplexity), true

	case "CommunitiesConnection.edges":
		if e.complexity.CommunitiesConnection.Edges == nil {
			break
		}

		return e.complexity.CommunitiesConnection.Edges(childComplexity), true

	case "CommunitiesConnection.pageInfo":
		if e.complexity.CommunitiesConnection.PageInfo == nil {
			break
		}

		return e.complexity.CommunitiesConnection.PageInfo(childComplexity), true

	case "Community.badgeURL":
		if e.complexity.Community.BadgeURL == nil {
			break
		}

		return e.complexity.Community.BadgeURL(childComplexity), true

	case "Community.chain":
		if e.complexity.Community.Chain == nil {
			break
		}

		return e.complexity.Community.Chain(childComplexity), true

	case "Community.contractAddress":
		if e.complexity.Community.ContractAddress == nil {
			break
		}

		return e.complexity.Community.ContractAddress(childComplexity), true

	case "Community.creatorAddress":
		if e.complexity.Community.CreatorAddress == nil {
			break
		}

		return e.complexity.Community.CreatorAddress(childComplexity), true

	case "Community.dbid":
		if e.complexity.Community.Dbid == nil {
			break
		}

		return e.complexity.Community.Dbid(childComplexity), true

	case "Community.description":
		if e.complexity.Community.Description == nil {
			break
		}

		return e.complexity.Community.Description(childComplexity), true

	case "Community.id":
		if e.complexity.Community.ID == nil {
			break
		}

		return e.complexity.Community.ID(childComplexity), true

	case "Community.lastUpdated":
		if e.complexity.Community.LastUpdated == nil {
			break
		}

		return e.complexity.Community.LastUpdated(childComplexity), true

	case "Community.name":
		if e.complexity.Community.Name == nil {
			break
		}

		return e.complexity.Community.Name(childComplexity), true

	case "Community.owners":
		if e.complexity.Community.Owners == nil {
			break
		}

		args, err := ec.field_Community_owners_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Community.Owners(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int), args["onlySplitFiUsers"].(*bool)), true

	case "Community.previewImage":
		if e.complexity.Community.PreviewImage == nil {
			break
		}

		return e.complexity.Community.PreviewImage(childComplexity), true

	case "Community.profileBannerURL":
		if e.complexity.Community.ProfileBannerURL == nil {
			break
		}

		return e.complexity.Community.ProfileBannerURL(childComplexity), true

	case "Community.profileImageURL":
		if e.complexity.Community.ProfileImageURL == nil {
			break
		}

		return e.complexity.Community.ProfileImageURL(childComplexity), true

	case "Community.tokensInCommunity":
		if e.complexity.Community.TokensInCommunity == nil {
			break
		}

		args, err := ec.field_Community_tokensInCommunity_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Community.TokensInCommunity(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int), args["onlySplitFiUsers"].(*bool)), true

	case "CommunityEdge.cursor":
		if e.complexity.CommunityEdge.Cursor == nil {
			break
		}

		return e.complexity.CommunityEdge.Cursor(childComplexity), true

	case "CommunityEdge.node":
		if e.complexity.CommunityEdge.Node == nil {
			break
		}

		return e.complexity.CommunityEdge.Node(childComplexity), true

	case "CommunitySearchResult.community":
		if e.complexity.CommunitySearchResult.Community == nil {
			break
		}

		return e.complexity.CommunitySearchResult.Community(childComplexity), true

	case "ConnectSocialAccountPayload.viewer":
		if e.complexity.ConnectSocialAccountPayload.Viewer == nil {
			break
		}

		return e.complexity.ConnectSocialAccountPayload.Viewer(childComplexity), true

	case "Contract.badgeURL":
		if e.complexity.Contract.BadgeURL == nil {
			break
		}

		return e.complexity.Contract.BadgeURL(childComplexity), true

	case "Contract.chain":
		if e.complexity.Contract.Chain == nil {
			break
		}

		return e.complexity.Contract.Chain(childComplexity), true

	case "Contract.contractAddress":
		if e.complexity.Contract.ContractAddress == nil {
			break
		}

		return e.complexity.Contract.ContractAddress(childComplexity), true

	case "Contract.creatorAddress":
		if e.complexity.Contract.CreatorAddress == nil {
			break
		}

		return e.complexity.Contract.CreatorAddress(childComplexity), true

	case "Contract.dbid":
		if e.complexity.Contract.Dbid == nil {
			break
		}

		return e.complexity.Contract.Dbid(childComplexity), true

	case "Contract.id":
		if e.complexity.Contract.ID == nil {
			break
		}

		return e.complexity.Contract.ID(childComplexity), true

	case "Contract.lastUpdated":
		if e.complexity.Contract.LastUpdated == nil {
			break
		}

		return e.complexity.Contract.LastUpdated(childComplexity), true

	case "Contract.name":
		if e.complexity.Contract.Name == nil {
			break
		}

		return e.complexity.Contract.Name(childComplexity), true

	case "Contract.profileBannerURL":
		if e.complexity.Contract.ProfileBannerURL == nil {
			break
		}

		return e.complexity.Contract.ProfileBannerURL(childComplexity), true

	case "Contract.profileImageURL":
		if e.complexity.Contract.ProfileImageURL == nil {
			break
		}

		return e.complexity.Contract.ProfileImageURL(childComplexity), true

	case "CreateCollectionPayload.collection":
		if e.complexity.CreateCollectionPayload.Collection == nil {
			break
		}

		return e.complexity.CreateCollectionPayload.Collection(childComplexity), true

	case "CreateSplitPayload.split":
		if e.complexity.CreateSplitPayload.Split == nil {
			break
		}

		return e.complexity.CreateSplitPayload.Split(childComplexity), true

	case "CreateUserPayload.splitId":
		if e.complexity.CreateUserPayload.SplitID == nil {
			break
		}

		return e.complexity.CreateUserPayload.SplitID(childComplexity), true

	case "CreateUserPayload.userId":
		if e.complexity.CreateUserPayload.UserID == nil {
			break
		}

		return e.complexity.CreateUserPayload.UserID(childComplexity), true

	case "CreateUserPayload.viewer":
		if e.complexity.CreateUserPayload.Viewer == nil {
			break
		}

		return e.complexity.CreateUserPayload.Viewer(childComplexity), true

	case "DeepRefreshPayload.chain":
		if e.complexity.DeepRefreshPayload.Chain == nil {
			break
		}

		return e.complexity.DeepRefreshPayload.Chain(childComplexity), true

	case "DeepRefreshPayload.submitted":
		if e.complexity.DeepRefreshPayload.Submitted == nil {
			break
		}

		return e.complexity.DeepRefreshPayload.Submitted(childComplexity), true

	case "DeleteCollectionPayload.split":
		if e.complexity.DeleteCollectionPayload.Split == nil {
			break
		}

		return e.complexity.DeleteCollectionPayload.Split(childComplexity), true

	case "DeleteSplitPayload.deletedId":
		if e.complexity.DeleteSplitPayload.DeletedID == nil {
			break
		}

		return e.complexity.DeleteSplitPayload.DeletedID(childComplexity), true

	case "DeletedNode.dbid":
		if e.complexity.DeletedNode.Dbid == nil {
			break
		}

		return e.complexity.DeletedNode.Dbid(childComplexity), true

	case "DeletedNode.id":
		if e.complexity.DeletedNode.ID == nil {
			break
		}

		return e.complexity.DeletedNode.ID(childComplexity), true

	case "DisconnectSocialAccountPayload.viewer":
		if e.complexity.DisconnectSocialAccountPayload.Viewer == nil {
			break
		}

		return e.complexity.DisconnectSocialAccountPayload.Viewer(childComplexity), true

	case "EmailNotificationSettings.unsubscribedFromAll":
		if e.complexity.EmailNotificationSettings.UnsubscribedFromAll == nil {
			break
		}

		return e.complexity.EmailNotificationSettings.UnsubscribedFromAll(childComplexity), true

	case "EmailNotificationSettings.unsubscribedFromNotifications":
		if e.complexity.EmailNotificationSettings.UnsubscribedFromNotifications == nil {
			break
		}

		return e.complexity.EmailNotificationSettings.UnsubscribedFromNotifications(childComplexity), true

	case "ErrAddressOwnedByUser.message":
		if e.complexity.ErrAddressOwnedByUser.Message == nil {
			break
		}

		return e.complexity.ErrAddressOwnedByUser.Message(childComplexity), true

	case "ErrAuthenticationFailed.message":
		if e.complexity.ErrAuthenticationFailed.Message == nil {
			break
		}

		return e.complexity.ErrAuthenticationFailed.Message(childComplexity), true

	case "ErrCollectionNotFound.message":
		if e.complexity.ErrCollectionNotFound.Message == nil {
			break
		}

		return e.complexity.ErrCollectionNotFound.Message(childComplexity), true

	case "ErrCommunityNotFound.message":
		if e.complexity.ErrCommunityNotFound.Message == nil {
			break
		}

		return e.complexity.ErrCommunityNotFound.Message(childComplexity), true

	case "ErrDoesNotOwnRequiredToken.message":
		if e.complexity.ErrDoesNotOwnRequiredToken.Message == nil {
			break
		}

		return e.complexity.ErrDoesNotOwnRequiredToken.Message(childComplexity), true

	case "ErrInvalidInput.message":
		if e.complexity.ErrInvalidInput.Message == nil {
			break
		}

		return e.complexity.ErrInvalidInput.Message(childComplexity), true

	case "ErrInvalidInput.parameters":
		if e.complexity.ErrInvalidInput.Parameters == nil {
			break
		}

		return e.complexity.ErrInvalidInput.Parameters(childComplexity), true

	case "ErrInvalidInput.reasons":
		if e.complexity.ErrInvalidInput.Reasons == nil {
			break
		}

		return e.complexity.ErrInvalidInput.Reasons(childComplexity), true

	case "ErrInvalidToken.message":
		if e.complexity.ErrInvalidToken.Message == nil {
			break
		}

		return e.complexity.ErrInvalidToken.Message(childComplexity), true

	case "ErrNeedsToReconnectSocial.message":
		if e.complexity.ErrNeedsToReconnectSocial.Message == nil {
			break
		}

		return e.complexity.ErrNeedsToReconnectSocial.Message(childComplexity), true

	case "ErrNeedsToReconnectSocial.socialAccountType":
		if e.complexity.ErrNeedsToReconnectSocial.SocialAccountType == nil {
			break
		}

		return e.complexity.ErrNeedsToReconnectSocial.SocialAccountType(childComplexity), true

	case "ErrNoCookie.message":
		if e.complexity.ErrNoCookie.Message == nil {
			break
		}

		return e.complexity.ErrNoCookie.Message(childComplexity), true

	case "ErrNotAuthorized.cause":
		if e.complexity.ErrNotAuthorized.Cause == nil {
			break
		}

		return e.complexity.ErrNotAuthorized.Cause(childComplexity), true

	case "ErrNotAuthorized.message":
		if e.complexity.ErrNotAuthorized.Message == nil {
			break
		}

		return e.complexity.ErrNotAuthorized.Message(childComplexity), true

	case "ErrSplitNotFound.message":
		if e.complexity.ErrSplitNotFound.Message == nil {
			break
		}

		return e.complexity.ErrSplitNotFound.Message(childComplexity), true

	case "ErrSyncFailed.message":
		if e.complexity.ErrSyncFailed.Message == nil {
			break
		}

		return e.complexity.ErrSyncFailed.Message(childComplexity), true

	case "ErrTokenNotFound.message":
		if e.complexity.ErrTokenNotFound.Message == nil {
			break
		}

		return e.complexity.ErrTokenNotFound.Message(childComplexity), true

	case "ErrUserAlreadyExists.message":
		if e.complexity.ErrUserAlreadyExists.Message == nil {
			break
		}

		return e.complexity.ErrUserAlreadyExists.Message(childComplexity), true

	case "ErrUserNotFound.message":
		if e.complexity.ErrUserNotFound.Message == nil {
			break
		}

		return e.complexity.ErrUserNotFound.Message(childComplexity), true

	case "ErrUsernameNotAvailable.message":
		if e.complexity.ErrUsernameNotAvailable.Message == nil {
			break
		}

		return e.complexity.ErrUsernameNotAvailable.Message(childComplexity), true

	case "FollowAllSocialConnectionsPayload.viewer":
		if e.complexity.FollowAllSocialConnectionsPayload.Viewer == nil {
			break
		}

		return e.complexity.FollowAllSocialConnectionsPayload.Viewer(childComplexity), true

	case "FollowInfo.followedBack":
		if e.complexity.FollowInfo.FollowedBack == nil {
			break
		}

		return e.complexity.FollowInfo.FollowedBack(childComplexity), true

	case "FollowInfo.user":
		if e.complexity.FollowInfo.User == nil {
			break
		}

		return e.complexity.FollowInfo.User(childComplexity), true

	case "FollowUserPayload.user":
		if e.complexity.FollowUserPayload.User == nil {
			break
		}

		return e.complexity.FollowUserPayload.User(childComplexity), true

	case "FollowUserPayload.viewer":
		if e.complexity.FollowUserPayload.Viewer == nil {
			break
		}

		return e.complexity.FollowUserPayload.Viewer(childComplexity), true

	case "GIFMedia.contentRenderURL":
		if e.complexity.GIFMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.GIFMedia.ContentRenderURL(childComplexity), true

	case "GIFMedia.dimensions":
		if e.complexity.GIFMedia.Dimensions == nil {
			break
		}

		return e.complexity.GIFMedia.Dimensions(childComplexity), true

	case "GIFMedia.mediaType":
		if e.complexity.GIFMedia.MediaType == nil {
			break
		}

		return e.complexity.GIFMedia.MediaType(childComplexity), true

	case "GIFMedia.mediaURL":
		if e.complexity.GIFMedia.MediaURL == nil {
			break
		}

		return e.complexity.GIFMedia.MediaURL(childComplexity), true

	case "GIFMedia.previewURLs":
		if e.complexity.GIFMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.GIFMedia.PreviewURLs(childComplexity), true

	case "GIFMedia.staticPreviewURLs":
		if e.complexity.GIFMedia.StaticPreviewURLs == nil {
			break
		}

		return e.complexity.GIFMedia.StaticPreviewURLs(childComplexity), true

	case "GltfMedia.contentRenderURL":
		if e.complexity.GltfMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.GltfMedia.ContentRenderURL(childComplexity), true

	case "GltfMedia.dimensions":
		if e.complexity.GltfMedia.Dimensions == nil {
			break
		}

		return e.complexity.GltfMedia.Dimensions(childComplexity), true

	case "GltfMedia.mediaType":
		if e.complexity.GltfMedia.MediaType == nil {
			break
		}

		return e.complexity.GltfMedia.MediaType(childComplexity), true

	case "GltfMedia.mediaURL":
		if e.complexity.GltfMedia.MediaURL == nil {
			break
		}

		return e.complexity.GltfMedia.MediaURL(childComplexity), true

	case "GltfMedia.previewURLs":
		if e.complexity.GltfMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.GltfMedia.PreviewURLs(childComplexity), true

	case "GroupNotificationUserEdge.cursor":
		if e.complexity.GroupNotificationUserEdge.Cursor == nil {
			break
		}

		return e.complexity.GroupNotificationUserEdge.Cursor(childComplexity), true

	case "GroupNotificationUserEdge.node":
		if e.complexity.GroupNotificationUserEdge.Node == nil {
			break
		}

		return e.complexity.GroupNotificationUserEdge.Node(childComplexity), true

	case "GroupNotificationUsersConnection.edges":
		if e.complexity.GroupNotificationUsersConnection.Edges == nil {
			break
		}

		return e.complexity.GroupNotificationUsersConnection.Edges(childComplexity), true

	case "GroupNotificationUsersConnection.pageInfo":
		if e.complexity.GroupNotificationUsersConnection.PageInfo == nil {
			break
		}

		return e.complexity.GroupNotificationUsersConnection.PageInfo(childComplexity), true

	case "HtmlMedia.contentRenderURL":
		if e.complexity.HtmlMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.HtmlMedia.ContentRenderURL(childComplexity), true

	case "HtmlMedia.dimensions":
		if e.complexity.HtmlMedia.Dimensions == nil {
			break
		}

		return e.complexity.HtmlMedia.Dimensions(childComplexity), true

	case "HtmlMedia.mediaType":
		if e.complexity.HtmlMedia.MediaType == nil {
			break
		}

		return e.complexity.HtmlMedia.MediaType(childComplexity), true

	case "HtmlMedia.mediaURL":
		if e.complexity.HtmlMedia.MediaURL == nil {
			break
		}

		return e.complexity.HtmlMedia.MediaURL(childComplexity), true

	case "HtmlMedia.previewURLs":
		if e.complexity.HtmlMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.HtmlMedia.PreviewURLs(childComplexity), true

	case "ImageMedia.contentRenderURL":
		if e.complexity.ImageMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.ImageMedia.ContentRenderURL(childComplexity), true

	case "ImageMedia.dimensions":
		if e.complexity.ImageMedia.Dimensions == nil {
			break
		}

		return e.complexity.ImageMedia.Dimensions(childComplexity), true

	case "ImageMedia.mediaType":
		if e.complexity.ImageMedia.MediaType == nil {
			break
		}

		return e.complexity.ImageMedia.MediaType(childComplexity), true

	case "ImageMedia.mediaURL":
		if e.complexity.ImageMedia.MediaURL == nil {
			break
		}

		return e.complexity.ImageMedia.MediaURL(childComplexity), true

	case "ImageMedia.previewURLs":
		if e.complexity.ImageMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.ImageMedia.PreviewURLs(childComplexity), true

	case "InvalidMedia.contentRenderURL":
		if e.complexity.InvalidMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.InvalidMedia.ContentRenderURL(childComplexity), true

	case "InvalidMedia.dimensions":
		if e.complexity.InvalidMedia.Dimensions == nil {
			break
		}

		return e.complexity.InvalidMedia.Dimensions(childComplexity), true

	case "InvalidMedia.mediaType":
		if e.complexity.InvalidMedia.MediaType == nil {
			break
		}

		return e.complexity.InvalidMedia.MediaType(childComplexity), true

	case "InvalidMedia.mediaURL":
		if e.complexity.InvalidMedia.MediaURL == nil {
			break
		}

		return e.complexity.InvalidMedia.MediaURL(childComplexity), true

	case "InvalidMedia.previewURLs":
		if e.complexity.InvalidMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.InvalidMedia.PreviewURLs(childComplexity), true

	case "JsonMedia.contentRenderURL":
		if e.complexity.JsonMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.JsonMedia.ContentRenderURL(childComplexity), true

	case "JsonMedia.dimensions":
		if e.complexity.JsonMedia.Dimensions == nil {
			break
		}

		return e.complexity.JsonMedia.Dimensions(childComplexity), true

	case "JsonMedia.mediaType":
		if e.complexity.JsonMedia.MediaType == nil {
			break
		}

		return e.complexity.JsonMedia.MediaType(childComplexity), true

	case "JsonMedia.mediaURL":
		if e.complexity.JsonMedia.MediaURL == nil {
			break
		}

		return e.complexity.JsonMedia.MediaURL(childComplexity), true

	case "JsonMedia.previewURLs":
		if e.complexity.JsonMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.JsonMedia.PreviewURLs(childComplexity), true

	case "LoginPayload.userId":
		if e.complexity.LoginPayload.UserID == nil {
			break
		}

		return e.complexity.LoginPayload.UserID(childComplexity), true

	case "LoginPayload.viewer":
		if e.complexity.LoginPayload.Viewer == nil {
			break
		}

		return e.complexity.LoginPayload.Viewer(childComplexity), true

	case "LogoutPayload.viewer":
		if e.complexity.LogoutPayload.Viewer == nil {
			break
		}

		return e.complexity.LogoutPayload.Viewer(childComplexity), true

	case "MediaDimensions.aspectRatio":
		if e.complexity.MediaDimensions.AspectRatio == nil {
			break
		}

		return e.complexity.MediaDimensions.AspectRatio(childComplexity), true

	case "MediaDimensions.height":
		if e.complexity.MediaDimensions.Height == nil {
			break
		}

		return e.complexity.MediaDimensions.Height(childComplexity), true

	case "MediaDimensions.width":
		if e.complexity.MediaDimensions.Width == nil {
			break
		}

		return e.complexity.MediaDimensions.Width(childComplexity), true

	case "MembershipTier.assetUrl":
		if e.complexity.MembershipTier.AssetURL == nil {
			break
		}

		return e.complexity.MembershipTier.AssetURL(childComplexity), true

	case "MembershipTier.dbid":
		if e.complexity.MembershipTier.Dbid == nil {
			break
		}

		return e.complexity.MembershipTier.Dbid(childComplexity), true

	case "MembershipTier.id":
		if e.complexity.MembershipTier.ID == nil {
			break
		}

		return e.complexity.MembershipTier.ID(childComplexity), true

	case "MembershipTier.name":
		if e.complexity.MembershipTier.Name == nil {
			break
		}

		return e.complexity.MembershipTier.Name(childComplexity), true

	case "MembershipTier.owners":
		if e.complexity.MembershipTier.Owners == nil {
			break
		}

		return e.complexity.MembershipTier.Owners(childComplexity), true

	case "MembershipTier.tokenId":
		if e.complexity.MembershipTier.TokenID == nil {
			break
		}

		return e.complexity.MembershipTier.TokenID(childComplexity), true

	case "MintPremiumCardToWalletPayload.tx":
		if e.complexity.MintPremiumCardToWalletPayload.Tx == nil {
			break
		}

		return e.complexity.MintPremiumCardToWalletPayload.Tx(childComplexity), true

	case "MoveCollectionToSplitPayload.newSplit":
		if e.complexity.MoveCollectionToSplitPayload.NewSplit == nil {
			break
		}

		return e.complexity.MoveCollectionToSplitPayload.NewSplit(childComplexity), true

	case "MoveCollectionToSplitPayload.oldSplit":
		if e.complexity.MoveCollectionToSplitPayload.OldSplit == nil {
			break
		}

		return e.complexity.MoveCollectionToSplitPayload.OldSplit(childComplexity), true

	case "Mutation.addRolesToUser":
		if e.complexity.Mutation.AddRolesToUser == nil {
			break
		}

		args, err := ec.field_Mutation_addRolesToUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRolesToUser(childComplexity, args["username"].(string), args["roles"].([]*persist.Role)), true

	case "Mutation.addUserWallet":
		if e.complexity.Mutation.AddUserWallet == nil {
			break
		}

		args, err := ec.field_Mutation_addUserWallet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddUserWallet(childComplexity, args["chainAddress"].(persist.ChainAddress), args["authMechanism"].(model.AuthMechanism)), true

	case "Mutation.addWalletToUserUnchecked":
		if e.complexity.Mutation.AddWalletToUserUnchecked == nil {
			break
		}

		args, err := ec.field_Mutation_addWalletToUserUnchecked_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddWalletToUserUnchecked(childComplexity, args["input"].(model.AdminAddWalletInput)), true

	case "Mutation.clearAllNotifications":
		if e.complexity.Mutation.ClearAllNotifications == nil {
			break
		}

		return e.complexity.Mutation.ClearAllNotifications(childComplexity), true

	case "Mutation.connectSocialAccount":
		if e.complexity.Mutation.ConnectSocialAccount == nil {
			break
		}

		args, err := ec.field_Mutation_connectSocialAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConnectSocialAccount(childComplexity, args["input"].(model.SocialAuthMechanism), args["display"].(bool)), true

	case "Mutation.createCollection":
		if e.complexity.Mutation.CreateCollection == nil {
			break
		}

		args, err := ec.field_Mutation_createCollection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCollection(childComplexity, args["input"].(model.CreateCollectionInput)), true

	case "Mutation.createSplit":
		if e.complexity.Mutation.CreateSplit == nil {
			break
		}

		args, err := ec.field_Mutation_createSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSplit(childComplexity, args["input"].(model.CreateSplitInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["authMechanism"].(model.AuthMechanism), args["input"].(model.CreateUserInput)), true

	case "Mutation.deepRefresh":
		if e.complexity.Mutation.DeepRefresh == nil {
			break
		}

		args, err := ec.field_Mutation_deepRefresh_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeepRefresh(childComplexity, args["input"].(model.DeepRefreshInput)), true

	case "Mutation.deleteCollection":
		if e.complexity.Mutation.DeleteCollection == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCollection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCollection(childComplexity, args["collectionId"].(persist.DBID)), true

	case "Mutation.deleteSplit":
		if e.complexity.Mutation.DeleteSplit == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSplit(childComplexity, args["splitId"].(persist.DBID)), true

	case "Mutation.disconnectSocialAccount":
		if e.complexity.Mutation.DisconnectSocialAccount == nil {
			break
		}

		args, err := ec.field_Mutation_disconnectSocialAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DisconnectSocialAccount(childComplexity, args["accountType"].(persist.SocialProvider)), true

	case "Mutation.followAllSocialConnections":
		if e.complexity.Mutation.FollowAllSocialConnections == nil {
			break
		}

		args, err := ec.field_Mutation_followAllSocialConnections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FollowAllSocialConnections(childComplexity, args["accountType"].(persist.SocialProvider)), true

	case "Mutation.followUser":
		if e.complexity.Mutation.FollowUser == nil {
			break
		}

		args, err := ec.field_Mutation_followUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FollowUser(childComplexity, args["userId"].(persist.DBID)), true

	case "Mutation.getAuthNonce":
		if e.complexity.Mutation.GetAuthNonce == nil {
			break
		}

		args, err := ec.field_Mutation_getAuthNonce_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetAuthNonce(childComplexity, args["chainAddress"].(persist.ChainAddress)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["authMechanism"].(model.AuthMechanism)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		return e.complexity.Mutation.Logout(childComplexity), true

	case "Mutation.mintPremiumCardToWallet":
		if e.complexity.Mutation.MintPremiumCardToWallet == nil {
			break
		}

		args, err := ec.field_Mutation_mintPremiumCardToWallet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MintPremiumCardToWallet(childComplexity, args["input"].(model.MintPremiumCardToWalletInput)), true

	case "Mutation.moveCollectionToSplit":
		if e.complexity.Mutation.MoveCollectionToSplit == nil {
			break
		}

		args, err := ec.field_Mutation_moveCollectionToSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveCollectionToSplit(childComplexity, args["input"].(*model.MoveCollectionToSplitInput)), true

	case "Mutation.preverifyEmail":
		if e.complexity.Mutation.PreverifyEmail == nil {
			break
		}

		args, err := ec.field_Mutation_preverifyEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PreverifyEmail(childComplexity, args["input"].(model.PreverifyEmailInput)), true

	case "Mutation.publishSplit":
		if e.complexity.Mutation.PublishSplit == nil {
			break
		}

		args, err := ec.field_Mutation_publishSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PublishSplit(childComplexity, args["input"].(model.PublishSplitInput)), true

	case "Mutation.refreshCollection":
		if e.complexity.Mutation.RefreshCollection == nil {
			break
		}

		args, err := ec.field_Mutation_refreshCollection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshCollection(childComplexity, args["collectionId"].(persist.DBID)), true

	case "Mutation.refreshContract":
		if e.complexity.Mutation.RefreshContract == nil {
			break
		}

		args, err := ec.field_Mutation_refreshContract_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshContract(childComplexity, args["contractId"].(persist.DBID)), true

	case "Mutation.refreshToken":
		if e.complexity.Mutation.RefreshToken == nil {
			break
		}

		args, err := ec.field_Mutation_refreshToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshToken(childComplexity, args["tokenId"].(persist.DBID)), true

	case "Mutation.removeUserWallets":
		if e.complexity.Mutation.RemoveUserWallets == nil {
			break
		}

		args, err := ec.field_Mutation_removeUserWallets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveUserWallets(childComplexity, args["walletIds"].([]persist.DBID)), true

	case "Mutation.resendVerificationEmail":
		if e.complexity.Mutation.ResendVerificationEmail == nil {
			break
		}

		return e.complexity.Mutation.ResendVerificationEmail(childComplexity), true

	case "Mutation.revokeRolesFromUser":
		if e.complexity.Mutation.RevokeRolesFromUser == nil {
			break
		}

		args, err := ec.field_Mutation_revokeRolesFromUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeRolesFromUser(childComplexity, args["username"].(string), args["roles"].([]*persist.Role)), true

	case "Mutation.setSpamPreference":
		if e.complexity.Mutation.SetSpamPreference == nil {
			break
		}

		args, err := ec.field_Mutation_setSpamPreference_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetSpamPreference(childComplexity, args["input"].(model.SetSpamPreferenceInput)), true

	case "Mutation.syncTokens":
		if e.complexity.Mutation.SyncTokens == nil {
			break
		}

		args, err := ec.field_Mutation_syncTokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncTokens(childComplexity, args["chains"].([]persist.Chain)), true

	case "Mutation.syncTokensForUsername":
		if e.complexity.Mutation.SyncTokensForUsername == nil {
			break
		}

		args, err := ec.field_Mutation_syncTokensForUsername_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SyncTokensForUsername(childComplexity, args["username"].(string), args["chains"].([]persist.Chain)), true

	case "Mutation.unfollowUser":
		if e.complexity.Mutation.UnfollowUser == nil {
			break
		}

		args, err := ec.field_Mutation_unfollowUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnfollowUser(childComplexity, args["userId"].(persist.DBID)), true

	case "Mutation.unsubscribeFromEmailType":
		if e.complexity.Mutation.UnsubscribeFromEmailType == nil {
			break
		}

		args, err := ec.field_Mutation_unsubscribeFromEmailType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnsubscribeFromEmailType(childComplexity, args["input"].(model.UnsubscribeFromEmailTypeInput)), true

	case "Mutation.updateCollectionHidden":
		if e.complexity.Mutation.UpdateCollectionHidden == nil {
			break
		}

		args, err := ec.field_Mutation_updateCollectionHidden_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCollectionHidden(childComplexity, args["input"].(model.UpdateCollectionHiddenInput)), true

	case "Mutation.updateCollectionInfo":
		if e.complexity.Mutation.UpdateCollectionInfo == nil {
			break
		}

		args, err := ec.field_Mutation_updateCollectionInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCollectionInfo(childComplexity, args["input"].(model.UpdateCollectionInfoInput)), true

	case "Mutation.updateCollectionTokens":
		if e.complexity.Mutation.UpdateCollectionTokens == nil {
			break
		}

		args, err := ec.field_Mutation_updateCollectionTokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCollectionTokens(childComplexity, args["input"].(model.UpdateCollectionTokensInput)), true

	case "Mutation.updateEmail":
		if e.complexity.Mutation.UpdateEmail == nil {
			break
		}

		args, err := ec.field_Mutation_updateEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEmail(childComplexity, args["input"].(model.UpdateEmailInput)), true

	case "Mutation.updateEmailNotificationSettings":
		if e.complexity.Mutation.UpdateEmailNotificationSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateEmailNotificationSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEmailNotificationSettings(childComplexity, args["input"].(model.UpdateEmailNotificationSettingsInput)), true

	case "Mutation.updateFeaturedSplit":
		if e.complexity.Mutation.UpdateFeaturedSplit == nil {
			break
		}

		args, err := ec.field_Mutation_updateFeaturedSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFeaturedSplit(childComplexity, args["splitId"].(persist.DBID)), true

	case "Mutation.updateNotificationSettings":
		if e.complexity.Mutation.UpdateNotificationSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateNotificationSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateNotificationSettings(childComplexity, args["settings"].(*model.NotificationSettingsInput)), true

	case "Mutation.updatePrimaryWallet":
		if e.complexity.Mutation.UpdatePrimaryWallet == nil {
			break
		}

		args, err := ec.field_Mutation_updatePrimaryWallet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePrimaryWallet(childComplexity, args["walletID"].(persist.DBID)), true

	case "Mutation.updateSocialAccountDisplayed":
		if e.complexity.Mutation.UpdateSocialAccountDisplayed == nil {
			break
		}

		args, err := ec.field_Mutation_updateSocialAccountDisplayed_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSocialAccountDisplayed(childComplexity, args["input"].(model.UpdateSocialAccountDisplayedInput)), true

	case "Mutation.updateSplit":
		if e.complexity.Mutation.UpdateSplit == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplit(childComplexity, args["input"].(model.UpdateSplitInput)), true

	case "Mutation.updateSplitCollections":
		if e.complexity.Mutation.UpdateSplitCollections == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplitCollections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplitCollections(childComplexity, args["input"].(model.UpdateSplitCollectionsInput)), true

	case "Mutation.updateSplitHidden":
		if e.complexity.Mutation.UpdateSplitHidden == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplitHidden_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplitHidden(childComplexity, args["input"].(model.UpdateSplitHiddenInput)), true

	case "Mutation.updateSplitInfo":
		if e.complexity.Mutation.UpdateSplitInfo == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplitInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplitInfo(childComplexity, args["input"].(model.UpdateSplitInfoInput)), true

	case "Mutation.updateSplitOrder":
		if e.complexity.Mutation.UpdateSplitOrder == nil {
			break
		}

		args, err := ec.field_Mutation_updateSplitOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSplitOrder(childComplexity, args["input"].(model.UpdateSplitOrderInput)), true

	case "Mutation.updateTokenInfo":
		if e.complexity.Mutation.UpdateTokenInfo == nil {
			break
		}

		args, err := ec.field_Mutation_updateTokenInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTokenInfo(childComplexity, args["input"].(model.UpdateTokenInfoInput)), true

	case "Mutation.updateUserExperience":
		if e.complexity.Mutation.UpdateUserExperience == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserExperience_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserExperience(childComplexity, args["input"].(model.UpdateUserExperienceInput)), true

	case "Mutation.updateUserInfo":
		if e.complexity.Mutation.UpdateUserInfo == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserInfo(childComplexity, args["input"].(model.UpdateUserInfoInput)), true

	case "Mutation.uploadPersistedQueries":
		if e.complexity.Mutation.UploadPersistedQueries == nil {
			break
		}

		args, err := ec.field_Mutation_uploadPersistedQueries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadPersistedQueries(childComplexity, args["input"].(*model.UploadPersistedQueriesInput)), true

	case "Mutation.verifyEmail":
		if e.complexity.Mutation.VerifyEmail == nil {
			break
		}

		args, err := ec.field_Mutation_verifyEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VerifyEmail(childComplexity, args["input"].(model.VerifyEmailInput)), true

	case "Mutation.viewSplit":
		if e.complexity.Mutation.ViewSplit == nil {
			break
		}

		args, err := ec.field_Mutation_viewSplit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ViewSplit(childComplexity, args["splitId"].(persist.DBID)), true

	case "NotificationEdge.cursor":
		if e.complexity.NotificationEdge.Cursor == nil {
			break
		}

		return e.complexity.NotificationEdge.Cursor(childComplexity), true

	case "NotificationEdge.node":
		if e.complexity.NotificationEdge.Node == nil {
			break
		}

		return e.complexity.NotificationEdge.Node(childComplexity), true

	case "NotificationSettings.someoneFollowedYou":
		if e.complexity.NotificationSettings.SomeoneFollowedYou == nil {
			break
		}

		return e.complexity.NotificationSettings.SomeoneFollowedYou(childComplexity), true

	case "NotificationSettings.someoneViewedYourSplit":
		if e.complexity.NotificationSettings.SomeoneViewedYourSplit == nil {
			break
		}

		return e.complexity.NotificationSettings.SomeoneViewedYourSplit(childComplexity), true

	case "NotificationsConnection.edges":
		if e.complexity.NotificationsConnection.Edges == nil {
			break
		}

		return e.complexity.NotificationsConnection.Edges(childComplexity), true

	case "NotificationsConnection.pageInfo":
		if e.complexity.NotificationsConnection.PageInfo == nil {
			break
		}

		return e.complexity.NotificationsConnection.PageInfo(childComplexity), true

	case "NotificationsConnection.unseenCount":
		if e.complexity.NotificationsConnection.UnseenCount == nil {
			break
		}

		return e.complexity.NotificationsConnection.UnseenCount(childComplexity), true

	case "OwnerAtBlock.blockNumber":
		if e.complexity.OwnerAtBlock.BlockNumber == nil {
			break
		}

		return e.complexity.OwnerAtBlock.BlockNumber(childComplexity), true

	case "OwnerAtBlock.owner":
		if e.complexity.OwnerAtBlock.Owner == nil {
			break
		}

		return e.complexity.OwnerAtBlock.Owner(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.size":
		if e.complexity.PageInfo.Size == nil {
			break
		}

		return e.complexity.PageInfo.Size(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PageInfo.total":
		if e.complexity.PageInfo.Total == nil {
			break
		}

		return e.complexity.PageInfo.Total(childComplexity), true

	case "PdfMedia.contentRenderURL":
		if e.complexity.PdfMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.PdfMedia.ContentRenderURL(childComplexity), true

	case "PdfMedia.dimensions":
		if e.complexity.PdfMedia.Dimensions == nil {
			break
		}

		return e.complexity.PdfMedia.Dimensions(childComplexity), true

	case "PdfMedia.mediaType":
		if e.complexity.PdfMedia.MediaType == nil {
			break
		}

		return e.complexity.PdfMedia.MediaType(childComplexity), true

	case "PdfMedia.mediaURL":
		if e.complexity.PdfMedia.MediaURL == nil {
			break
		}

		return e.complexity.PdfMedia.MediaURL(childComplexity), true

	case "PdfMedia.previewURLs":
		if e.complexity.PdfMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.PdfMedia.PreviewURLs(childComplexity), true

	case "PreverifyEmailPayload.email":
		if e.complexity.PreverifyEmailPayload.Email == nil {
			break
		}

		return e.complexity.PreverifyEmailPayload.Email(childComplexity), true

	case "PreverifyEmailPayload.result":
		if e.complexity.PreverifyEmailPayload.Result == nil {
			break
		}

		return e.complexity.PreverifyEmailPayload.Result(childComplexity), true

	case "PreviewURLSet.blurhash":
		if e.complexity.PreviewURLSet.Blurhash == nil {
			break
		}

		return e.complexity.PreviewURLSet.Blurhash(childComplexity), true

	case "PreviewURLSet.large":
		if e.complexity.PreviewURLSet.Large == nil {
			break
		}

		return e.complexity.PreviewURLSet.Large(childComplexity), true

	case "PreviewURLSet.liveRender":
		if e.complexity.PreviewURLSet.LiveRender == nil {
			break
		}

		return e.complexity.PreviewURLSet.LiveRender(childComplexity), true

	case "PreviewURLSet.medium":
		if e.complexity.PreviewURLSet.Medium == nil {
			break
		}

		return e.complexity.PreviewURLSet.Medium(childComplexity), true

	case "PreviewURLSet.raw":
		if e.complexity.PreviewURLSet.Raw == nil {
			break
		}

		return e.complexity.PreviewURLSet.Raw(childComplexity), true

	case "PreviewURLSet.small":
		if e.complexity.PreviewURLSet.Small == nil {
			break
		}

		return e.complexity.PreviewURLSet.Small(childComplexity), true

	case "PreviewURLSet.srcSet":
		if e.complexity.PreviewURLSet.SrcSet == nil {
			break
		}

		return e.complexity.PreviewURLSet.SrcSet(childComplexity), true

	case "PreviewURLSet.thumbnail":
		if e.complexity.PreviewURLSet.Thumbnail == nil {
			break
		}

		return e.complexity.PreviewURLSet.Thumbnail(childComplexity), true

	case "PublishSplitPayload.split":
		if e.complexity.PublishSplitPayload.Split == nil {
			break
		}

		return e.complexity.PublishSplitPayload.Split(childComplexity), true

	case "Query.collectionById":
		if e.complexity.Query.CollectionByID == nil {
			break
		}

		args, err := ec.field_Query_collectionById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CollectionByID(childComplexity, args["id"].(persist.DBID)), true

	case "Query.collectionTokenById":
		if e.complexity.Query.CollectionTokenByID == nil {
			break
		}

		args, err := ec.field_Query_collectionTokenById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CollectionTokenByID(childComplexity, args["tokenId"].(persist.DBID), args["collectionId"].(persist.DBID)), true

	case "Query.collectionsByIds":
		if e.complexity.Query.CollectionsByIds == nil {
			break
		}

		args, err := ec.field_Query_collectionsByIds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CollectionsByIds(childComplexity, args["ids"].([]persist.DBID)), true

	case "Query.communityByAddress":
		if e.complexity.Query.CommunityByAddress == nil {
			break
		}

		args, err := ec.field_Query_communityByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CommunityByAddress(childComplexity, args["communityAddress"].(persist.ChainAddress), args["forceRefresh"].(*bool)), true

	case "Query.generalAllowlist":
		if e.complexity.Query.GeneralAllowlist == nil {
			break
		}

		return e.complexity.Query.GeneralAllowlist(childComplexity), true

	case "Query.membershipTiers":
		if e.complexity.Query.MembershipTiers == nil {
			break
		}

		args, err := ec.field_Query_membershipTiers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MembershipTiers(childComplexity, args["forceRefresh"].(*bool)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(model.GqlID)), true

	case "Query.searchCommunities":
		if e.complexity.Query.SearchCommunities == nil {
			break
		}

		args, err := ec.field_Query_searchCommunities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchCommunities(childComplexity, args["query"].(string), args["limit"].(*int), args["nameWeight"].(*float64), args["descriptionWeight"].(*float64), args["poapAddressWeight"].(*float64)), true

	case "Query.searchSplits":
		if e.complexity.Query.SearchSplits == nil {
			break
		}

		args, err := ec.field_Query_searchSplits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchSplits(childComplexity, args["query"].(string), args["limit"].(*int), args["nameWeight"].(*float64), args["descriptionWeight"].(*float64)), true

	case "Query.searchUsers":
		if e.complexity.Query.SearchUsers == nil {
			break
		}

		args, err := ec.field_Query_searchUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchUsers(childComplexity, args["query"].(string), args["limit"].(*int), args["usernameWeight"].(*float64), args["bioWeight"].(*float64)), true

	case "Query.socialConnections":
		if e.complexity.Query.SocialConnections == nil {
			break
		}

		args, err := ec.field_Query_socialConnections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SocialConnections(childComplexity, args["socialAccountType"].(persist.SocialProvider), args["excludeAlreadyFollowing"].(*bool), args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.socialQueries":
		if e.complexity.Query.SocialQueries == nil {
			break
		}

		return e.complexity.Query.SocialQueries(childComplexity), true

	case "Query.splitById":
		if e.complexity.Query.SplitByID == nil {
			break
		}

		args, err := ec.field_Query_splitById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SplitByID(childComplexity, args["id"].(persist.DBID)), true

	case "Query.tokenById":
		if e.complexity.Query.TokenByID == nil {
			break
		}

		args, err := ec.field_Query_tokenById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TokenByID(childComplexity, args["id"].(persist.DBID)), true

	case "Query.userByAddress":
		if e.complexity.Query.UserByAddress == nil {
			break
		}

		args, err := ec.field_Query_userByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByAddress(childComplexity, args["chainAddress"].(persist.ChainAddress)), true

	case "Query.userById":
		if e.complexity.Query.UserByID == nil {
			break
		}

		args, err := ec.field_Query_userById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByID(childComplexity, args["id"].(persist.DBID)), true

	case "Query.userByUsername":
		if e.complexity.Query.UserByUsername == nil {
			break
		}

		args, err := ec.field_Query_userByUsername_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByUsername(childComplexity, args["username"].(string)), true

	case "Query.usersByRole":
		if e.complexity.Query.UsersByRole == nil {
			break
		}

		args, err := ec.field_Query_usersByRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsersByRole(childComplexity, args["role"].(persist.Role), args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Query.usersWithTrait":
		if e.complexity.Query.UsersWithTrait == nil {
			break
		}

		args, err := ec.field_Query_usersWithTrait_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UsersWithTrait(childComplexity, args["trait"].(string)), true

	case "Query.viewer":
		if e.complexity.Query.Viewer == nil {
			break
		}

		return e.complexity.Query.Viewer(childComplexity), true

	case "Query.viewerSplitById":
		if e.complexity.Query.ViewerSplitByID == nil {
			break
		}

		args, err := ec.field_Query_viewerSplitById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ViewerSplitByID(childComplexity, args["id"].(persist.DBID)), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "RefreshCollectionPayload.collection":
		if e.complexity.RefreshCollectionPayload.Collection == nil {
			break
		}

		return e.complexity.RefreshCollectionPayload.Collection(childComplexity), true

	case "RefreshContractPayload.contract":
		if e.complexity.RefreshContractPayload.Contract == nil {
			break
		}

		return e.complexity.RefreshContractPayload.Contract(childComplexity), true

	case "RefreshTokenPayload.token":
		if e.complexity.RefreshTokenPayload.Token == nil {
			break
		}

		return e.complexity.RefreshTokenPayload.Token(childComplexity), true

	case "RemoveUserWalletsPayload.viewer":
		if e.complexity.RemoveUserWalletsPayload.Viewer == nil {
			break
		}

		return e.complexity.RemoveUserWalletsPayload.Viewer(childComplexity), true

	case "ResendVerificationEmailPayload.viewer":
		if e.complexity.ResendVerificationEmailPayload.Viewer == nil {
			break
		}

		return e.complexity.ResendVerificationEmailPayload.Viewer(childComplexity), true

	case "SearchCommunitiesPayload.results":
		if e.complexity.SearchCommunitiesPayload.Results == nil {
			break
		}

		return e.complexity.SearchCommunitiesPayload.Results(childComplexity), true

	case "SearchSplitsPayload.results":
		if e.complexity.SearchSplitsPayload.Results == nil {
			break
		}

		return e.complexity.SearchSplitsPayload.Results(childComplexity), true

	case "SearchUsersPayload.results":
		if e.complexity.SearchUsersPayload.Results == nil {
			break
		}

		return e.complexity.SearchUsersPayload.Results(childComplexity), true

	case "SetSpamPreferencePayload.tokens":
		if e.complexity.SetSpamPreferencePayload.Tokens == nil {
			break
		}

		return e.complexity.SetSpamPreferencePayload.Tokens(childComplexity), true

	case "SocialAccounts.twitter":
		if e.complexity.SocialAccounts.Twitter == nil {
			break
		}

		return e.complexity.SocialAccounts.Twitter(childComplexity), true

	case "SocialConnection.currentlyFollowing":
		if e.complexity.SocialConnection.CurrentlyFollowing == nil {
			break
		}

		return e.complexity.SocialConnection.CurrentlyFollowing(childComplexity), true

	case "SocialConnection.displayName":
		if e.complexity.SocialConnection.DisplayName == nil {
			break
		}

		return e.complexity.SocialConnection.DisplayName(childComplexity), true

	case "SocialConnection.id":
		if e.complexity.SocialConnection.ID == nil {
			break
		}

		return e.complexity.SocialConnection.ID(childComplexity), true

	case "SocialConnection.profileImage":
		if e.complexity.SocialConnection.ProfileImage == nil {
			break
		}

		return e.complexity.SocialConnection.ProfileImage(childComplexity), true

	case "SocialConnection.socialId":
		if e.complexity.SocialConnection.SocialID == nil {
			break
		}

		return e.complexity.SocialConnection.SocialID(childComplexity), true

	case "SocialConnection.socialType":
		if e.complexity.SocialConnection.SocialType == nil {
			break
		}

		return e.complexity.SocialConnection.SocialType(childComplexity), true

	case "SocialConnection.socialUsername":
		if e.complexity.SocialConnection.SocialUsername == nil {
			break
		}

		return e.complexity.SocialConnection.SocialUsername(childComplexity), true

	case "SocialConnection.splitFiUser":
		if e.complexity.SocialConnection.SplitFiUser == nil {
			break
		}

		return e.complexity.SocialConnection.SplitFiUser(childComplexity), true

	case "SocialConnectionsConnection.edges":
		if e.complexity.SocialConnectionsConnection.Edges == nil {
			break
		}

		return e.complexity.SocialConnectionsConnection.Edges(childComplexity), true

	case "SocialConnectionsConnection.pageInfo":
		if e.complexity.SocialConnectionsConnection.PageInfo == nil {
			break
		}

		return e.complexity.SocialConnectionsConnection.PageInfo(childComplexity), true

	case "SocialConnectionsEdge.cursor":
		if e.complexity.SocialConnectionsEdge.Cursor == nil {
			break
		}

		return e.complexity.SocialConnectionsEdge.Cursor(childComplexity), true

	case "SocialConnectionsEdge.node":
		if e.complexity.SocialConnectionsEdge.Node == nil {
			break
		}

		return e.complexity.SocialConnectionsEdge.Node(childComplexity), true

	case "SocialQueries.socialConnections":
		if e.complexity.SocialQueries.SocialConnections == nil {
			break
		}

		args, err := ec.field_SocialQueries_socialConnections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SocialQueries.SocialConnections(childComplexity, args["socialAccountType"].(persist.SocialProvider), args["excludeAlreadyFollowing"].(*bool), args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "SomeoneFollowedYouBackNotification.count":
		if e.complexity.SomeoneFollowedYouBackNotification.Count == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouBackNotification.Count(childComplexity), true

	case "SomeoneFollowedYouBackNotification.creationTime":
		if e.complexity.SomeoneFollowedYouBackNotification.CreationTime == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouBackNotification.CreationTime(childComplexity), true

	case "SomeoneFollowedYouBackNotification.dbid":
		if e.complexity.SomeoneFollowedYouBackNotification.Dbid == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouBackNotification.Dbid(childComplexity), true

	case "SomeoneFollowedYouBackNotification.followers":
		if e.complexity.SomeoneFollowedYouBackNotification.Followers == nil {
			break
		}

		args, err := ec.field_SomeoneFollowedYouBackNotification_followers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SomeoneFollowedYouBackNotification.Followers(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "SomeoneFollowedYouBackNotification.id":
		if e.complexity.SomeoneFollowedYouBackNotification.ID == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouBackNotification.ID(childComplexity), true

	case "SomeoneFollowedYouBackNotification.seen":
		if e.complexity.SomeoneFollowedYouBackNotification.Seen == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouBackNotification.Seen(childComplexity), true

	case "SomeoneFollowedYouBackNotification.updatedTime":
		if e.complexity.SomeoneFollowedYouBackNotification.UpdatedTime == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouBackNotification.UpdatedTime(childComplexity), true

	case "SomeoneFollowedYouNotification.count":
		if e.complexity.SomeoneFollowedYouNotification.Count == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouNotification.Count(childComplexity), true

	case "SomeoneFollowedYouNotification.creationTime":
		if e.complexity.SomeoneFollowedYouNotification.CreationTime == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouNotification.CreationTime(childComplexity), true

	case "SomeoneFollowedYouNotification.dbid":
		if e.complexity.SomeoneFollowedYouNotification.Dbid == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouNotification.Dbid(childComplexity), true

	case "SomeoneFollowedYouNotification.followers":
		if e.complexity.SomeoneFollowedYouNotification.Followers == nil {
			break
		}

		args, err := ec.field_SomeoneFollowedYouNotification_followers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SomeoneFollowedYouNotification.Followers(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "SomeoneFollowedYouNotification.id":
		if e.complexity.SomeoneFollowedYouNotification.ID == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouNotification.ID(childComplexity), true

	case "SomeoneFollowedYouNotification.seen":
		if e.complexity.SomeoneFollowedYouNotification.Seen == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouNotification.Seen(childComplexity), true

	case "SomeoneFollowedYouNotification.updatedTime":
		if e.complexity.SomeoneFollowedYouNotification.UpdatedTime == nil {
			break
		}

		return e.complexity.SomeoneFollowedYouNotification.UpdatedTime(childComplexity), true

	case "SomeoneViewedYourSplitNotification.count":
		if e.complexity.SomeoneViewedYourSplitNotification.Count == nil {
			break
		}

		return e.complexity.SomeoneViewedYourSplitNotification.Count(childComplexity), true

	case "SomeoneViewedYourSplitNotification.creationTime":
		if e.complexity.SomeoneViewedYourSplitNotification.CreationTime == nil {
			break
		}

		return e.complexity.SomeoneViewedYourSplitNotification.CreationTime(childComplexity), true

	case "SomeoneViewedYourSplitNotification.dbid":
		if e.complexity.SomeoneViewedYourSplitNotification.Dbid == nil {
			break
		}

		return e.complexity.SomeoneViewedYourSplitNotification.Dbid(childComplexity), true

	case "SomeoneViewedYourSplitNotification.id":
		if e.complexity.SomeoneViewedYourSplitNotification.ID == nil {
			break
		}

		return e.complexity.SomeoneViewedYourSplitNotification.ID(childComplexity), true

	case "SomeoneViewedYourSplitNotification.nonUserViewerCount":
		if e.complexity.SomeoneViewedYourSplitNotification.NonUserViewerCount == nil {
			break
		}

		return e.complexity.SomeoneViewedYourSplitNotification.NonUserViewerCount(childComplexity), true

	case "SomeoneViewedYourSplitNotification.seen":
		if e.complexity.SomeoneViewedYourSplitNotification.Seen == nil {
			break
		}

		return e.complexity.SomeoneViewedYourSplitNotification.Seen(childComplexity), true

	case "SomeoneViewedYourSplitNotification.split":
		if e.complexity.SomeoneViewedYourSplitNotification.Split == nil {
			break
		}

		return e.complexity.SomeoneViewedYourSplitNotification.Split(childComplexity), true

	case "SomeoneViewedYourSplitNotification.updatedTime":
		if e.complexity.SomeoneViewedYourSplitNotification.UpdatedTime == nil {
			break
		}

		return e.complexity.SomeoneViewedYourSplitNotification.UpdatedTime(childComplexity), true

	case "SomeoneViewedYourSplitNotification.userViewers":
		if e.complexity.SomeoneViewedYourSplitNotification.UserViewers == nil {
			break
		}

		args, err := ec.field_SomeoneViewedYourSplitNotification_userViewers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SomeoneViewedYourSplitNotification.UserViewers(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Split.collections":
		if e.complexity.Split.Collections == nil {
			break
		}

		return e.complexity.Split.Collections(childComplexity), true

	case "Split.dbid":
		if e.complexity.Split.Dbid == nil {
			break
		}

		return e.complexity.Split.Dbid(childComplexity), true

	case "Split.description":
		if e.complexity.Split.Description == nil {
			break
		}

		return e.complexity.Split.Description(childComplexity), true

	case "Split.hidden":
		if e.complexity.Split.Hidden == nil {
			break
		}

		return e.complexity.Split.Hidden(childComplexity), true

	case "Split.id":
		if e.complexity.Split.ID == nil {
			break
		}

		return e.complexity.Split.ID(childComplexity), true

	case "Split.name":
		if e.complexity.Split.Name == nil {
			break
		}

		return e.complexity.Split.Name(childComplexity), true

	case "Split.owner":
		if e.complexity.Split.Owner == nil {
			break
		}

		return e.complexity.Split.Owner(childComplexity), true

	case "Split.position":
		if e.complexity.Split.Position == nil {
			break
		}

		return e.complexity.Split.Position(childComplexity), true

	case "Split.tokenPreviews":
		if e.complexity.Split.TokenPreviews == nil {
			break
		}

		return e.complexity.Split.TokenPreviews(childComplexity), true

	case "SplitFiUser.badges":
		if e.complexity.SplitFiUser.Badges == nil {
			break
		}

		return e.complexity.SplitFiUser.Badges(childComplexity), true

	case "SplitFiUser.bio":
		if e.complexity.SplitFiUser.Bio == nil {
			break
		}

		return e.complexity.SplitFiUser.Bio(childComplexity), true

	case "SplitFiUser.dbid":
		if e.complexity.SplitFiUser.Dbid == nil {
			break
		}

		return e.complexity.SplitFiUser.Dbid(childComplexity), true

	case "SplitFiUser.featuredSplit":
		if e.complexity.SplitFiUser.FeaturedSplit == nil {
			break
		}

		return e.complexity.SplitFiUser.FeaturedSplit(childComplexity), true

	case "SplitFiUser.followers":
		if e.complexity.SplitFiUser.Followers == nil {
			break
		}

		return e.complexity.SplitFiUser.Followers(childComplexity), true

	case "SplitFiUser.following":
		if e.complexity.SplitFiUser.Following == nil {
			break
		}

		return e.complexity.SplitFiUser.Following(childComplexity), true

	case "SplitFiUser.id":
		if e.complexity.SplitFiUser.ID == nil {
			break
		}

		return e.complexity.SplitFiUser.ID(childComplexity), true

	case "SplitFiUser.isAuthenticatedUser":
		if e.complexity.SplitFiUser.IsAuthenticatedUser == nil {
			break
		}

		return e.complexity.SplitFiUser.IsAuthenticatedUser(childComplexity), true

	case "SplitFiUser.primaryWallet":
		if e.complexity.SplitFiUser.PrimaryWallet == nil {
			break
		}

		return e.complexity.SplitFiUser.PrimaryWallet(childComplexity), true

	case "SplitFiUser.roles":
		if e.complexity.SplitFiUser.Roles == nil {
			break
		}

		return e.complexity.SplitFiUser.Roles(childComplexity), true

	case "SplitFiUser.sharedCommunities":
		if e.complexity.SplitFiUser.SharedCommunities == nil {
			break
		}

		args, err := ec.field_SplitFiUser_sharedCommunities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SplitFiUser.SharedCommunities(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "SplitFiUser.sharedFollowers":
		if e.complexity.SplitFiUser.SharedFollowers == nil {
			break
		}

		args, err := ec.field_SplitFiUser_sharedFollowers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SplitFiUser.SharedFollowers(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "SplitFiUser.socialAccounts":
		if e.complexity.SplitFiUser.SocialAccounts == nil {
			break
		}

		return e.complexity.SplitFiUser.SocialAccounts(childComplexity), true

	case "SplitFiUser.splits":
		if e.complexity.SplitFiUser.Splits == nil {
			break
		}

		return e.complexity.SplitFiUser.Splits(childComplexity), true

	case "SplitFiUser.tokens":
		if e.complexity.SplitFiUser.Tokens == nil {
			break
		}

		return e.complexity.SplitFiUser.Tokens(childComplexity), true

	case "SplitFiUser.tokensByChain":
		if e.complexity.SplitFiUser.TokensByChain == nil {
			break
		}

		args, err := ec.field_SplitFiUser_tokensByChain_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SplitFiUser.TokensByChain(childComplexity, args["chain"].(persist.Chain)), true

	case "SplitFiUser.traits":
		if e.complexity.SplitFiUser.Traits == nil {
			break
		}

		return e.complexity.SplitFiUser.Traits(childComplexity), true

	case "SplitFiUser.universal":
		if e.complexity.SplitFiUser.Universal == nil {
			break
		}

		return e.complexity.SplitFiUser.Universal(childComplexity), true

	case "SplitFiUser.username":
		if e.complexity.SplitFiUser.Username == nil {
			break
		}

		return e.complexity.SplitFiUser.Username(childComplexity), true

	case "SplitFiUser.wallets":
		if e.complexity.SplitFiUser.Wallets == nil {
			break
		}

		return e.complexity.SplitFiUser.Wallets(childComplexity), true

	case "SplitSearchResult.split":
		if e.complexity.SplitSearchResult.Split == nil {
			break
		}

		return e.complexity.SplitSearchResult.Split(childComplexity), true

	case "Subscription.newNotification":
		if e.complexity.Subscription.NewNotification == nil {
			break
		}

		return e.complexity.Subscription.NewNotification(childComplexity), true

	case "Subscription.notificationUpdated":
		if e.complexity.Subscription.NotificationUpdated == nil {
			break
		}

		return e.complexity.Subscription.NotificationUpdated(childComplexity), true

	case "SyncTokensForUsernamePayload.message":
		if e.complexity.SyncTokensForUsernamePayload.Message == nil {
			break
		}

		return e.complexity.SyncTokensForUsernamePayload.Message(childComplexity), true

	case "SyncTokensPayload.viewer":
		if e.complexity.SyncTokensPayload.Viewer == nil {
			break
		}

		return e.complexity.SyncTokensPayload.Viewer(childComplexity), true

	case "SyncingMedia.contentRenderURL":
		if e.complexity.SyncingMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.SyncingMedia.ContentRenderURL(childComplexity), true

	case "SyncingMedia.dimensions":
		if e.complexity.SyncingMedia.Dimensions == nil {
			break
		}

		return e.complexity.SyncingMedia.Dimensions(childComplexity), true

	case "SyncingMedia.mediaType":
		if e.complexity.SyncingMedia.MediaType == nil {
			break
		}

		return e.complexity.SyncingMedia.MediaType(childComplexity), true

	case "SyncingMedia.mediaURL":
		if e.complexity.SyncingMedia.MediaURL == nil {
			break
		}

		return e.complexity.SyncingMedia.MediaURL(childComplexity), true

	case "SyncingMedia.previewURLs":
		if e.complexity.SyncingMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.SyncingMedia.PreviewURLs(childComplexity), true

	case "TextMedia.contentRenderURL":
		if e.complexity.TextMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.TextMedia.ContentRenderURL(childComplexity), true

	case "TextMedia.dimensions":
		if e.complexity.TextMedia.Dimensions == nil {
			break
		}

		return e.complexity.TextMedia.Dimensions(childComplexity), true

	case "TextMedia.mediaType":
		if e.complexity.TextMedia.MediaType == nil {
			break
		}

		return e.complexity.TextMedia.MediaType(childComplexity), true

	case "TextMedia.mediaURL":
		if e.complexity.TextMedia.MediaURL == nil {
			break
		}

		return e.complexity.TextMedia.MediaURL(childComplexity), true

	case "TextMedia.previewURLs":
		if e.complexity.TextMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.TextMedia.PreviewURLs(childComplexity), true

	case "Token.blockNumber":
		if e.complexity.Token.BlockNumber == nil {
			break
		}

		return e.complexity.Token.BlockNumber(childComplexity), true

	case "Token.chain":
		if e.complexity.Token.Chain == nil {
			break
		}

		return e.complexity.Token.Chain(childComplexity), true

	case "Token.collectorsNote":
		if e.complexity.Token.CollectorsNote == nil {
			break
		}

		return e.complexity.Token.CollectorsNote(childComplexity), true

	case "Token.contract":
		if e.complexity.Token.Contract == nil {
			break
		}

		return e.complexity.Token.Contract(childComplexity), true

	case "Token.creationTime":
		if e.complexity.Token.CreationTime == nil {
			break
		}

		return e.complexity.Token.CreationTime(childComplexity), true

	case "Token.creatorAddress":
		if e.complexity.Token.CreatorAddress == nil {
			break
		}

		return e.complexity.Token.CreatorAddress(childComplexity), true

	case "Token.dbid":
		if e.complexity.Token.Dbid == nil {
			break
		}

		return e.complexity.Token.Dbid(childComplexity), true

	case "Token.description":
		if e.complexity.Token.Description == nil {
			break
		}

		return e.complexity.Token.Description(childComplexity), true

	case "Token.externalUrl":
		if e.complexity.Token.ExternalURL == nil {
			break
		}

		return e.complexity.Token.ExternalURL(childComplexity), true

	case "Token.id":
		if e.complexity.Token.ID == nil {
			break
		}

		return e.complexity.Token.ID(childComplexity), true

	case "Token.isSpamByProvider":
		if e.complexity.Token.IsSpamByProvider == nil {
			break
		}

		return e.complexity.Token.IsSpamByProvider(childComplexity), true

	case "Token.isSpamByUser":
		if e.complexity.Token.IsSpamByUser == nil {
			break
		}

		return e.complexity.Token.IsSpamByUser(childComplexity), true

	case "Token.lastUpdated":
		if e.complexity.Token.LastUpdated == nil {
			break
		}

		return e.complexity.Token.LastUpdated(childComplexity), true

	case "Token.media":
		if e.complexity.Token.Media == nil {
			break
		}

		return e.complexity.Token.Media(childComplexity), true

	case "Token.name":
		if e.complexity.Token.Name == nil {
			break
		}

		return e.complexity.Token.Name(childComplexity), true

	case "Token.ownedByWallets":
		if e.complexity.Token.OwnedByWallets == nil {
			break
		}

		return e.complexity.Token.OwnedByWallets(childComplexity), true

	case "Token.owner":
		if e.complexity.Token.Owner == nil {
			break
		}

		return e.complexity.Token.Owner(childComplexity), true

	case "Token.ownershipHistory":
		if e.complexity.Token.OwnershipHistory == nil {
			break
		}

		return e.complexity.Token.OwnershipHistory(childComplexity), true

	case "Token.quantity":
		if e.complexity.Token.Quantity == nil {
			break
		}

		return e.complexity.Token.Quantity(childComplexity), true

	case "Token.tokenId":
		if e.complexity.Token.TokenID == nil {
			break
		}

		return e.complexity.Token.TokenID(childComplexity), true

	case "Token.tokenMetadata":
		if e.complexity.Token.TokenMetadata == nil {
			break
		}

		return e.complexity.Token.TokenMetadata(childComplexity), true

	case "Token.tokenType":
		if e.complexity.Token.TokenType == nil {
			break
		}

		return e.complexity.Token.TokenType(childComplexity), true

	case "TokenEdge.cursor":
		if e.complexity.TokenEdge.Cursor == nil {
			break
		}

		return e.complexity.TokenEdge.Cursor(childComplexity), true

	case "TokenEdge.node":
		if e.complexity.TokenEdge.Node == nil {
			break
		}

		return e.complexity.TokenEdge.Node(childComplexity), true

	case "TokenHolder.displayName":
		if e.complexity.TokenHolder.DisplayName == nil {
			break
		}

		return e.complexity.TokenHolder.DisplayName(childComplexity), true

	case "TokenHolder.previewTokens":
		if e.complexity.TokenHolder.PreviewTokens == nil {
			break
		}

		return e.complexity.TokenHolder.PreviewTokens(childComplexity), true

	case "TokenHolder.user":
		if e.complexity.TokenHolder.User == nil {
			break
		}

		return e.complexity.TokenHolder.User(childComplexity), true

	case "TokenHolder.wallets":
		if e.complexity.TokenHolder.Wallets == nil {
			break
		}

		return e.complexity.TokenHolder.Wallets(childComplexity), true

	case "TokenHolderEdge.cursor":
		if e.complexity.TokenHolderEdge.Cursor == nil {
			break
		}

		return e.complexity.TokenHolderEdge.Cursor(childComplexity), true

	case "TokenHolderEdge.node":
		if e.complexity.TokenHolderEdge.Node == nil {
			break
		}

		return e.complexity.TokenHolderEdge.Node(childComplexity), true

	case "TokenHoldersConnection.edges":
		if e.complexity.TokenHoldersConnection.Edges == nil {
			break
		}

		return e.complexity.TokenHoldersConnection.Edges(childComplexity), true

	case "TokenHoldersConnection.pageInfo":
		if e.complexity.TokenHoldersConnection.PageInfo == nil {
			break
		}

		return e.complexity.TokenHoldersConnection.PageInfo(childComplexity), true

	case "TokensConnection.edges":
		if e.complexity.TokensConnection.Edges == nil {
			break
		}

		return e.complexity.TokensConnection.Edges(childComplexity), true

	case "TokensConnection.pageInfo":
		if e.complexity.TokensConnection.PageInfo == nil {
			break
		}

		return e.complexity.TokensConnection.PageInfo(childComplexity), true

	case "TwitterSocialAccount.display":
		if e.complexity.TwitterSocialAccount.Display == nil {
			break
		}

		return e.complexity.TwitterSocialAccount.Display(childComplexity), true

	case "TwitterSocialAccount.name":
		if e.complexity.TwitterSocialAccount.Name == nil {
			break
		}

		return e.complexity.TwitterSocialAccount.Name(childComplexity), true

	case "TwitterSocialAccount.profileImageURL":
		if e.complexity.TwitterSocialAccount.ProfileImageURL == nil {
			break
		}

		return e.complexity.TwitterSocialAccount.ProfileImageURL(childComplexity), true

	case "TwitterSocialAccount.social_id":
		if e.complexity.TwitterSocialAccount.SocialID == nil {
			break
		}

		return e.complexity.TwitterSocialAccount.SocialID(childComplexity), true

	case "TwitterSocialAccount.type":
		if e.complexity.TwitterSocialAccount.Type == nil {
			break
		}

		return e.complexity.TwitterSocialAccount.Type(childComplexity), true

	case "TwitterSocialAccount.username":
		if e.complexity.TwitterSocialAccount.Username == nil {
			break
		}

		return e.complexity.TwitterSocialAccount.Username(childComplexity), true

	case "UnfollowUserPayload.user":
		if e.complexity.UnfollowUserPayload.User == nil {
			break
		}

		return e.complexity.UnfollowUserPayload.User(childComplexity), true

	case "UnfollowUserPayload.viewer":
		if e.complexity.UnfollowUserPayload.Viewer == nil {
			break
		}

		return e.complexity.UnfollowUserPayload.Viewer(childComplexity), true

	case "UnknownMedia.contentRenderURL":
		if e.complexity.UnknownMedia.ContentRenderURL == nil {
			break
		}

		return e.complexity.UnknownMedia.ContentRenderURL(childComplexity), true

	case "UnknownMedia.dimensions":
		if e.complexity.UnknownMedia.Dimensions == nil {
			break
		}

		return e.complexity.UnknownMedia.Dimensions(childComplexity), true

	case "UnknownMedia.mediaType":
		if e.complexity.UnknownMedia.MediaType == nil {
			break
		}

		return e.complexity.UnknownMedia.MediaType(childComplexity), true

	case "UnknownMedia.mediaURL":
		if e.complexity.UnknownMedia.MediaURL == nil {
			break
		}

		return e.complexity.UnknownMedia.MediaURL(childComplexity), true

	case "UnknownMedia.previewURLs":
		if e.complexity.UnknownMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.UnknownMedia.PreviewURLs(childComplexity), true

	case "UnsubscribeFromEmailTypePayload.viewer":
		if e.complexity.UnsubscribeFromEmailTypePayload.Viewer == nil {
			break
		}

		return e.complexity.UnsubscribeFromEmailTypePayload.Viewer(childComplexity), true

	case "UpdateCollectionHiddenPayload.collection":
		if e.complexity.UpdateCollectionHiddenPayload.Collection == nil {
			break
		}

		return e.complexity.UpdateCollectionHiddenPayload.Collection(childComplexity), true

	case "UpdateCollectionInfoPayload.collection":
		if e.complexity.UpdateCollectionInfoPayload.Collection == nil {
			break
		}

		return e.complexity.UpdateCollectionInfoPayload.Collection(childComplexity), true

	case "UpdateCollectionTokensPayload.collection":
		if e.complexity.UpdateCollectionTokensPayload.Collection == nil {
			break
		}

		return e.complexity.UpdateCollectionTokensPayload.Collection(childComplexity), true

	case "UpdateEmailNotificationSettingsPayload.viewer":
		if e.complexity.UpdateEmailNotificationSettingsPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateEmailNotificationSettingsPayload.Viewer(childComplexity), true

	case "UpdateEmailPayload.viewer":
		if e.complexity.UpdateEmailPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateEmailPayload.Viewer(childComplexity), true

	case "UpdateFeaturedSplitPayload.viewer":
		if e.complexity.UpdateFeaturedSplitPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateFeaturedSplitPayload.Viewer(childComplexity), true

	case "UpdatePrimaryWalletPayload.viewer":
		if e.complexity.UpdatePrimaryWalletPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdatePrimaryWalletPayload.Viewer(childComplexity), true

	case "UpdateSocialAccountDisplayedPayload.viewer":
		if e.complexity.UpdateSocialAccountDisplayedPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateSocialAccountDisplayedPayload.Viewer(childComplexity), true

	case "UpdateSplitCollectionsPayload.split":
		if e.complexity.UpdateSplitCollectionsPayload.Split == nil {
			break
		}

		return e.complexity.UpdateSplitCollectionsPayload.Split(childComplexity), true

	case "UpdateSplitHiddenPayload.split":
		if e.complexity.UpdateSplitHiddenPayload.Split == nil {
			break
		}

		return e.complexity.UpdateSplitHiddenPayload.Split(childComplexity), true

	case "UpdateSplitInfoPayload.split":
		if e.complexity.UpdateSplitInfoPayload.Split == nil {
			break
		}

		return e.complexity.UpdateSplitInfoPayload.Split(childComplexity), true

	case "UpdateSplitOrderPayload.viewer":
		if e.complexity.UpdateSplitOrderPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateSplitOrderPayload.Viewer(childComplexity), true

	case "UpdateSplitPayload.split":
		if e.complexity.UpdateSplitPayload.Split == nil {
			break
		}

		return e.complexity.UpdateSplitPayload.Split(childComplexity), true

	case "UpdateTokenInfoPayload.token":
		if e.complexity.UpdateTokenInfoPayload.Token == nil {
			break
		}

		return e.complexity.UpdateTokenInfoPayload.Token(childComplexity), true

	case "UpdateUserExperiencePayload.viewer":
		if e.complexity.UpdateUserExperiencePayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateUserExperiencePayload.Viewer(childComplexity), true

	case "UpdateUserInfoPayload.viewer":
		if e.complexity.UpdateUserInfoPayload.Viewer == nil {
			break
		}

		return e.complexity.UpdateUserInfoPayload.Viewer(childComplexity), true

	case "UploadPersistedQueriesPayload.message":
		if e.complexity.UploadPersistedQueriesPayload.Message == nil {
			break
		}

		return e.complexity.UploadPersistedQueriesPayload.Message(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UserEmail.email":
		if e.complexity.UserEmail.Email == nil {
			break
		}

		return e.complexity.UserEmail.Email(childComplexity), true

	case "UserEmail.emailNotificationSettings":
		if e.complexity.UserEmail.EmailNotificationSettings == nil {
			break
		}

		return e.complexity.UserEmail.EmailNotificationSettings(childComplexity), true

	case "UserEmail.verificationStatus":
		if e.complexity.UserEmail.VerificationStatus == nil {
			break
		}

		return e.complexity.UserEmail.VerificationStatus(childComplexity), true

	case "UserExperience.experienced":
		if e.complexity.UserExperience.Experienced == nil {
			break
		}

		return e.complexity.UserExperience.Experienced(childComplexity), true

	case "UserExperience.type":
		if e.complexity.UserExperience.Type == nil {
			break
		}

		return e.complexity.UserExperience.Type(childComplexity), true

	case "UserSearchResult.user":
		if e.complexity.UserSearchResult.User == nil {
			break
		}

		return e.complexity.UserSearchResult.User(childComplexity), true

	case "UsersConnection.edges":
		if e.complexity.UsersConnection.Edges == nil {
			break
		}

		return e.complexity.UsersConnection.Edges(childComplexity), true

	case "UsersConnection.pageInfo":
		if e.complexity.UsersConnection.PageInfo == nil {
			break
		}

		return e.complexity.UsersConnection.PageInfo(childComplexity), true

	case "VerifyEmailPayload.email":
		if e.complexity.VerifyEmailPayload.Email == nil {
			break
		}

		return e.complexity.VerifyEmailPayload.Email(childComplexity), true

	case "VideoMedia.contentRenderURLs":
		if e.complexity.VideoMedia.ContentRenderURLs == nil {
			break
		}

		return e.complexity.VideoMedia.ContentRenderURLs(childComplexity), true

	case "VideoMedia.dimensions":
		if e.complexity.VideoMedia.Dimensions == nil {
			break
		}

		return e.complexity.VideoMedia.Dimensions(childComplexity), true

	case "VideoMedia.mediaType":
		if e.complexity.VideoMedia.MediaType == nil {
			break
		}

		return e.complexity.VideoMedia.MediaType(childComplexity), true

	case "VideoMedia.mediaURL":
		if e.complexity.VideoMedia.MediaURL == nil {
			break
		}

		return e.complexity.VideoMedia.MediaURL(childComplexity), true

	case "VideoMedia.previewURLs":
		if e.complexity.VideoMedia.PreviewURLs == nil {
			break
		}

		return e.complexity.VideoMedia.PreviewURLs(childComplexity), true

	case "VideoURLSet.large":
		if e.complexity.VideoURLSet.Large == nil {
			break
		}

		return e.complexity.VideoURLSet.Large(childComplexity), true

	case "VideoURLSet.medium":
		if e.complexity.VideoURLSet.Medium == nil {
			break
		}

		return e.complexity.VideoURLSet.Medium(childComplexity), true

	case "VideoURLSet.raw":
		if e.complexity.VideoURLSet.Raw == nil {
			break
		}

		return e.complexity.VideoURLSet.Raw(childComplexity), true

	case "VideoURLSet.small":
		if e.complexity.VideoURLSet.Small == nil {
			break
		}

		return e.complexity.VideoURLSet.Small(childComplexity), true

	case "ViewSplitPayload.split":
		if e.complexity.ViewSplitPayload.Split == nil {
			break
		}

		return e.complexity.ViewSplitPayload.Split(childComplexity), true

	case "Viewer.email":
		if e.complexity.Viewer.Email == nil {
			break
		}

		return e.complexity.Viewer.Email(childComplexity), true

	case "Viewer.id":
		if e.complexity.Viewer.ID == nil {
			break
		}

		return e.complexity.Viewer.ID(childComplexity), true

	case "Viewer.notificationSettings":
		if e.complexity.Viewer.NotificationSettings == nil {
			break
		}

		return e.complexity.Viewer.NotificationSettings(childComplexity), true

	case "Viewer.notifications":
		if e.complexity.Viewer.Notifications == nil {
			break
		}

		args, err := ec.field_Viewer_notifications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Viewer.Notifications(childComplexity, args["before"].(*string), args["after"].(*string), args["first"].(*int), args["last"].(*int)), true

	case "Viewer.socialAccounts":
		if e.complexity.Viewer.SocialAccounts == nil {
			break
		}

		return e.complexity.Viewer.SocialAccounts(childComplexity), true

	case "Viewer.user":
		if e.complexity.Viewer.User == nil {
			break
		}

		return e.complexity.Viewer.User(childComplexity), true

	case "Viewer.userExperiences":
		if e.complexity.Viewer.UserExperiences == nil {
			break
		}

		return e.complexity.Viewer.UserExperiences(childComplexity), true

	case "Viewer.viewerSplits":
		if e.complexity.Viewer.ViewerSplits == nil {
			break
		}

		return e.complexity.Viewer.ViewerSplits(childComplexity), true

	case "ViewerSplit.split":
		if e.complexity.ViewerSplit.Split == nil {
			break
		}

		return e.complexity.ViewerSplit.Split(childComplexity), true

	case "Wallet.chain":
		if e.complexity.Wallet.Chain == nil {
			break
		}

		return e.complexity.Wallet.Chain(childComplexity), true

	case "Wallet.chainAddress":
		if e.complexity.Wallet.ChainAddress == nil {
			break
		}

		return e.complexity.Wallet.ChainAddress(childComplexity), true

	case "Wallet.dbid":
		if e.complexity.Wallet.Dbid == nil {
			break
		}

		return e.complexity.Wallet.Dbid(childComplexity), true

	case "Wallet.id":
		if e.complexity.Wallet.ID == nil {
			break
		}

		return e.complexity.Wallet.ID(childComplexity), true

	case "Wallet.tokens":
		if e.complexity.Wallet.Tokens == nil {
			break
		}

		return e.complexity.Wallet.Tokens(childComplexity), true

	case "Wallet.walletType":
		if e.complexity.Wallet.WalletType == nil {
			break
		}

		return e.complexity.Wallet.WalletType(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAdminAddWalletInput,
		ec.unmarshalInputAuthMechanism,
		ec.unmarshalInputChainAddressInput,
		ec.unmarshalInputChainPubKeyInput,
		ec.unmarshalInputCollectionLayoutInput,
		ec.unmarshalInputCollectionSectionLayoutInput,
		ec.unmarshalInputCollectionTokenSettingsInput,
		ec.unmarshalInputCreateCollectionInSplitInput,
		ec.unmarshalInputCreateCollectionInput,
		ec.unmarshalInputCreateSplitInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputDebugAuth,
		ec.unmarshalInputDebugSocialAuth,
		ec.unmarshalInputDeepRefreshInput,
		ec.unmarshalInputEoaAuth,
		ec.unmarshalInputGnosisSafeAuth,
		ec.unmarshalInputMagicLinkAuth,
		ec.unmarshalInputMintPremiumCardToWalletInput,
		ec.unmarshalInputMoveCollectionToSplitInput,
		ec.unmarshalInputNotificationSettingsInput,
		ec.unmarshalInputPreverifyEmailInput,
		ec.unmarshalInputPublishSplitInput,
		ec.unmarshalInputSetSpamPreferenceInput,
		ec.unmarshalInputSocialAuthMechanism,
		ec.unmarshalInputSplitPositionInput,
		ec.unmarshalInputTwitterAuth,
		ec.unmarshalInputUnsubscribeFromEmailTypeInput,
		ec.unmarshalInputUpdateCollectionHiddenInput,
		ec.unmarshalInputUpdateCollectionInfoInput,
		ec.unmarshalInputUpdateCollectionInput,
		ec.unmarshalInputUpdateCollectionTokensInput,
		ec.unmarshalInputUpdateEmailInput,
		ec.unmarshalInputUpdateEmailNotificationSettingsInput,
		ec.unmarshalInputUpdateSocialAccountDisplayedInput,
		ec.unmarshalInputUpdateSplitCollectionsInput,
		ec.unmarshalInputUpdateSplitHiddenInput,
		ec.unmarshalInputUpdateSplitInfoInput,
		ec.unmarshalInputUpdateSplitInput,
		ec.unmarshalInputUpdateSplitOrderInput,
		ec.unmarshalInputUpdateTokenInfoInput,
		ec.unmarshalInputUpdateUserExperienceInput,
		ec.unmarshalInputUpdateUserInfoInput,
		ec.unmarshalInputUploadPersistedQueriesInput,
		ec.unmarshalInputVerifyEmailInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/schema.graphql", Input: `"""
Any field decorated with the @experimental directive should not be used in production.
It will not conform to our rules around breaking changes.
"""
directive @experimental on FIELD_DEFINITION

# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
  forceResolver: Boolean
  name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Add @authRequired to any field that requires a user to be logged in. NOTE: Any field tagged with
# @authRequired MUST return a union type that includes ErrNotAuthorized.
#
# If we need more control over auth in the future, this directive can be updated to take
# arguments that specify the level of access required.
directive @authRequired on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @retoolAuth on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @frontendBuildAuth on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Use @scrub on any input field that should be omitted from request logging (e.g. passwords or
# other sensitive data)
directive @scrub on INPUT_FIELD_DEFINITION

# Use @restrictEnvironment to choose which values of the ENV environment variable the annotated field/object
# should be usable in (case-insensitive). Example: @restrictEnvironment(allowed:["local", "development"]) would
# allow a field in "local" and "development" environments but not in "production"
directive @restrictEnvironment(
  allowed: [String!]!
) on INPUT_FIELD_DEFINITION | INPUT_OBJECT | FIELD_DEFINITION | OBJECT

# All types that implement Node must have a unique GqlID set in their "id" field. For types with
# a "dbid" field, it's assumed that we can synthesize a unique ID from the type name and the dbid,
# so those types will automatically have an ID function generated for them (which gqlgen will find
# and bind to). Types without a dbid field, or types that need multiple inputs to create a unique ID
# that can be used to refetch the node in the future, must use the @goGqlId directive to explicitly
# state the fields that will be used to generate the ID. If a named field exists on the object and is
# a string-based type, that field will be used as part of the ID automatically. Otherwise, a manual
# getter method will need to be implemented to retrieve that component of the GqlID.
directive @goGqlId(fields: [String!]!) on OBJECT

# Injects a "Helper<TypeName>Data" struct embed into a generated type. Useful for adding backend-only
# helper data necessary to resolve queries, while keeping that data out of the schema and invisible
# to clients.
directive @goEmbedHelper on OBJECT

scalar Time
scalar Address
scalar PubKey
scalar DBID
scalar Email

interface Node {
  id: ID!
}

type DeletedNode implements Node {
  id: ID!
  dbid: DBID!
}

interface Error {
  message: String!
}

type SplitFiUser implements Node @goEmbedHelper {
  id: ID!
  dbid: DBID!
  username: String
  bio: String
  traits: String
  universal: Boolean
  roles: [Role] @goField(forceResolver: true)
  socialAccounts: SocialAccounts @goField(forceResolver: true)

  # Returns all tokens owned by this user. Useful for retrieving all tokens without any duplicates,
  # as opposed to retrieving user -> wallets -> tokens, which would contain duplicates for any token
  # that appears in more than one of the user's wallets.
  tokens: [Token] @goField(forceResolver: true)
  tokensByChain(chain: Chain!): ChainTokens @goField(forceResolver: true)

  wallets: [Wallet] @goField(forceResolver: true)
  primaryWallet: Wallet @goField(forceResolver: true)
  featuredSplit: Split @goField(forceResolver: true)
  splits: [Split] @goField(forceResolver: true)
  badges: [Badge] @goField(forceResolver: true)
  isAuthenticatedUser: Boolean
  followers: [SplitFiUser] @goField(forceResolver: true)
  following: [SplitFiUser] @goField(forceResolver: true)
  sharedFollowers(before: String, after: String, first: Int, last: Int): UsersConnection
    @authRequired
    @goField(forceResolver: true)
  sharedCommunities(before: String, after: String, first: Int, last: Int): CommunitiesConnection
    @authRequired
    @goField(forceResolver: true)
}

type Wallet implements Node {
  id: ID!
  dbid: DBID!
  chainAddress: ChainAddress
  chain: Chain
  walletType: WalletType
  tokens: [Token] @goField(forceResolver: true)
}

type ChainAddress {
  address: Address
  chain: Chain
}

type ChainPubKey {
  pubKey: PubKey
  chain: Chain
}

type ChainTokens {
  chain: Chain
  tokens: [Token]
}

input ChainAddressInput {
  address: Address! @goField(forceResolver: true)
  chain: Chain! @goField(forceResolver: true)
}

input ChainPubKeyInput {
  pubKey: PubKey! @goField(forceResolver: true)
  chain: Chain! @goField(forceResolver: true)
}

type Badge {
  name: String
  imageURL: String!
  contract: Contract
}

union SplitFiUserOrWallet = SplitFiUser | Wallet

union SplitFiUserOrAddress = SplitFiUser | ChainAddress

union MediaSubtype =
    ImageMedia
  | GIFMedia
  | VideoMedia
  | AudioMedia
  | TextMedia
  | PdfMedia
  | HtmlMedia
  | JsonMedia
  | GltfMedia
  | UnknownMedia
  | SyncingMedia
  | InvalidMedia

type PreviewURLSet {
  raw: String
  thumbnail: String
  small: String
  medium: String
  large: String
  srcSet: String
  liveRender: String
  blurhash: String @experimental @goField(forceResolver: true)
}

type VideoURLSet {
  raw: String
  small: String
  medium: String
  large: String
}

type MediaDimensions {
  width: Int
  height: Int
  aspectRatio: Float
}

interface Media {
  # Various sizes of preview images for the media
  previewURLs: PreviewURLSet

  # The original source URL for the media (may be IPFS, etc)
  mediaURL: String

  # The type of media, as determined by the backend. May be redundant given the approach we're using here
  # (media subtypes implementing the Media interface)
  mediaType: String

  # All Media types will also have something like contentRenderURL or contentRenderURLs,
  # which are the URL(s) that should actually be used for rendering the media's content

  # The dimensions of the media, if known
  dimensions: MediaDimensions
}

type ImageMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type GIFMedia implements Media {
  previewURLs: PreviewURLSet
  staticPreviewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type VideoMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURLs: VideoURLSet
  dimensions: MediaDimensions
}

type AudioMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type TextMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type PdfMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type HtmlMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type JsonMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type GltfMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type UnknownMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type SyncingMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

type InvalidMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
  dimensions: MediaDimensions
}

enum TokenType {
  ERC721
  ERC1155
  ERC20
}

enum Chain {
  Ethereum
  Arbitrum
  Polygon
  Optimism
}

enum WalletType {
  EOA
  GnosisSafe
}

type Token implements Node {
  id: ID!
  dbid: DBID!
  creationTime: Time
  lastUpdated: Time
  collectorsNote: String
  media: MediaSubtype
  tokenType: TokenType
  chain: Chain
  name: String
  description: String
  tokenId: String
  quantity: String # source is a hex string
  owner: SplitFiUser @goField(forceResolver: true)
  ownedByWallets: [Wallet] @goField(forceResolver: true)
  ownershipHistory: [OwnerAtBlock]
  tokenMetadata: String # source is map[string]interface{} on backend, not sure what best format is here
  contract: Contract @goField(forceResolver: true)
  externalUrl: String
  blockNumber: String # source is uint64
  isSpamByUser: Boolean
  isSpamByProvider: Boolean
  # These are subject to change; unlike the other fields, they aren't present on the current persist.Token
  # struct and may ultimately end up elsewhere
  creatorAddress: ChainAddress
}

type OwnerAtBlock {
  # TODO: will need to store addresses to make this resolver work
  owner: SplitFiUserOrAddress @goField(forceResolver: true)
  blockNumber: String # source is uint64
}

type CollectionToken implements Node @goEmbedHelper @goGqlId(fields: ["tokenId", "collectionId"]) {
  id: ID!
  token: Token @goField(forceResolver: true)
  collection: Collection @goField(forceResolver: true)
  tokenSettings: CollectionTokenSettings @goField(forceResolver: true)
}

type CollectionLayout {
  sections: [Int]
  sectionLayout: [CollectionSectionLayout]
}

type CollectionSectionLayout {
  columns: Int
  whitespace: [Int]
}

type CollectionTokenSettings {
  renderLive: Boolean
}

type Collection implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  name: String
  collectorsNote: String
  split: Split @goField(forceResolver: true)
  layout: CollectionLayout
  hidden: Boolean
  tokens(limit: Int): [CollectionToken] @goField(forceResolver: true)
}

type Split implements Node {
  id: ID!
  dbid: DBID!
  name: String
  description: String
  position: String
  hidden: Boolean
  tokenPreviews: [PreviewURLSet] @goField(forceResolver: true)
  owner: SplitFiUser @goField(forceResolver: true)
  collections: [Collection] @goField(forceResolver: true)
}

type TokenHolder @goEmbedHelper {
  displayName: String
  wallets: [Wallet] @goField(forceResolver: true)
  user: SplitFiUser @goField(forceResolver: true)
  previewTokens: [String]
}

type MembershipTier implements Node {
  id: ID!
  dbid: DBID!
  name: String
  assetUrl: String
  tokenId: String
  owners: [TokenHolder]
}

type TokenEdge {
  node: Token
  cursor: String
}

type TokensConnection {
  edges: [TokenEdge]
  pageInfo: PageInfo!
}

type TokenHolderEdge {
  node: TokenHolder
  cursor: String
}

type TokenHoldersConnection {
  edges: [TokenHolderEdge]
  pageInfo: PageInfo!
}

type Community implements Node @goGqlId(fields: ["contractAddress", "chain"]) @goEmbedHelper {
  dbid: DBID!
  id: ID!

  lastUpdated: Time

  contractAddress: ChainAddress
  creatorAddress: ChainAddress
  chain: Chain
  name: String
  description: String
  previewImage: String
  profileImageURL: String
  profileBannerURL: String
  badgeURL: String

  tokensInCommunity(
    before: String
    after: String
    first: Int
    last: Int
    onlySplitFiUsers: Boolean
  ): TokensConnection @goField(forceResolver: true)

  owners(
    before: String
    after: String
    first: Int
    last: Int
    onlySplitFiUsers: Boolean
  ): TokenHoldersConnection @goField(forceResolver: true)
}

type Contract implements Node {
  id: ID!
  dbid: DBID!

  lastUpdated: Time

  contractAddress: ChainAddress
  creatorAddress: ChainAddress
  chain: Chain
  name: String
  profileImageURL: String
  profileBannerURL: String
  badgeURL: String
}

# We have this extra type in case we need to stick authed data
# in here one day.
type ViewerSplit {
  split: Split
}

type NotificationEdge {
  node: Notification
  cursor: String
}

type NotificationsConnection @goEmbedHelper {
  edges: [NotificationEdge]
  unseenCount: Int
  pageInfo: PageInfo
}

enum SocialAccountType {
  Twitter
}

interface SocialAccount {
  type: SocialAccountType!
  social_id: String!
  display: Boolean!
}

type SocialAccounts {
  twitter: TwitterSocialAccount
}

type TwitterSocialAccount implements SocialAccount {
  type: SocialAccountType!
  social_id: String!
  name: String!
  username: String!
  profileImageURL: String!
  display: Boolean!
}

type Viewer implements Node @goGqlId(fields: ["userId"]) @goEmbedHelper {
  id: ID!
  user: SplitFiUser @goField(forceResolver: true)
  socialAccounts: SocialAccounts @goField(forceResolver: true)
  viewerSplits: [ViewerSplit] @goField(forceResolver: true)

  email: UserEmail @goField(forceResolver: true)
  """
  Returns a list of notifications in reverse chronological order.
  Seen notifications come after unseen notifications
  """
  notifications(before: String, after: String, first: Int, last: Int): NotificationsConnection
    @goField(forceResolver: true)

  notificationSettings: NotificationSettings @goField(forceResolver: true)

  userExperiences: [UserExperience!] @goField(forceResolver: true)
}

type NotificationSettings {
  someoneFollowedYou: Boolean
  someoneViewedYourSplit: Boolean
}

input NotificationSettingsInput {
  someoneFollowedYou: Boolean
  someoneViewedYourSplit: Boolean
}

enum EmailVerificationStatus {
  Unverified
  Verified
  Failed
  Admin
}

enum EmailUnsubscriptionType {
  All
  Notifications
}

type UserEmail {
  email: Email
  verificationStatus: EmailVerificationStatus
  emailNotificationSettings: EmailNotificationSettings
}

type EmailNotificationSettings {
  unsubscribedFromAll: Boolean!
  unsubscribedFromNotifications: Boolean!
}

input UpdateEmailNotificationSettingsInput {
  unsubscribedFromAll: Boolean!
  unsubscribedFromNotifications: Boolean!
}

input UnsubscribeFromEmailTypeInput {
  type: EmailUnsubscriptionType!
  token: String! @scrub
}

enum UserExperienceType {
  MultiSplitAnnouncement
  EmailUpsell
  MaintenanceFeb2023
  TwitterConnectionOnboardingUpsell
  UpsellMintMemento4
}

type UserExperience {
  type: UserExperienceType!
  experienced: Boolean!
}

union UserByUsernameOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union UserByIdOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union UserByAddressOrError = SplitFiUser | ErrUserNotFound | ErrInvalidInput

union ViewerOrError = Viewer | ErrNotAuthorized

type ErrCollectionNotFound implements Error {
  message: String!
}

union TokenByIdOrError = Token | ErrTokenNotFound

type ErrTokenNotFound implements Error {
  message: String!
}

union CollectionByIdOrError = Collection | ErrCollectionNotFound | ErrInvalidInput

union CollectionTokenByIdOrError = CollectionToken | ErrCollectionNotFound | ErrTokenNotFound

union CommunityByAddressOrError = Community | ErrCommunityNotFound | ErrInvalidInput

# Actions a user can take on a resource
enum Action {
  UserCreated
  UserFollowedUsers
  CollectorsNoteAddedtoToken
  CollectionCreated
  CollectorsNoteAddedToCollection
  TokensAddedToCollection
}

type FollowInfo {
  user: SplitFiUser @goField(forceResolver: true)
  followedBack: Boolean
}

type PageInfo {
  total: Int
  size: Int!
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type SocialConnection implements Node @goGqlId(fields: ["socialId", "socialType"]) @goEmbedHelper {
  id: ID!

  splitFiUser: SplitFiUser @goField(forceResolver: true)

  currentlyFollowing: Boolean!
  socialId: String!
  socialType: SocialAccountType!
  displayName: String!
  socialUsername: String!
  profileImage: String!
}

union SocialConnectionsOrError = SocialConnection | ErrInvalidInput

type SocialConnectionsEdge {
  node: SocialConnectionsOrError
  cursor: String
}

type SocialConnectionsConnection {
  edges: [SocialConnectionsEdge]
  pageInfo: PageInfo!
}

type UserEdge {
  node: SplitFiUser
  cursor: String
}

type UsersConnection {
  edges: [UserEdge]
  pageInfo: PageInfo!
}

type CommunityEdge {
  node: Community
  cursor: String
}

type CommunitiesConnection {
  edges: [CommunityEdge]
  pageInfo: PageInfo!
}

enum Role {
  ADMIN
  BETA_TESTER
  EARLY_ACCESS
}

type ErrSplitNotFound implements Error {
  message: String!
}

union SplitByIdPayloadOrError = Split | ErrSplitNotFound
union ViewerSplitByIdPayloadOrError = ViewerSplit | ErrSplitNotFound

enum ReportWindow {
  LAST_5_DAYS
  LAST_7_DAYS
  ALL_TIME
}

type UserSearchResult {
  user: SplitFiUser
}

type SearchUsersPayload {
  results: [UserSearchResult!]
}

union SearchUsersPayloadOrError = SearchUsersPayload | ErrInvalidInput

type SplitSearchResult {
  split: Split
}

type SearchSplitsPayload {
  results: [SplitSearchResult!]
}

union SearchSplitsPayloadOrError = SearchSplitsPayload | ErrInvalidInput

type CommunitySearchResult {
  community: Community
}

type SearchCommunitiesPayload {
  results: [CommunitySearchResult!]
}

union SearchCommunitiesPayloadOrError = SearchCommunitiesPayload | ErrInvalidInput

union SocialQueriesOrError = SocialQueries | ErrNotAuthorized | ErrNeedsToReconnectSocial

type Query {
  node(id: ID!): Node
  viewer: ViewerOrError @authRequired
  userByUsername(username: String!): UserByUsernameOrError
  userById(id: DBID!): UserByIdOrError
  userByAddress(chainAddress: ChainAddressInput!): UserByAddressOrError
  usersWithTrait(trait: String!): [SplitFiUser]
  membershipTiers(forceRefresh: Boolean): [MembershipTier]
  collectionById(id: DBID!): CollectionByIdOrError
  collectionsByIds(ids: [DBID!]!): [CollectionByIdOrError]
  tokenById(id: DBID!): TokenByIdOrError
  collectionTokenById(tokenId: DBID!, collectionId: DBID!): CollectionTokenByIdOrError
  communityByAddress(
    communityAddress: ChainAddressInput!
    forceRefresh: Boolean
  ): CommunityByAddressOrError
  generalAllowlist: [ChainAddress!]
  splitById(id: DBID!): SplitByIdPayloadOrError
  viewerSplitById(id: DBID!): ViewerSplitByIdPayloadOrError
  """
  Search for users with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. usernameWeight defaults to 0.4 and
  bioWeight defaults to 0.2, meaning that a search result matching a username is considered
  twice as relevant as a search result matching a bio.
  """
  searchUsers(
    query: String!
    limit: Int
    usernameWeight: Float
    bioWeight: Float
  ): SearchUsersPayloadOrError
  """
  Search for splits with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. nameWeight defaults to 0.4 and
  descriptionWeight defaults to 0.2, meaning that a search result matching a split name is
  considered twice as relevant as a search result matching a split description.
  """
  searchSplits(
    query: String!
    limit: Int
    nameWeight: Float
    descriptionWeight: Float
  ): SearchSplitsPayloadOrError
  """
  Search for communities with optional weighting. Weights are floats in the [0.0. 1.0] range
  that help determine how matches will be ranked. nameWeight defaults to 0.4, descriptionWeight
  defaults to 0.2, and poapAddressWeight defaults to 0.1, meaning that a search result matching
  a community name is considered twice as relevant as a search result matching a community
  description, and four times as relevant as a search result matching a POAP address string.
  """
  searchCommunities(
    query: String!
    limit: Int
    nameWeight: Float
    descriptionWeight: Float
    poapAddressWeight: Float
  ): SearchCommunitiesPayloadOrError

  # Retool Specific
  usersByRole(role: Role!, before: String, after: String, first: Int, last: Int): UsersConnection
    @retoolAuth

  socialConnections(
    socialAccountType: SocialAccountType!
    excludeAlreadyFollowing: Boolean
    before: String
    after: String
    first: Int
    last: Int
  ): SocialConnectionsConnection @goField(forceResolver: true) @authRequired

  socialQueries: SocialQueriesOrError @authRequired
}

type SocialQueries {
  socialConnections(
    socialAccountType: SocialAccountType!
    excludeAlreadyFollowing: Boolean
    before: String
    after: String
    first: Int
    last: Int
  ): SocialConnectionsConnection @goField(forceResolver: true) @authRequired
}

input CollectionLayoutInput {
  sections: [Int!]!
  sectionLayout: [CollectionSectionLayoutInput!]!
}

input CollectionSectionLayoutInput {
  columns: Int!
  whitespace: [Int!]!
}

input CollectionTokenSettingsInput {
  tokenId: DBID!
  renderLive: Boolean!
}

input CreateCollectionInput {
  splitId: DBID!
  name: String!
  collectorsNote: String!
  tokens: [DBID!]!
  layout: CollectionLayoutInput!
  tokenSettings: [CollectionTokenSettingsInput!]!
  caption: String
}

union CreateCollectionPayloadOrError = CreateCollectionPayload | ErrNotAuthorized | ErrInvalidInput

type CreateCollectionPayload {
  collection: Collection
}

union DeleteCollectionPayloadOrError =
    DeleteCollectionPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrCollectionNotFound

type DeleteCollectionPayload {
  split: Split
}

input UpdateCollectionInfoInput {
  collectionId: DBID!
  name: String!
  collectorsNote: String!
}

union UpdateCollectionInfoPayloadOrError =
    UpdateCollectionInfoPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateCollectionInfoPayload {
  collection: Collection
}

input UpdateCollectionTokensInput {
  collectionId: DBID!
  tokens: [DBID!]!
  layout: CollectionLayoutInput!
  tokenSettings: [CollectionTokenSettingsInput!]!
  caption: String
}

union UpdateCollectionTokensPayloadOrError =
    UpdateCollectionTokensPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateCollectionTokensPayload {
  collection: Collection
}

input UpdateCollectionHiddenInput {
  collectionId: DBID!
  hidden: Boolean!
}

union UpdateCollectionHiddenPayloadOrError =
    UpdateCollectionHiddenPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateCollectionHiddenPayload {
  collection: Collection
}

input UpdateSplitCollectionsInput {
  splitId: DBID!
  collections: [DBID!]!
}

union UpdateSplitCollectionsPayloadOrError =
    UpdateSplitCollectionsPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateSplitCollectionsPayload {
  split: Split
}

input UpdateTokenInfoInput {
  tokenId: DBID!
  collectorsNote: String!

  # Optional (for now). Lets the backend know what collection the token was being edited in.
  # @DEPCRECATED used to generate feedbot URLs.
  collectionId: DBID
}

union UpdateTokenInfoPayloadOrError = UpdateTokenInfoPayload | ErrNotAuthorized | ErrInvalidInput

type UpdateTokenInfoPayload {
  token: Token
}

input SetSpamPreferenceInput {
  tokens: [DBID!]!
  isSpam: Boolean!
}

type SetSpamPreferencePayload {
  tokens: [Token] @goField(forceResolver: true)
}

union SetSpamPreferencePayloadOrError = SetSpamPreferencePayload | ErrNotAuthorized

union AddUserWalletPayloadOrError =
    AddUserWalletPayload
  | ErrAuthenticationFailed
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrAddressOwnedByUser

type AddUserWalletPayload {
  viewer: Viewer
}

union RemoveUserWalletsPayloadOrError =
    RemoveUserWalletsPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type RemoveUserWalletsPayload {
  viewer: Viewer
}

input UpdateUserInfoInput {
  username: String!
  bio: String!
}

union UpdateUserInfoPayloadOrError =
    UpdateUserInfoPayload
  | ErrNotAuthorized
  | ErrUsernameNotAvailable
  | ErrInvalidInput

type UpdateUserInfoPayload {
  viewer: Viewer
}

union SyncTokensPayloadOrError = SyncTokensPayload | ErrNotAuthorized | ErrSyncFailed

type SyncTokensPayload {
  viewer: Viewer
}

union RefreshTokenPayloadOrError = RefreshTokenPayload | ErrInvalidInput | ErrSyncFailed

type RefreshTokenPayload {
  token: Token
}

union RefreshCollectionPayloadOrError = RefreshCollectionPayload | ErrInvalidInput | ErrSyncFailed

type RefreshCollectionPayload {
  collection: Collection
}

union RefreshContractPayloadOrError = RefreshContractPayload | ErrInvalidInput | ErrSyncFailed

type RefreshContractPayload {
  contract: Contract
}

type AuthNonce {
  nonce: String
  userExists: Boolean
}

union GetAuthNoncePayloadOrError = AuthNonce | ErrDoesNotOwnRequiredToken

type ErrAuthenticationFailed implements Error {
  message: String!
}

type ErrUserAlreadyExists implements Error {
  message: String!
}

type ErrUsernameNotAvailable implements Error {
  message: String!
}

type ErrAddressOwnedByUser implements Error {
  message: String!
}

type ErrUserNotFound implements Error {
  message: String!
}

type ErrCommunityNotFound implements Error {
  message: String!
}

union AuthorizationError = ErrNoCookie | ErrInvalidToken | ErrDoesNotOwnRequiredToken

type ErrNotAuthorized implements Error {
  message: String!
  cause: AuthorizationError!
}

type ErrInvalidInput implements Error {
  message: String!
  parameters: [String!]!
  reasons: [String!]!
}

type ErrNoCookie implements Error {
  message: String!
}

type ErrInvalidToken implements Error {
  message: String!
}

type ErrNeedsToReconnectSocial implements Error {
  socialAccountType: SocialAccountType!
  message: String!
}

type ErrDoesNotOwnRequiredToken implements Error {
  message: String!
}

type ErrSyncFailed implements Error {
  message: String!
}

input AuthMechanism {
  eoa: EoaAuth
  gnosisSafe: GnosisSafeAuth
  debug: DebugAuth
  magicLink: MagicLinkAuth
}

input EoaAuth {
  chainPubKey: ChainPubKeyInput!
  nonce: String!
  signature: String! @scrub
}

# DebugAuth is a local-only authentication mechanism for testing and debugging.
# It creates an authenticator that will return the supplied userId and chainAddresses as if they had been
# successfully authenticated. For existing users, the asUsername parameter may be supplied as a convenience
# method to look up and return their userId and chainAddresses.
input DebugAuth @restrictEnvironment(allowed: ["local"]) {
  # Convenience method to authenticate as an existing user.
  # Cannot be used in conjunction with the userId and chainAddresses parameters.
  asUsername: String

  # The userId that will be returned from the resulting authenticator.
  # May be omitted or blank to indicate that there is no user associated with the supplied chainAddresses.
  # Cannot be used in conjunction with the asUsername parameter.
  userId: DBID

  # The chainAddresses that will be returned from the resulting authenticator.
  # Cannot be used in conjunction with the asUsername parameter.
  chainAddresses: [ChainAddressInput!]
}

input GnosisSafeAuth {
  address: Address!
  nonce: String!
}

input MagicLinkAuth {
  token: String!
}

input SocialAuthMechanism {
  twitter: TwitterAuth
  debug: DebugSocialAuth
}

input TwitterAuth {
  code: String!
}

input DebugSocialAuth {
  provider: SocialAccountType!
  id: String!
  username: String!
}

input DeepRefreshInput {
  chain: Chain!
}

type DeepRefreshPayload {
  chain: Chain
  submitted: Boolean
}

union DeepRefreshPayloadOrError = DeepRefreshPayload | ErrNotAuthorized

union LoginPayloadOrError =
    LoginPayload
  | ErrUserNotFound
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredToken

type LoginPayload {
  # TODO: Remove userId in favor of viewer
  userId: DBID
  viewer: Viewer
}

type LogoutPayload {
  viewer: Viewer
}
input CreateUserInput {
  username: String!
  bio: String
  email: Email
  splitName: String
  splitDescription: String
  splitPosition: String
}

union CreateUserPayloadOrError =
    CreateUserPayload
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredToken
  | ErrUserAlreadyExists
  | ErrUsernameNotAvailable
  | ErrInvalidInput

type CreateUserPayload {
  userId: DBID
  splitId: DBID
  # TODO: Remove userId and splitId in favor of viewer
  viewer: Viewer
}

union FollowUserPayloadOrError =
    FollowUserPayload
  | ErrAuthenticationFailed
  | ErrUserNotFound
  | ErrInvalidInput

union UnfollowUserPayloadOrError =
    UnfollowUserPayload
  | ErrAuthenticationFailed
  | ErrUserNotFound
  | ErrInvalidInput

type FollowUserPayload {
  viewer: Viewer
  user: SplitFiUser @goField(forceResolver: true)
}

type UnfollowUserPayload {
  viewer: Viewer
  user: SplitFiUser @goField(forceResolver: true)
}

interface Notification implements Node {
  id: ID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
}

interface GroupedNotification implements Notification & Node {
  id: ID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time

  count: Int
}

type GroupNotificationUserEdge {
  node: SplitFiUser
  cursor: String
}

type GroupNotificationUsersConnection @goEmbedHelper {
  edges: [GroupNotificationUserEdge]
  pageInfo: PageInfo
}

type SomeoneFollowedYouNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  followers(before: String, after: String, first: Int, last: Int): GroupNotificationUsersConnection
    @goField(forceResolver: true)
}

type SomeoneFollowedYouBackNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  count: Int

  followers(before: String, after: String, first: Int, last: Int): GroupNotificationUsersConnection
    @goField(forceResolver: true)
}

type SomeoneViewedYourSplitNotification implements Notification & Node & GroupedNotification
  @goEmbedHelper {
  id: ID!
  dbid: DBID!
  seen: Boolean
  creationTime: Time
  updatedTime: Time
  # the total count of notifications grouped, despite uniqueness of the viewers and whether they are logged in or not
  count: Int

  # unique user viewers, use PageInfo.Total to get the total unique user viewers
  userViewers(
    before: String
    after: String
    first: Int
    last: Int
  ): GroupNotificationUsersConnection @goField(forceResolver: true)

  # count of unique non-user viewers
  nonUserViewerCount: Int
  split: Split @goField(forceResolver: true)
}

type ClearAllNotificationsPayload {
  notifications: [Notification]
}

type ViewSplitPayload {
  split: Split
}

union ViewSplitPayloadOrError = ViewSplitPayload | ErrAuthenticationFailed

input VerifyEmailInput {
  token: String! @scrub
}

type VerifyEmailPayload {
  email: Email!
}

union VerifyEmailPayloadOrError = VerifyEmailPayload | ErrInvalidInput

input PreverifyEmailInput {
  email: Email! @scrub
}

enum PreverifyEmailResult {
  Invalid
  Risky
  Valid
}

type PreverifyEmailPayload {
  email: Email!
  result: PreverifyEmailResult!
}

union PreverifyEmailPayloadOrError = PreverifyEmailPayload | ErrInvalidInput

input UpdateEmailInput {
  email: Email! @scrub
}

type UpdateEmailPayload {
  viewer: Viewer
}

union UpdateEmailPayloadOrError = UpdateEmailPayload | ErrInvalidInput

type ResendVerificationEmailPayload {
  viewer: Viewer
}

union ResendVerificationEmailPayloadOrError = ResendVerificationEmailPayload | ErrInvalidInput

type UpdateEmailNotificationSettingsPayload {
  viewer: Viewer
}

union UpdateEmailNotificationSettingsPayloadOrError =
    UpdateEmailNotificationSettingsPayload
  | ErrInvalidInput

type UnsubscribeFromEmailTypePayload {
  viewer: Viewer
}

union UnsubscribeFromEmailTypePayloadOrError = UnsubscribeFromEmailTypePayload | ErrInvalidInput

union AddRolesToUserPayloadOrError = SplitFiUser | ErrNotAuthorized
union RevokeRolesFromUserPayloadOrError = SplitFiUser | ErrNotAuthorized

input UploadPersistedQueriesInput {
  persistedQueries: String
}

union UploadPersistedQueriesPayloadOrError = UploadPersistedQueriesPayload | ErrNotAuthorized

type UploadPersistedQueriesPayload {
  message: String
}

type SyncTokensForUsernamePayload {
  message: String!
}

union SyncTokensForUsernamePayloadOrError =
    SyncTokensForUsernamePayload
  | ErrNotAuthorized
  | ErrSyncFailed

input SplitPositionInput {
  splitId: DBID!
  position: String!
}

input UpdateSplitOrderInput {
  positions: [SplitPositionInput!]!
}

input UpdateSplitHiddenInput {
  id: DBID!
  hidden: Boolean!
}

input UpdateSplitInfoInput {
  id: DBID!
  name: String
  description: String
}

input CreateSplitInput {
  name: String
  description: String
  position: String!
}

type CreateSplitPayload {
  split: Split
}

union CreateSplitPayloadOrError = CreateSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdateSplitInfoPayload {
  split: Split
}

union UpdateSplitInfoPayloadOrError =
    UpdateSplitInfoPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type UpdateSplitHiddenPayload {
  split: Split
}

union UpdateSplitHiddenPayloadOrError =
    UpdateSplitHiddenPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type DeleteSplitPayload {
  deletedId: DeletedNode
}

union DeleteSplitPayloadOrError = DeleteSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdateSplitOrderPayload {
  viewer: Viewer
}

union UpdateSplitOrderPayloadOrError =
    UpdateSplitOrderPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type UpdateFeaturedSplitPayload {
  viewer: Viewer
}

union UpdateFeaturedSplitPayloadOrError =
    UpdateFeaturedSplitPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input UpdateCollectionInput {
  dbid: DBID!
  name: String!
  collectorsNote: String!
  tokens: [DBID!]!
  layout: CollectionLayoutInput!
  tokenSettings: [CollectionTokenSettingsInput!]!
  hidden: Boolean!
}

input CreateCollectionInSplitInput {
  name: String!
  collectorsNote: String!
  tokens: [DBID!]!
  layout: CollectionLayoutInput!
  tokenSettings: [CollectionTokenSettingsInput!]!
  hidden: Boolean!
  givenID: DBID!
}

input UpdateSplitInput {
  splitId: DBID!

  name: String
  description: String

  # leaving caption around for a bit for backwards compatibility
  caption: String

  deletedCollections: [DBID!]

  updatedCollections: [UpdateCollectionInput]
  createdCollections: [CreateCollectionInSplitInput]

  order: [DBID!]

  # generated on the frontend
  # will be String! in the future, not required for temp backwards compatibility
  editId: String
}

type UpdateSplitPayload {
  split: Split
}

union UpdateSplitPayloadOrError = UpdateSplitPayload | ErrInvalidInput | ErrNotAuthorized

input PublishSplitInput {
  splitId: DBID!
  editId: String!
  caption: String
}

type PublishSplitPayload {
  split: Split
}

union PublishSplitPayloadOrError = PublishSplitPayload | ErrInvalidInput | ErrNotAuthorized

type UpdatePrimaryWalletPayload {
  viewer: Viewer
}

union UpdatePrimaryWalletPayloadOrError =
    UpdatePrimaryWalletPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input AdminAddWalletInput {
  username: String!
  chainAddress: ChainAddressInput!
  walletType: WalletType!
}

type AdminAddWalletPayload {
  user: SplitFiUser
}

union AdminAddWalletPayloadOrError =
    AdminAddWalletPayload
  | ErrUserNotFound
  | ErrAddressOwnedByUser
  | ErrNotAuthorized

input UpdateUserExperienceInput {
  experienceType: UserExperienceType!
  experienced: Boolean!
}

type UpdateUserExperiencePayload {
  viewer: Viewer
}

union UpdateUserExperiencePayloadOrError =
    UpdateUserExperiencePayload
  | ErrInvalidInput
  | ErrNotAuthorized

input MoveCollectionToSplitInput {
  sourceCollectionId: DBID!
  targetSplitId: DBID!
}

type MoveCollectionToSplitPayload {
  oldSplit: Split
  newSplit: Split
}

union MoveCollectionToSplitPayloadOrError =
    MoveCollectionToSplitPayload
  | ErrInvalidInput
  | ErrNotAuthorized

type ConnectSocialAccountPayload {
  viewer: Viewer
}

union ConnectSocialAccountPayloadOrError =
    ConnectSocialAccountPayload
  | ErrInvalidInput
  | ErrNotAuthorized

input UpdateSocialAccountDisplayedInput {
  type: SocialAccountType!
  displayed: Boolean!
}

type UpdateSocialAccountDisplayedPayload {
  viewer: Viewer
}

union UpdateSocialAccountDisplayedPayloadOrError =
    UpdateSocialAccountDisplayedPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrNeedsToReconnectSocial

input MintPremiumCardToWalletInput {
  tokenId: String!
  walletAddresses: [Address!]
}

type MintPremiumCardToWalletPayload {
  tx: String!
}

union MintPremiumCardToWalletPayloadOrError =
    MintPremiumCardToWalletPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrNeedsToReconnectSocial

type DisconnectSocialAccountPayload {
  viewer: Viewer
}

union DisconnectSocialAccountPayloadOrError =
    DisconnectSocialAccountPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrNeedsToReconnectSocial

type FollowAllSocialConnectionsPayload {
  viewer: Viewer
}

union FollowAllSocialConnectionsPayloadOrError =
    FollowAllSocialConnectionsPayload
  | ErrInvalidInput
  | ErrNotAuthorized
  | ErrNeedsToReconnectSocial

type Mutation {
  # User Mutations
  addUserWallet(
    chainAddress: ChainAddressInput!
    authMechanism: AuthMechanism!
  ): AddUserWalletPayloadOrError @authRequired
  removeUserWallets(walletIds: [DBID!]!): RemoveUserWalletsPayloadOrError @authRequired
  updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayloadOrError @authRequired

  # Split Mutations
  updateSplitCollections(
    input: UpdateSplitCollectionsInput!
  ): UpdateSplitCollectionsPayloadOrError @authRequired

  # Collection Mutations

  createCollection(input: CreateCollectionInput!): CreateCollectionPayloadOrError @authRequired
  deleteCollection(collectionId: DBID!): DeleteCollectionPayloadOrError @authRequired
  updateCollectionInfo(input: UpdateCollectionInfoInput!): UpdateCollectionInfoPayloadOrError
    @authRequired
  updateCollectionTokens(input: UpdateCollectionTokensInput!): UpdateCollectionTokensPayloadOrError
    @authRequired
  updateCollectionHidden(input: UpdateCollectionHiddenInput!): UpdateCollectionHiddenPayloadOrError
    @authRequired

  # Token Mutations
  updateTokenInfo(input: UpdateTokenInfoInput!): UpdateTokenInfoPayloadOrError @authRequired
  setSpamPreference(input: SetSpamPreferenceInput!): SetSpamPreferencePayloadOrError @authRequired

  syncTokens(chains: [Chain!]): SyncTokensPayloadOrError @authRequired
  refreshToken(tokenId: DBID!): RefreshTokenPayloadOrError
  refreshCollection(collectionId: DBID!): RefreshCollectionPayloadOrError
  refreshContract(contractId: DBID!): RefreshContractPayloadOrError
  deepRefresh(input: DeepRefreshInput!): DeepRefreshPayloadOrError @authRequired

  getAuthNonce(chainAddress: ChainAddressInput!): GetAuthNoncePayloadOrError

  createUser(authMechanism: AuthMechanism!, input: CreateUserInput!): CreateUserPayloadOrError
  updateEmail(input: UpdateEmailInput!): UpdateEmailPayloadOrError @authRequired
  resendVerificationEmail: ResendVerificationEmailPayloadOrError @authRequired
  updateEmailNotificationSettings(
    input: UpdateEmailNotificationSettingsInput!
  ): UpdateEmailNotificationSettingsPayloadOrError @authRequired
  unsubscribeFromEmailType(
    input: UnsubscribeFromEmailTypeInput!
  ): UnsubscribeFromEmailTypePayloadOrError
  login(authMechanism: AuthMechanism!): LoginPayloadOrError
  logout: LogoutPayload

  connectSocialAccount(
    input: SocialAuthMechanism!
    display: Boolean! = true
  ): ConnectSocialAccountPayloadOrError @authRequired
  disconnectSocialAccount(accountType: SocialAccountType!): DisconnectSocialAccountPayloadOrError
    @authRequired
  updateSocialAccountDisplayed(
    input: UpdateSocialAccountDisplayedInput!
  ): UpdateSocialAccountDisplayedPayloadOrError @authRequired

  followUser(userId: DBID!): FollowUserPayloadOrError @authRequired
  followAllSocialConnections(
    accountType: SocialAccountType!
  ): FollowAllSocialConnectionsPayloadOrError @authRequired
  unfollowUser(userId: DBID!): UnfollowUserPayloadOrError @authRequired

  viewSplit(splitId: DBID!): ViewSplitPayloadOrError

  updateSplit(input: UpdateSplitInput!): UpdateSplitPayloadOrError @authRequired
  publishSplit(input: PublishSplitInput!): PublishSplitPayloadOrError @authRequired

  createSplit(input: CreateSplitInput!): CreateSplitPayloadOrError @authRequired
  updateSplitHidden(input: UpdateSplitHiddenInput!): UpdateSplitHiddenPayloadOrError
    @authRequired
  deleteSplit(splitId: DBID!): DeleteSplitPayloadOrError @authRequired
  updateSplitOrder(input: UpdateSplitOrderInput!): UpdateSplitOrderPayloadOrError
    @authRequired
  updateSplitInfo(input: UpdateSplitInfoInput!): UpdateSplitInfoPayloadOrError @authRequired
  updateFeaturedSplit(splitId: DBID!): UpdateFeaturedSplitPayloadOrError @authRequired

  clearAllNotifications: ClearAllNotificationsPayload @authRequired

  updateNotificationSettings(settings: NotificationSettingsInput): NotificationSettings

  preverifyEmail(input: PreverifyEmailInput!): PreverifyEmailPayloadOrError
  verifyEmail(input: VerifyEmailInput!): VerifyEmailPayloadOrError

  # Retool Specific Mutations
  addRolesToUser(username: String!, roles: [Role]): AddRolesToUserPayloadOrError @retoolAuth
  addWalletToUserUnchecked(input: AdminAddWalletInput!): AdminAddWalletPayloadOrError @retoolAuth
  revokeRolesFromUser(username: String!, roles: [Role]): RevokeRolesFromUserPayloadOrError
    @retoolAuth
  syncTokensForUsername(username: String!, chains: [Chain!]!): SyncTokensForUsernamePayloadOrError
    @retoolAuth
  mintPremiumCardToWallet(
    input: MintPremiumCardToWalletInput!
  ): MintPremiumCardToWalletPayloadOrError @retoolAuth

  # Split Frontend Deploy Persisted Queries
  uploadPersistedQueries(input: UploadPersistedQueriesInput): UploadPersistedQueriesPayloadOrError
    @frontendBuildAuth

  updatePrimaryWallet(walletID: DBID!): UpdatePrimaryWalletPayloadOrError @authRequired

  updateUserExperience(input: UpdateUserExperienceInput!): UpdateUserExperiencePayloadOrError
    @authRequired

  moveCollectionToSplit(
    input: MoveCollectionToSplitInput
  ): MoveCollectionToSplitPayloadOrError @authRequired
}

type Subscription {
  newNotification: Notification
  notificationUpdated: Notification
}
`, BuiltIn: false},
	{Name: "../../federation/directives.graphql", Input: `
	scalar _Any
	scalar _FieldSet
	directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
	directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
	directive @extends on OBJECT | INTERFACE

	directive @key(fields: _FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @external on FIELD_DEFINITION | OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @shareable on OBJECT | FIELD_DEFINITION
	directive @tag(name: String!) repeatable on FIELD_DEFINITION | INTERFACE | OBJECT | UNION | ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
	directive @override(from: String!) on FIELD_DEFINITION
	directive @inaccessible on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION
`, BuiltIn: true},
	{Name: "../../federation/entity.graphql", Input: `
type _Service {
  sdl: String
}

extend type Query {
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_restrictEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["allowed"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowed"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowed"] = arg0
	return args, nil
}

func (ec *executionContext) field_Collection_tokens_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Community_owners_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *bool
	if tmp, ok := rawArgs["onlySplitFiUsers"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onlySplitFiUsers"))
		arg4, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["onlySplitFiUsers"] = arg4
	return args, nil
}

func (ec *executionContext) field_Community_tokensInCommunity_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *bool
	if tmp, ok := rawArgs["onlySplitFiUsers"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onlySplitFiUsers"))
		arg4, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["onlySplitFiUsers"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_addRolesToUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 []*persist.Role
	if tmp, ok := rawArgs["roles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
		arg1, err = ec.unmarshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roles"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addUserWallet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.ChainAddress
	if tmp, ok := rawArgs["chainAddress"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddress"))
		arg0, err = ec.unmarshalNChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chainAddress"] = arg0
	var arg1 model.AuthMechanism
	if tmp, ok := rawArgs["authMechanism"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMechanism"))
		arg1, err = ec.unmarshalNAuthMechanism2githubcomSplitFigosplitfigraphqlmodelAuthMechanism(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authMechanism"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addWalletToUserUnchecked_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AdminAddWalletInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAdminAddWalletInput2githubcomSplitFigosplitfigraphqlmodelAdminAddWalletInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_connectSocialAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SocialAuthMechanism
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSocialAuthMechanism2githubcomSplitFigosplitfigraphqlmodelSocialAuthMechanism(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["display"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("display"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["display"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createCollection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateCollectionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateCollectionInput2githubcomSplitFigosplitfigraphqlmodelCreateCollectionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateSplitInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateSplitInput2githubcomSplitFigosplitfigraphqlmodelCreateSplitInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AuthMechanism
	if tmp, ok := rawArgs["authMechanism"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMechanism"))
		arg0, err = ec.unmarshalNAuthMechanism2githubcomSplitFigosplitfigraphqlmodelAuthMechanism(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authMechanism"] = arg0
	var arg1 model.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNCreateUserInput2githubcomSplitFigosplitfigraphqlmodelCreateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deepRefresh_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DeepRefreshInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeepRefreshInput2githubcomSplitFigosplitfigraphqlmodelDeepRefreshInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCollection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["collectionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectionId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["collectionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["splitId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["splitId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_disconnectSocialAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.SocialProvider
	if tmp, ok := rawArgs["accountType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountType"))
		arg0, err = ec.unmarshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accountType"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_followAllSocialConnections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.SocialProvider
	if tmp, ok := rawArgs["accountType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountType"))
		arg0, err = ec.unmarshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accountType"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_followUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_getAuthNonce_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.ChainAddress
	if tmp, ok := rawArgs["chainAddress"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddress"))
		arg0, err = ec.unmarshalNChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chainAddress"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_login_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AuthMechanism
	if tmp, ok := rawArgs["authMechanism"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authMechanism"))
		arg0, err = ec.unmarshalNAuthMechanism2githubcomSplitFigosplitfigraphqlmodelAuthMechanism(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authMechanism"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_mintPremiumCardToWallet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.MintPremiumCardToWalletInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNMintPremiumCardToWalletInput2githubcomSplitFigosplitfigraphqlmodelMintPremiumCardToWalletInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_moveCollectionToSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.MoveCollectionToSplitInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOMoveCollectionToSplitInput2githubcomSplitFigosplitfigraphqlmodelMoveCollectionToSplitInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_preverifyEmail_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PreverifyEmailInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNPreverifyEmailInput2githubcomSplitFigosplitfigraphqlmodelPreverifyEmailInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_publishSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.PublishSplitInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNPublishSplitInput2githubcomSplitFigosplitfigraphqlmodelPublishSplitInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refreshCollection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["collectionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectionId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["collectionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refreshContract_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["contractId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contractId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refreshToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["tokenId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeUserWallets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []persist.DBID
	if tmp, ok := rawArgs["walletIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("walletIds"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["walletIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_revokeRolesFromUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 []*persist.Role
	if tmp, ok := rawArgs["roles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
		arg1, err = ec.unmarshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roles"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setSpamPreference_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SetSpamPreferenceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSetSpamPreferenceInput2githubcomSplitFigosplitfigraphqlmodelSetSpamPreferenceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_syncTokensForUsername_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 []persist.Chain
	if tmp, ok := rawArgs["chains"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chains"))
		arg1, err = ec.unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chains"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_syncTokens_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []persist.Chain
	if tmp, ok := rawArgs["chains"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chains"))
		arg0, err = ec.unmarshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chains"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unfollowUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unsubscribeFromEmailType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UnsubscribeFromEmailTypeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUnsubscribeFromEmailTypeInput2githubcomSplitFigosplitfigraphqlmodelUnsubscribeFromEmailTypeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCollectionHidden_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateCollectionHiddenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateCollectionHiddenInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionHiddenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCollectionInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateCollectionInfoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateCollectionInfoInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCollectionTokens_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateCollectionTokensInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateCollectionTokensInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionTokensInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEmailNotificationSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateEmailNotificationSettingsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateEmailNotificationSettingsInput2githubcomSplitFigosplitfigraphqlmodelUpdateEmailNotificationSettingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEmail_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateEmailInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateEmailInput2githubcomSplitFigosplitfigraphqlmodelUpdateEmailInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFeaturedSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["splitId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["splitId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateNotificationSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.NotificationSettingsInput
	if tmp, ok := rawArgs["settings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("settings"))
		arg0, err = ec.unmarshalONotificationSettingsInput2githubcomSplitFigosplitfigraphqlmodelNotificationSettingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["settings"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePrimaryWallet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["walletID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("walletID"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["walletID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSocialAccountDisplayed_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSocialAccountDisplayedInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSocialAccountDisplayedInput2githubcomSplitFigosplitfigraphqlmodelUpdateSocialAccountDisplayedInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplitCollections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitCollectionsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitCollectionsInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitCollectionsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplitHidden_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitHiddenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitHiddenInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitHiddenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplitInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitInfoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitInfoInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplitOrder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitOrderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitOrderInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitOrderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateSplitInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateSplitInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTokenInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateTokenInfoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateTokenInfoInput2githubcomSplitFigosplitfigraphqlmodelUpdateTokenInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserExperience_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateUserExperienceInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateUserExperienceInput2githubcomSplitFigosplitfigraphqlmodelUpdateUserExperienceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateUserInfoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateUserInfoInput2githubcomSplitFigosplitfigraphqlmodelUpdateUserInfoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_uploadPersistedQueries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.UploadPersistedQueriesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOUploadPersistedQueriesInput2githubcomSplitFigosplitfigraphqlmodelUploadPersistedQueriesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_verifyEmail_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.VerifyEmailInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNVerifyEmailInput2githubcomSplitFigosplitfigraphqlmodelVerifyEmailInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_viewSplit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["splitId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["splitId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_collectionById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_collectionTokenById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["tokenId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenId"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenId"] = arg0
	var arg1 persist.DBID
	if tmp, ok := rawArgs["collectionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectionId"))
		arg1, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["collectionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_collectionsByIds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []persist.DBID
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_communityByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.ChainAddress
	if tmp, ok := rawArgs["communityAddress"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("communityAddress"))
		arg0, err = ec.unmarshalNChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["communityAddress"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["forceRefresh"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forceRefresh"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["forceRefresh"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_membershipTiers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["forceRefresh"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forceRefresh"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["forceRefresh"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.GqlID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_searchCommunities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *float64
	if tmp, ok := rawArgs["nameWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameWeight"))
		arg2, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["nameWeight"] = arg2
	var arg3 *float64
	if tmp, ok := rawArgs["descriptionWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionWeight"))
		arg3, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["descriptionWeight"] = arg3
	var arg4 *float64
	if tmp, ok := rawArgs["poapAddressWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poapAddressWeight"))
		arg4, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poapAddressWeight"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_searchSplits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *float64
	if tmp, ok := rawArgs["nameWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameWeight"))
		arg2, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["nameWeight"] = arg2
	var arg3 *float64
	if tmp, ok := rawArgs["descriptionWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionWeight"))
		arg3, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["descriptionWeight"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_searchUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *float64
	if tmp, ok := rawArgs["usernameWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameWeight"))
		arg2, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["usernameWeight"] = arg2
	var arg3 *float64
	if tmp, ok := rawArgs["bioWeight"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bioWeight"))
		arg3, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["bioWeight"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_socialConnections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.SocialProvider
	if tmp, ok := rawArgs["socialAccountType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("socialAccountType"))
		arg0, err = ec.unmarshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["socialAccountType"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["excludeAlreadyFollowing"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeAlreadyFollowing"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["excludeAlreadyFollowing"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg5, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_splitById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tokenById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.ChainAddress
	if tmp, ok := rawArgs["chainAddress"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddress"))
		arg0, err = ec.unmarshalNChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chainAddress"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userByUsername_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_usersByRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.Role
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg0, err = ec.unmarshalNRole2githubcomSplitFigosplitfiservicepersistRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_usersWithTrait_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["trait"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trait"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["trait"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_viewerSplitById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.DBID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_SocialQueries_socialConnections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.SocialProvider
	if tmp, ok := rawArgs["socialAccountType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("socialAccountType"))
		arg0, err = ec.unmarshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["socialAccountType"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["excludeAlreadyFollowing"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeAlreadyFollowing"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["excludeAlreadyFollowing"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg5, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg5
	return args, nil
}

func (ec *executionContext) field_SomeoneFollowedYouBackNotification_followers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field_SomeoneFollowedYouNotification_followers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field_SomeoneViewedYourSplitNotification_userViewers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field_SplitFiUser_sharedCommunities_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field_SplitFiUser_sharedFollowers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field_SplitFiUser_tokensByChain_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 persist.Chain
	if tmp, ok := rawArgs["chain"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
		arg0, err = ec.unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chain"] = arg0
	return args, nil
}

func (ec *executionContext) field_Viewer_notifications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddUserWalletPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.AddUserWalletPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AddUserWalletPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AddUserWalletPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AddUserWalletPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminAddWalletPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.AdminAddWalletPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminAddWalletPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminAddWalletPayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminAddWalletPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AudioMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.AudioMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AudioMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AudioMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AudioMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthNonce_nonce(ctx context.Context, field graphql.CollectedField, obj *model.AuthNonce) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthNonce_nonce(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthNonce_nonce(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthNonce",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthNonce_userExists(ctx context.Context, field graphql.CollectedField, obj *model.AuthNonce) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthNonce_userExists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserExists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthNonce_userExists(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthNonce",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Badge_name(ctx context.Context, field graphql.CollectedField, obj *model.Badge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Badge_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Badge_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Badge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Badge_imageURL(ctx context.Context, field graphql.CollectedField, obj *model.Badge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Badge_imageURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Badge_imageURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Badge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Badge_contract(ctx context.Context, field graphql.CollectedField, obj *model.Badge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Badge_contract(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contract, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Contract)
	fc.Result = res
	return ec.marshalOContract2githubcomSplitFigosplitfigraphqlmodelContract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Badge_contract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Badge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Contract_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Contract_dbid(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Contract_lastUpdated(ctx, field)
			case "contractAddress":
				return ec.fieldContext_Contract_contractAddress(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Contract_creatorAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Contract_chain(ctx, field)
			case "name":
				return ec.fieldContext_Contract_name(ctx, field)
			case "profileImageURL":
				return ec.fieldContext_Contract_profileImageURL(ctx, field)
			case "profileBannerURL":
				return ec.fieldContext_Contract_profileBannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Contract_badgeURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainAddress_address(ctx context.Context, field graphql.CollectedField, obj *persist.ChainAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainAddress_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(persist.Address)
	fc.Result = res
	return ec.marshalOAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainAddress_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainAddress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainAddress_chain(ctx context.Context, field graphql.CollectedField, obj *persist.ChainAddress) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainAddress_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainAddress_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainAddress",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainPubKey_pubKey(ctx context.Context, field graphql.CollectedField, obj *persist.ChainPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainPubKey_pubKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PubKey(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(persist.PubKey)
	fc.Result = res
	return ec.marshalOPubKey2githubcomSplitFigosplitfiservicepersistPubKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainPubKey_pubKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainPubKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PubKey does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainPubKey_chain(ctx context.Context, field graphql.CollectedField, obj *persist.ChainPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainPubKey_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainPubKey_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainPubKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainTokens_chain(ctx context.Context, field graphql.CollectedField, obj *model.ChainTokens) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainTokens_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainTokens_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainTokens",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChainTokens_tokens(ctx context.Context, field graphql.CollectedField, obj *model.ChainTokens) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChainTokens_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Token)
	fc.Result = res
	return ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChainTokens_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChainTokens",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Token_collectorsNote(ctx, field)
			case "media":
				return ec.fieldContext_Token_media(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "description":
				return ec.fieldContext_Token_description(ctx, field)
			case "tokenId":
				return ec.fieldContext_Token_tokenId(ctx, field)
			case "quantity":
				return ec.fieldContext_Token_quantity(ctx, field)
			case "owner":
				return ec.fieldContext_Token_owner(ctx, field)
			case "ownedByWallets":
				return ec.fieldContext_Token_ownedByWallets(ctx, field)
			case "ownershipHistory":
				return ec.fieldContext_Token_ownershipHistory(ctx, field)
			case "tokenMetadata":
				return ec.fieldContext_Token_tokenMetadata(ctx, field)
			case "contract":
				return ec.fieldContext_Token_contract(ctx, field)
			case "externalUrl":
				return ec.fieldContext_Token_externalUrl(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpamByUser":
				return ec.fieldContext_Token_isSpamByUser(ctx, field)
			case "isSpamByProvider":
				return ec.fieldContext_Token_isSpamByProvider(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Token_creatorAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClearAllNotificationsPayload_notifications(ctx context.Context, field graphql.CollectedField, obj *model.ClearAllNotificationsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClearAllNotificationsPayload_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Notification)
	fc.Result = res
	return ec.marshalONotification2githubcomSplitFigosplitfigraphqlmodelNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClearAllNotificationsPayload_notifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClearAllNotificationsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_id(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_version(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_name(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_collectorsNote(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_collectorsNote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CollectorsNote, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_collectorsNote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_split(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Collection().Split(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_layout(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CollectionLayout)
	fc.Result = res
	return ec.marshalOCollectionLayout2githubcomSplitFigosplitfigraphqlmodelCollectionLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_layout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sections":
				return ec.fieldContext_CollectionLayout_sections(ctx, field)
			case "sectionLayout":
				return ec.fieldContext_CollectionLayout_sectionLayout(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CollectionLayout", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_hidden(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_hidden(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Collection_tokens(ctx context.Context, field graphql.CollectedField, obj *model.Collection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Collection_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Collection().Tokens(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CollectionToken)
	fc.Result = res
	return ec.marshalOCollectionToken2githubcomSplitFigosplitfigraphqlmodelCollectionToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Collection_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Collection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CollectionToken_id(ctx, field)
			case "token":
				return ec.fieldContext_CollectionToken_token(ctx, field)
			case "collection":
				return ec.fieldContext_CollectionToken_collection(ctx, field)
			case "tokenSettings":
				return ec.fieldContext_CollectionToken_tokenSettings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CollectionToken", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Collection_tokens_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _CollectionLayout_sections(ctx context.Context, field graphql.CollectedField, obj *model.CollectionLayout) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionLayout_sections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionLayout_sections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionLayout",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CollectionLayout_sectionLayout(ctx context.Context, field graphql.CollectedField, obj *model.CollectionLayout) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionLayout_sectionLayout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectionLayout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CollectionSectionLayout)
	fc.Result = res
	return ec.marshalOCollectionSectionLayout2githubcomSplitFigosplitfigraphqlmodelCollectionSectionLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionLayout_sectionLayout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionLayout",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "columns":
				return ec.fieldContext_CollectionSectionLayout_columns(ctx, field)
			case "whitespace":
				return ec.fieldContext_CollectionSectionLayout_whitespace(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CollectionSectionLayout", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CollectionSectionLayout_columns(ctx context.Context, field graphql.CollectedField, obj *model.CollectionSectionLayout) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionSectionLayout_columns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Columns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionSectionLayout_columns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionSectionLayout",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CollectionSectionLayout_whitespace(ctx context.Context, field graphql.CollectedField, obj *model.CollectionSectionLayout) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionSectionLayout_whitespace(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Whitespace, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionSectionLayout_whitespace(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionSectionLayout",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CollectionToken_id(ctx context.Context, field graphql.CollectedField, obj *model.CollectionToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionToken_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionToken_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionToken",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CollectionToken_token(ctx context.Context, field graphql.CollectedField, obj *model.CollectionToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionToken_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CollectionToken().Token(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Token)
	fc.Result = res
	return ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionToken_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionToken",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Token_collectorsNote(ctx, field)
			case "media":
				return ec.fieldContext_Token_media(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "description":
				return ec.fieldContext_Token_description(ctx, field)
			case "tokenId":
				return ec.fieldContext_Token_tokenId(ctx, field)
			case "quantity":
				return ec.fieldContext_Token_quantity(ctx, field)
			case "owner":
				return ec.fieldContext_Token_owner(ctx, field)
			case "ownedByWallets":
				return ec.fieldContext_Token_ownedByWallets(ctx, field)
			case "ownershipHistory":
				return ec.fieldContext_Token_ownershipHistory(ctx, field)
			case "tokenMetadata":
				return ec.fieldContext_Token_tokenMetadata(ctx, field)
			case "contract":
				return ec.fieldContext_Token_contract(ctx, field)
			case "externalUrl":
				return ec.fieldContext_Token_externalUrl(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpamByUser":
				return ec.fieldContext_Token_isSpamByUser(ctx, field)
			case "isSpamByProvider":
				return ec.fieldContext_Token_isSpamByProvider(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Token_creatorAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CollectionToken_collection(ctx context.Context, field graphql.CollectedField, obj *model.CollectionToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionToken_collection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CollectionToken().Collection(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Collection)
	fc.Result = res
	return ec.marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionToken_collection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionToken",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Collection_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Collection_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Collection_version(ctx, field)
			case "name":
				return ec.fieldContext_Collection_name(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Collection_collectorsNote(ctx, field)
			case "split":
				return ec.fieldContext_Collection_split(ctx, field)
			case "layout":
				return ec.fieldContext_Collection_layout(ctx, field)
			case "hidden":
				return ec.fieldContext_Collection_hidden(ctx, field)
			case "tokens":
				return ec.fieldContext_Collection_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Collection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CollectionToken_tokenSettings(ctx context.Context, field graphql.CollectedField, obj *model.CollectionToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionToken_tokenSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CollectionToken().TokenSettings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CollectionTokenSettings)
	fc.Result = res
	return ec.marshalOCollectionTokenSettings2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionToken_tokenSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionToken",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "renderLive":
				return ec.fieldContext_CollectionTokenSettings_renderLive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CollectionTokenSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CollectionTokenSettings_renderLive(ctx context.Context, field graphql.CollectedField, obj *model.CollectionTokenSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CollectionTokenSettings_renderLive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RenderLive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CollectionTokenSettings_renderLive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CollectionTokenSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommunitiesConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.CommunitiesConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommunitiesConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CommunityEdge)
	fc.Result = res
	return ec.marshalOCommunityEdge2githubcomSplitFigosplitfigraphqlmodelCommunityEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommunitiesConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommunitiesConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_CommunityEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_CommunityEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommunityEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommunitiesConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.CommunitiesConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommunitiesConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommunitiesConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommunitiesConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_id(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_contractAddress(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_contractAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContractAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_contractAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_creatorAddress(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_creatorAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatorAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_creatorAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_chain(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_name(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_description(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_previewImage(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_previewImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_previewImage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_profileImageURL(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_profileImageURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_profileImageURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_profileBannerURL(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_profileBannerURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileBannerURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_profileBannerURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_badgeURL(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_badgeURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BadgeURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_badgeURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Community_tokensInCommunity(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_tokensInCommunity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Community().TokensInCommunity(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["onlySplitFiUsers"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TokensConnection)
	fc.Result = res
	return ec.marshalOTokensConnection2githubcomSplitFigosplitfigraphqlmodelTokensConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_tokensInCommunity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TokensConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TokensConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TokensConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Community_tokensInCommunity_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Community_owners(ctx context.Context, field graphql.CollectedField, obj *model.Community) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Community_owners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Community().Owners(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["onlySplitFiUsers"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TokenHoldersConnection)
	fc.Result = res
	return ec.marshalOTokenHoldersConnection2githubcomSplitFigosplitfigraphqlmodelTokenHoldersConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Community_owners(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Community",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TokenHoldersConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TokenHoldersConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TokenHoldersConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Community_owners_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _CommunityEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.CommunityEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommunityEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Community)
	fc.Result = res
	return ec.marshalOCommunity2githubcomSplitFigosplitfigraphqlmodelCommunity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommunityEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommunityEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dbid":
				return ec.fieldContext_Community_dbid(ctx, field)
			case "id":
				return ec.fieldContext_Community_id(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Community_lastUpdated(ctx, field)
			case "contractAddress":
				return ec.fieldContext_Community_contractAddress(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Community_creatorAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Community_chain(ctx, field)
			case "name":
				return ec.fieldContext_Community_name(ctx, field)
			case "description":
				return ec.fieldContext_Community_description(ctx, field)
			case "previewImage":
				return ec.fieldContext_Community_previewImage(ctx, field)
			case "profileImageURL":
				return ec.fieldContext_Community_profileImageURL(ctx, field)
			case "profileBannerURL":
				return ec.fieldContext_Community_profileBannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Community_badgeURL(ctx, field)
			case "tokensInCommunity":
				return ec.fieldContext_Community_tokensInCommunity(ctx, field)
			case "owners":
				return ec.fieldContext_Community_owners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Community", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommunityEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.CommunityEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommunityEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommunityEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommunityEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommunitySearchResult_community(ctx context.Context, field graphql.CollectedField, obj *model.CommunitySearchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommunitySearchResult_community(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Community, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Community)
	fc.Result = res
	return ec.marshalOCommunity2githubcomSplitFigosplitfigraphqlmodelCommunity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommunitySearchResult_community(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommunitySearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dbid":
				return ec.fieldContext_Community_dbid(ctx, field)
			case "id":
				return ec.fieldContext_Community_id(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Community_lastUpdated(ctx, field)
			case "contractAddress":
				return ec.fieldContext_Community_contractAddress(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Community_creatorAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Community_chain(ctx, field)
			case "name":
				return ec.fieldContext_Community_name(ctx, field)
			case "description":
				return ec.fieldContext_Community_description(ctx, field)
			case "previewImage":
				return ec.fieldContext_Community_previewImage(ctx, field)
			case "profileImageURL":
				return ec.fieldContext_Community_profileImageURL(ctx, field)
			case "profileBannerURL":
				return ec.fieldContext_Community_profileBannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Community_badgeURL(ctx, field)
			case "tokensInCommunity":
				return ec.fieldContext_Community_tokensInCommunity(ctx, field)
			case "owners":
				return ec.fieldContext_Community_owners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Community", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectSocialAccountPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.ConnectSocialAccountPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectSocialAccountPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectSocialAccountPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectSocialAccountPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_id(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_contractAddress(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_contractAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContractAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_contractAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_creatorAddress(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_creatorAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatorAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_creatorAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_chain(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_name(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_profileImageURL(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_profileImageURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_profileImageURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_profileBannerURL(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_profileBannerURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileBannerURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_profileBannerURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_badgeURL(ctx context.Context, field graphql.CollectedField, obj *model.Contract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Contract_badgeURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BadgeURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Contract_badgeURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateCollectionPayload_collection(ctx context.Context, field graphql.CollectedField, obj *model.CreateCollectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateCollectionPayload_collection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Collection, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Collection)
	fc.Result = res
	return ec.marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateCollectionPayload_collection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateCollectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Collection_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Collection_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Collection_version(ctx, field)
			case "name":
				return ec.fieldContext_Collection_name(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Collection_collectorsNote(ctx, field)
			case "split":
				return ec.fieldContext_Collection_split(ctx, field)
			case "layout":
				return ec.fieldContext_Collection_layout(ctx, field)
			case "hidden":
				return ec.fieldContext_Collection_hidden(ctx, field)
			case "tokens":
				return ec.fieldContext_Collection_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Collection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateSplitPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.CreateSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateSplitPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateSplitPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateUserPayload_userId(ctx context.Context, field graphql.CollectedField, obj *model.CreateUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateUserPayload_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.DBID)
	fc.Result = res
	return ec.marshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateUserPayload_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateUserPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateUserPayload_splitId(ctx context.Context, field graphql.CollectedField, obj *model.CreateUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateUserPayload_splitId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SplitID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.DBID)
	fc.Result = res
	return ec.marshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateUserPayload_splitId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateUserPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateUserPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.CreateUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateUserPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateUserPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateUserPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeepRefreshPayload_chain(ctx context.Context, field graphql.CollectedField, obj *model.DeepRefreshPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeepRefreshPayload_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeepRefreshPayload_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeepRefreshPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeepRefreshPayload_submitted(ctx context.Context, field graphql.CollectedField, obj *model.DeepRefreshPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeepRefreshPayload_submitted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Submitted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeepRefreshPayload_submitted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeepRefreshPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteCollectionPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.DeleteCollectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteCollectionPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteCollectionPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteCollectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteSplitPayload_deletedId(ctx context.Context, field graphql.CollectedField, obj *model.DeleteSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteSplitPayload_deletedId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DeletedNode)
	fc.Result = res
	return ec.marshalODeletedNode2githubcomSplitFigosplitfigraphqlmodelDeletedNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteSplitPayload_deletedId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DeletedNode_id(ctx, field)
			case "dbid":
				return ec.fieldContext_DeletedNode_dbid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeletedNode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedNode_id(ctx context.Context, field graphql.CollectedField, obj *model.DeletedNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedNode_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedNode_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedNode",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeletedNode_dbid(ctx context.Context, field graphql.CollectedField, obj *model.DeletedNode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeletedNode_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeletedNode_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeletedNode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DisconnectSocialAccountPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.DisconnectSocialAccountPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DisconnectSocialAccountPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DisconnectSocialAccountPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DisconnectSocialAccountPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmailNotificationSettings_unsubscribedFromAll(ctx context.Context, field graphql.CollectedField, obj *model.EmailNotificationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmailNotificationSettings_unsubscribedFromAll(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnsubscribedFromAll, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmailNotificationSettings_unsubscribedFromAll(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmailNotificationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EmailNotificationSettings_unsubscribedFromNotifications(ctx context.Context, field graphql.CollectedField, obj *model.EmailNotificationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EmailNotificationSettings_unsubscribedFromNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnsubscribedFromNotifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EmailNotificationSettings_unsubscribedFromNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EmailNotificationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrAddressOwnedByUser_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrAddressOwnedByUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrAddressOwnedByUser_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrAddressOwnedByUser_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrAddressOwnedByUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrAuthenticationFailed_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrAuthenticationFailed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrAuthenticationFailed_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrAuthenticationFailed_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrAuthenticationFailed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrCollectionNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrCollectionNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrCollectionNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrCollectionNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrCollectionNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrCommunityNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrCommunityNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrCommunityNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrCommunityNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrCommunityNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrDoesNotOwnRequiredToken_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrDoesNotOwnRequiredToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrDoesNotOwnRequiredToken_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrDoesNotOwnRequiredToken_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrDoesNotOwnRequiredToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrInvalidInput_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrInvalidInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrInvalidInput_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrInvalidInput_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrInvalidInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrInvalidInput_parameters(ctx context.Context, field graphql.CollectedField, obj *model.ErrInvalidInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrInvalidInput_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrInvalidInput_parameters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrInvalidInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrInvalidInput_reasons(ctx context.Context, field graphql.CollectedField, obj *model.ErrInvalidInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrInvalidInput_reasons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reasons, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrInvalidInput_reasons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrInvalidInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrInvalidToken_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrInvalidToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrInvalidToken_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrInvalidToken_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrInvalidToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrNeedsToReconnectSocial_socialAccountType(ctx context.Context, field graphql.CollectedField, obj *model.ErrNeedsToReconnectSocial) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrNeedsToReconnectSocial_socialAccountType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SocialAccountType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.SocialProvider)
	fc.Result = res
	return ec.marshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrNeedsToReconnectSocial_socialAccountType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrNeedsToReconnectSocial",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SocialAccountType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrNeedsToReconnectSocial_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrNeedsToReconnectSocial) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrNeedsToReconnectSocial_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrNeedsToReconnectSocial_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrNeedsToReconnectSocial",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrNoCookie_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrNoCookie) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrNoCookie_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrNoCookie_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrNoCookie",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrNotAuthorized_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrNotAuthorized) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrNotAuthorized_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrNotAuthorized_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrNotAuthorized",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrNotAuthorized_cause(ctx context.Context, field graphql.CollectedField, obj *model.ErrNotAuthorized) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrNotAuthorized_cause(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cause, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AuthorizationError)
	fc.Result = res
	return ec.marshalNAuthorizationError2githubcomSplitFigosplitfigraphqlmodelAuthorizationError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrNotAuthorized_cause(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrNotAuthorized",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AuthorizationError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrSplitNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrSplitNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrSplitNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrSplitNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrSplitNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrSyncFailed_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrSyncFailed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrSyncFailed_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrSyncFailed_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrSyncFailed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrTokenNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrTokenNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrTokenNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrTokenNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrTokenNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrUserAlreadyExists_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrUserAlreadyExists) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrUserAlreadyExists_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrUserAlreadyExists_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrUserAlreadyExists",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrUserNotFound_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrUserNotFound) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrUserNotFound_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrUserNotFound_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrUserNotFound",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ErrUsernameNotAvailable_message(ctx context.Context, field graphql.CollectedField, obj *model.ErrUsernameNotAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ErrUsernameNotAvailable_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ErrUsernameNotAvailable_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ErrUsernameNotAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FollowAllSocialConnectionsPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.FollowAllSocialConnectionsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FollowAllSocialConnectionsPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FollowAllSocialConnectionsPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FollowAllSocialConnectionsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FollowInfo_user(ctx context.Context, field graphql.CollectedField, obj *model.FollowInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FollowInfo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FollowInfo().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FollowInfo_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FollowInfo",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FollowInfo_followedBack(ctx context.Context, field graphql.CollectedField, obj *model.FollowInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FollowInfo_followedBack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FollowedBack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FollowInfo_followedBack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FollowInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FollowUserPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.FollowUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FollowUserPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FollowUserPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FollowUserPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FollowUserPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.FollowUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FollowUserPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FollowUserPayload().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FollowUserPayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FollowUserPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_staticPreviewURLs(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_staticPreviewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticPreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_staticPreviewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GIFMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.GIFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GIFMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GIFMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GIFMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GltfMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.GltfMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GltfMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GltfMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GltfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupNotificationUserEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.GroupNotificationUserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupNotificationUserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupNotificationUserEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupNotificationUserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupNotificationUserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.GroupNotificationUserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupNotificationUserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupNotificationUserEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupNotificationUserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupNotificationUsersConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.GroupNotificationUsersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupNotificationUsersConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GroupNotificationUserEdge)
	fc.Result = res
	return ec.marshalOGroupNotificationUserEdge2githubcomSplitFigosplitfigraphqlmodelGroupNotificationUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupNotificationUsersConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupNotificationUsersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GroupNotificationUserEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GroupNotificationUserEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupNotificationUserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupNotificationUsersConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.GroupNotificationUsersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupNotificationUsersConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalOPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupNotificationUsersConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupNotificationUsersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HtmlMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.HTMLMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HtmlMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HtmlMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HtmlMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.ImageMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvalidMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.InvalidMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvalidMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvalidMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvalidMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JsonMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.JSONMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JsonMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JsonMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JsonMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginPayload_userId(ctx context.Context, field graphql.CollectedField, obj *model.LoginPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginPayload_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.DBID)
	fc.Result = res
	return ec.marshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginPayload_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.LoginPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogoutPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.LogoutPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogoutPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogoutPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogoutPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MediaDimensions_width(ctx context.Context, field graphql.CollectedField, obj *model.MediaDimensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MediaDimensions_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MediaDimensions_width(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MediaDimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MediaDimensions_height(ctx context.Context, field graphql.CollectedField, obj *model.MediaDimensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MediaDimensions_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MediaDimensions_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MediaDimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MediaDimensions_aspectRatio(ctx context.Context, field graphql.CollectedField, obj *model.MediaDimensions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AspectRatio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MediaDimensions_aspectRatio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MediaDimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MembershipTier_id(ctx context.Context, field graphql.CollectedField, obj *model.MembershipTier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MembershipTier_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MembershipTier_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MembershipTier",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MembershipTier_dbid(ctx context.Context, field graphql.CollectedField, obj *model.MembershipTier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MembershipTier_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MembershipTier_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MembershipTier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MembershipTier_name(ctx context.Context, field graphql.CollectedField, obj *model.MembershipTier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MembershipTier_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MembershipTier_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MembershipTier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MembershipTier_assetUrl(ctx context.Context, field graphql.CollectedField, obj *model.MembershipTier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MembershipTier_assetUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MembershipTier_assetUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MembershipTier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MembershipTier_tokenId(ctx context.Context, field graphql.CollectedField, obj *model.MembershipTier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MembershipTier_tokenId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MembershipTier_tokenId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MembershipTier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MembershipTier_owners(ctx context.Context, field graphql.CollectedField, obj *model.MembershipTier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MembershipTier_owners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TokenHolder)
	fc.Result = res
	return ec.marshalOTokenHolder2githubcomSplitFigosplitfigraphqlmodelTokenHolder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MembershipTier_owners(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MembershipTier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_TokenHolder_displayName(ctx, field)
			case "wallets":
				return ec.fieldContext_TokenHolder_wallets(ctx, field)
			case "user":
				return ec.fieldContext_TokenHolder_user(ctx, field)
			case "previewTokens":
				return ec.fieldContext_TokenHolder_previewTokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TokenHolder", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MintPremiumCardToWalletPayload_tx(ctx context.Context, field graphql.CollectedField, obj *model.MintPremiumCardToWalletPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MintPremiumCardToWalletPayload_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MintPremiumCardToWalletPayload_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MintPremiumCardToWalletPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MoveCollectionToSplitPayload_oldSplit(ctx context.Context, field graphql.CollectedField, obj *model.MoveCollectionToSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MoveCollectionToSplitPayload_oldSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldSplit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MoveCollectionToSplitPayload_oldSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MoveCollectionToSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MoveCollectionToSplitPayload_newSplit(ctx context.Context, field graphql.CollectedField, obj *model.MoveCollectionToSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MoveCollectionToSplitPayload_newSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewSplit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MoveCollectionToSplitPayload_newSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MoveCollectionToSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addUserWallet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addUserWallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddUserWallet(rctx, fc.Args["chainAddress"].(persist.ChainAddress), fc.Args["authMechanism"].(model.AuthMechanism))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.AddUserWalletPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.AddUserWalletPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.AddUserWalletPayloadOrError)
	fc.Result = res
	return ec.marshalOAddUserWalletPayloadOrError2githubcomSplitFigosplitfigraphqlmodelAddUserWalletPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addUserWallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AddUserWalletPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addUserWallet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeUserWallets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeUserWallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RemoveUserWallets(rctx, fc.Args["walletIds"].([]persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.RemoveUserWalletsPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.RemoveUserWalletsPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.RemoveUserWalletsPayloadOrError)
	fc.Result = res
	return ec.marshalORemoveUserWalletsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRemoveUserWalletsPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeUserWallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RemoveUserWalletsPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeUserWallets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUserInfo(rctx, fc.Args["input"].(model.UpdateUserInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateUserInfoPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateUserInfoPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateUserInfoPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateUserInfoPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateUserInfoPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateUserInfoPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplitCollections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplitCollections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplitCollections(rctx, fc.Args["input"].(model.UpdateSplitCollectionsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitCollectionsPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitCollectionsPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitCollectionsPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitCollectionsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitCollectionsPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplitCollections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitCollectionsPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplitCollections_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCollection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCollection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateCollection(rctx, fc.Args["input"].(model.CreateCollectionInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateCollectionPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.CreateCollectionPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CreateCollectionPayloadOrError)
	fc.Result = res
	return ec.marshalOCreateCollectionPayloadOrError2githubcomSplitFigosplitfigraphqlmodelCreateCollectionPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCollection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateCollectionPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCollection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCollection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteCollection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteCollection(rctx, fc.Args["collectionId"].(persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteCollectionPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.DeleteCollectionPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.DeleteCollectionPayloadOrError)
	fc.Result = res
	return ec.marshalODeleteCollectionPayloadOrError2githubcomSplitFigosplitfigraphqlmodelDeleteCollectionPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteCollection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteCollectionPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCollection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCollectionInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCollectionInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateCollectionInfo(rctx, fc.Args["input"].(model.UpdateCollectionInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateCollectionInfoPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateCollectionInfoPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateCollectionInfoPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateCollectionInfoPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionInfoPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCollectionInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateCollectionInfoPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCollectionInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCollectionTokens(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCollectionTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateCollectionTokens(rctx, fc.Args["input"].(model.UpdateCollectionTokensInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateCollectionTokensPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateCollectionTokensPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateCollectionTokensPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateCollectionTokensPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionTokensPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCollectionTokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateCollectionTokensPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCollectionTokens_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCollectionHidden(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCollectionHidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateCollectionHidden(rctx, fc.Args["input"].(model.UpdateCollectionHiddenInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateCollectionHiddenPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateCollectionHiddenPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateCollectionHiddenPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateCollectionHiddenPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionHiddenPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCollectionHidden(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateCollectionHiddenPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCollectionHidden_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTokenInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTokenInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTokenInfo(rctx, fc.Args["input"].(model.UpdateTokenInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateTokenInfoPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateTokenInfoPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateTokenInfoPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateTokenInfoPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateTokenInfoPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTokenInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateTokenInfoPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTokenInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setSpamPreference(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setSpamPreference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SetSpamPreference(rctx, fc.Args["input"].(model.SetSpamPreferenceInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.SetSpamPreferencePayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.SetSpamPreferencePayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SetSpamPreferencePayloadOrError)
	fc.Result = res
	return ec.marshalOSetSpamPreferencePayloadOrError2githubcomSplitFigosplitfigraphqlmodelSetSpamPreferencePayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setSpamPreference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SetSpamPreferencePayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setSpamPreference_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_syncTokens(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_syncTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SyncTokens(rctx, fc.Args["chains"].([]persist.Chain))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.SyncTokensPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.SyncTokensPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SyncTokensPayloadOrError)
	fc.Result = res
	return ec.marshalOSyncTokensPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSyncTokensPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_syncTokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SyncTokensPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_syncTokens_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshToken(rctx, fc.Args["tokenId"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.RefreshTokenPayloadOrError)
	fc.Result = res
	return ec.marshalORefreshTokenPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRefreshTokenPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RefreshTokenPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refreshToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshCollection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshCollection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshCollection(rctx, fc.Args["collectionId"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.RefreshCollectionPayloadOrError)
	fc.Result = res
	return ec.marshalORefreshCollectionPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRefreshCollectionPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshCollection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RefreshCollectionPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refreshCollection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshContract(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshContract(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshContract(rctx, fc.Args["contractId"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.RefreshContractPayloadOrError)
	fc.Result = res
	return ec.marshalORefreshContractPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRefreshContractPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshContract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RefreshContractPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refreshContract_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deepRefresh(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deepRefresh(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeepRefresh(rctx, fc.Args["input"].(model.DeepRefreshInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeepRefreshPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.DeepRefreshPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.DeepRefreshPayloadOrError)
	fc.Result = res
	return ec.marshalODeepRefreshPayloadOrError2githubcomSplitFigosplitfigraphqlmodelDeepRefreshPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deepRefresh(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeepRefreshPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deepRefresh_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_getAuthNonce(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_getAuthNonce(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GetAuthNonce(rctx, fc.Args["chainAddress"].(persist.ChainAddress))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.GetAuthNoncePayloadOrError)
	fc.Result = res
	return ec.marshalOGetAuthNoncePayloadOrError2githubcomSplitFigosplitfigraphqlmodelGetAuthNoncePayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_getAuthNonce(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type GetAuthNoncePayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_getAuthNonce_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["authMechanism"].(model.AuthMechanism), fc.Args["input"].(model.CreateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CreateUserPayloadOrError)
	fc.Result = res
	return ec.marshalOCreateUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelCreateUserPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateUserPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEmail(rctx, fc.Args["input"].(model.UpdateEmailInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEmailPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateEmailPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateEmailPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateEmailPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateEmailPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEmailPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEmail_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resendVerificationEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_resendVerificationEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ResendVerificationEmail(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.ResendVerificationEmailPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.ResendVerificationEmailPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ResendVerificationEmailPayloadOrError)
	fc.Result = res
	return ec.marshalOResendVerificationEmailPayloadOrError2githubcomSplitFigosplitfigraphqlmodelResendVerificationEmailPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_resendVerificationEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ResendVerificationEmailPayloadOrError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEmailNotificationSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEmailNotificationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEmailNotificationSettings(rctx, fc.Args["input"].(model.UpdateEmailNotificationSettingsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateEmailNotificationSettingsPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateEmailNotificationSettingsPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateEmailNotificationSettingsPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateEmailNotificationSettingsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateEmailNotificationSettingsPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEmailNotificationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateEmailNotificationSettingsPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEmailNotificationSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unsubscribeFromEmailType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unsubscribeFromEmailType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnsubscribeFromEmailType(rctx, fc.Args["input"].(model.UnsubscribeFromEmailTypeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UnsubscribeFromEmailTypePayloadOrError)
	fc.Result = res
	return ec.marshalOUnsubscribeFromEmailTypePayloadOrError2githubcomSplitFigosplitfigraphqlmodelUnsubscribeFromEmailTypePayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unsubscribeFromEmailType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UnsubscribeFromEmailTypePayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unsubscribeFromEmailType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_login(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Login(rctx, fc.Args["authMechanism"].(model.AuthMechanism))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.LoginPayloadOrError)
	fc.Result = res
	return ec.marshalOLoginPayloadOrError2githubcomSplitFigosplitfigraphqlmodelLoginPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LoginPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_login_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_logout(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_logout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Logout(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LogoutPayload)
	fc.Result = res
	return ec.marshalOLogoutPayload2githubcomSplitFigosplitfigraphqlmodelLogoutPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_logout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "viewer":
				return ec.fieldContext_LogoutPayload_viewer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogoutPayload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_connectSocialAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_connectSocialAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ConnectSocialAccount(rctx, fc.Args["input"].(model.SocialAuthMechanism), fc.Args["display"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.ConnectSocialAccountPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.ConnectSocialAccountPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ConnectSocialAccountPayloadOrError)
	fc.Result = res
	return ec.marshalOConnectSocialAccountPayloadOrError2githubcomSplitFigosplitfigraphqlmodelConnectSocialAccountPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_connectSocialAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectSocialAccountPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_connectSocialAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_disconnectSocialAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_disconnectSocialAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DisconnectSocialAccount(rctx, fc.Args["accountType"].(persist.SocialProvider))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DisconnectSocialAccountPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.DisconnectSocialAccountPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.DisconnectSocialAccountPayloadOrError)
	fc.Result = res
	return ec.marshalODisconnectSocialAccountPayloadOrError2githubcomSplitFigosplitfigraphqlmodelDisconnectSocialAccountPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_disconnectSocialAccount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DisconnectSocialAccountPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_disconnectSocialAccount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSocialAccountDisplayed(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSocialAccountDisplayed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSocialAccountDisplayed(rctx, fc.Args["input"].(model.UpdateSocialAccountDisplayedInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSocialAccountDisplayedPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSocialAccountDisplayedPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSocialAccountDisplayedPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSocialAccountDisplayedPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSocialAccountDisplayedPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSocialAccountDisplayed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSocialAccountDisplayedPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSocialAccountDisplayed_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_followUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_followUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FollowUser(rctx, fc.Args["userId"].(persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.FollowUserPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.FollowUserPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.FollowUserPayloadOrError)
	fc.Result = res
	return ec.marshalOFollowUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelFollowUserPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_followUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FollowUserPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_followUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_followAllSocialConnections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_followAllSocialConnections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FollowAllSocialConnections(rctx, fc.Args["accountType"].(persist.SocialProvider))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.FollowAllSocialConnectionsPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.FollowAllSocialConnectionsPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.FollowAllSocialConnectionsPayloadOrError)
	fc.Result = res
	return ec.marshalOFollowAllSocialConnectionsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelFollowAllSocialConnectionsPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_followAllSocialConnections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FollowAllSocialConnectionsPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_followAllSocialConnections_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unfollowUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unfollowUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UnfollowUser(rctx, fc.Args["userId"].(persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UnfollowUserPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UnfollowUserPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UnfollowUserPayloadOrError)
	fc.Result = res
	return ec.marshalOUnfollowUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUnfollowUserPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unfollowUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UnfollowUserPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unfollowUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_viewSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_viewSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ViewSplit(rctx, fc.Args["splitId"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ViewSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOViewSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelViewSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_viewSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ViewSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_viewSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplit(rctx, fc.Args["input"].(model.UpdateSplitInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_publishSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_publishSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PublishSplit(rctx, fc.Args["input"].(model.PublishSplitInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.PublishSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.PublishSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.PublishSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOPublishSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelPublishSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_publishSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PublishSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_publishSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateSplit(rctx, fc.Args["input"].(model.CreateSplitInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.CreateSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.CreateSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CreateSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOCreateSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelCreateSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreateSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplitHidden(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplitHidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplitHidden(rctx, fc.Args["input"].(model.UpdateSplitHiddenInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitHiddenPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitHiddenPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitHiddenPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitHiddenPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitHiddenPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplitHidden(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitHiddenPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplitHidden_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteSplit(rctx, fc.Args["splitId"].(persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.DeleteSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.DeleteSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.DeleteSplitPayloadOrError)
	fc.Result = res
	return ec.marshalODeleteSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelDeleteSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DeleteSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplitOrder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplitOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplitOrder(rctx, fc.Args["input"].(model.UpdateSplitOrderInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitOrderPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitOrderPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitOrderPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitOrderPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitOrderPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplitOrder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitOrderPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplitOrder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSplitInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSplitInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateSplitInfo(rctx, fc.Args["input"].(model.UpdateSplitInfoInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateSplitInfoPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateSplitInfoPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateSplitInfoPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateSplitInfoPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitInfoPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSplitInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateSplitInfoPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSplitInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFeaturedSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateFeaturedSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateFeaturedSplit(rctx, fc.Args["splitId"].(persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateFeaturedSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateFeaturedSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateFeaturedSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateFeaturedSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateFeaturedSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateFeaturedSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateFeaturedSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFeaturedSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_clearAllNotifications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_clearAllNotifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ClearAllNotifications(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ClearAllNotificationsPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.ClearAllNotificationsPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ClearAllNotificationsPayload)
	fc.Result = res
	return ec.marshalOClearAllNotificationsPayload2githubcomSplitFigosplitfigraphqlmodelClearAllNotificationsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_clearAllNotifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "notifications":
				return ec.fieldContext_ClearAllNotificationsPayload_notifications(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClearAllNotificationsPayload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateNotificationSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateNotificationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateNotificationSettings(rctx, fc.Args["settings"].(*model.NotificationSettingsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NotificationSettings)
	fc.Result = res
	return ec.marshalONotificationSettings2githubcomSplitFigosplitfigraphqlmodelNotificationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateNotificationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "someoneFollowedYou":
				return ec.fieldContext_NotificationSettings_someoneFollowedYou(ctx, field)
			case "someoneViewedYourSplit":
				return ec.fieldContext_NotificationSettings_someoneViewedYourSplit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateNotificationSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_preverifyEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_preverifyEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PreverifyEmail(rctx, fc.Args["input"].(model.PreverifyEmailInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.PreverifyEmailPayloadOrError)
	fc.Result = res
	return ec.marshalOPreverifyEmailPayloadOrError2githubcomSplitFigosplitfigraphqlmodelPreverifyEmailPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_preverifyEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PreverifyEmailPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_preverifyEmail_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_verifyEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_verifyEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VerifyEmail(rctx, fc.Args["input"].(model.VerifyEmailInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.VerifyEmailPayloadOrError)
	fc.Result = res
	return ec.marshalOVerifyEmailPayloadOrError2githubcomSplitFigosplitfigraphqlmodelVerifyEmailPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_verifyEmail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VerifyEmailPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_verifyEmail_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addRolesToUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addRolesToUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddRolesToUser(rctx, fc.Args["username"].(string), fc.Args["roles"].([]*persist.Role))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RetoolAuth == nil {
				return nil, errors.New("directive retoolAuth is not implemented")
			}
			return ec.directives.RetoolAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.AddRolesToUserPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.AddRolesToUserPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.AddRolesToUserPayloadOrError)
	fc.Result = res
	return ec.marshalOAddRolesToUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelAddRolesToUserPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addRolesToUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AddRolesToUserPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addRolesToUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addWalletToUserUnchecked(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addWalletToUserUnchecked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AddWalletToUserUnchecked(rctx, fc.Args["input"].(model.AdminAddWalletInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RetoolAuth == nil {
				return nil, errors.New("directive retoolAuth is not implemented")
			}
			return ec.directives.RetoolAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.AdminAddWalletPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.AdminAddWalletPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.AdminAddWalletPayloadOrError)
	fc.Result = res
	return ec.marshalOAdminAddWalletPayloadOrError2githubcomSplitFigosplitfigraphqlmodelAdminAddWalletPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addWalletToUserUnchecked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminAddWalletPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addWalletToUserUnchecked_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_revokeRolesFromUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_revokeRolesFromUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RevokeRolesFromUser(rctx, fc.Args["username"].(string), fc.Args["roles"].([]*persist.Role))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RetoolAuth == nil {
				return nil, errors.New("directive retoolAuth is not implemented")
			}
			return ec.directives.RetoolAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.RevokeRolesFromUserPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.RevokeRolesFromUserPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.RevokeRolesFromUserPayloadOrError)
	fc.Result = res
	return ec.marshalORevokeRolesFromUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRevokeRolesFromUserPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_revokeRolesFromUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RevokeRolesFromUserPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_revokeRolesFromUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_syncTokensForUsername(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_syncTokensForUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SyncTokensForUsername(rctx, fc.Args["username"].(string), fc.Args["chains"].([]persist.Chain))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RetoolAuth == nil {
				return nil, errors.New("directive retoolAuth is not implemented")
			}
			return ec.directives.RetoolAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.SyncTokensForUsernamePayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.SyncTokensForUsernamePayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SyncTokensForUsernamePayloadOrError)
	fc.Result = res
	return ec.marshalOSyncTokensForUsernamePayloadOrError2githubcomSplitFigosplitfigraphqlmodelSyncTokensForUsernamePayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_syncTokensForUsername(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SyncTokensForUsernamePayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_syncTokensForUsername_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_mintPremiumCardToWallet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_mintPremiumCardToWallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MintPremiumCardToWallet(rctx, fc.Args["input"].(model.MintPremiumCardToWalletInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RetoolAuth == nil {
				return nil, errors.New("directive retoolAuth is not implemented")
			}
			return ec.directives.RetoolAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.MintPremiumCardToWalletPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.MintPremiumCardToWalletPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.MintPremiumCardToWalletPayloadOrError)
	fc.Result = res
	return ec.marshalOMintPremiumCardToWalletPayloadOrError2githubcomSplitFigosplitfigraphqlmodelMintPremiumCardToWalletPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_mintPremiumCardToWallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MintPremiumCardToWalletPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_mintPremiumCardToWallet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_uploadPersistedQueries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_uploadPersistedQueries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UploadPersistedQueries(rctx, fc.Args["input"].(*model.UploadPersistedQueriesInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.FrontendBuildAuth == nil {
				return nil, errors.New("directive frontendBuildAuth is not implemented")
			}
			return ec.directives.FrontendBuildAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UploadPersistedQueriesPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UploadPersistedQueriesPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UploadPersistedQueriesPayloadOrError)
	fc.Result = res
	return ec.marshalOUploadPersistedQueriesPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUploadPersistedQueriesPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_uploadPersistedQueries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UploadPersistedQueriesPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_uploadPersistedQueries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePrimaryWallet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePrimaryWallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdatePrimaryWallet(rctx, fc.Args["walletID"].(persist.DBID))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdatePrimaryWalletPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdatePrimaryWalletPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdatePrimaryWalletPayloadOrError)
	fc.Result = res
	return ec.marshalOUpdatePrimaryWalletPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdatePrimaryWalletPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePrimaryWallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdatePrimaryWalletPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePrimaryWallet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserExperience(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserExperience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateUserExperience(rctx, fc.Args["input"].(model.UpdateUserExperienceInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.UpdateUserExperiencePayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.UpdateUserExperiencePayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UpdateUserExperiencePayloadOrError)
	fc.Result = res
	return ec.marshalOUpdateUserExperiencePayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateUserExperiencePayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserExperience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UpdateUserExperiencePayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserExperience_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_moveCollectionToSplit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_moveCollectionToSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().MoveCollectionToSplit(rctx, fc.Args["input"].(*model.MoveCollectionToSplitInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.MoveCollectionToSplitPayloadOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.MoveCollectionToSplitPayloadOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.MoveCollectionToSplitPayloadOrError)
	fc.Result = res
	return ec.marshalOMoveCollectionToSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelMoveCollectionToSplitPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_moveCollectionToSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MoveCollectionToSplitPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_moveCollectionToSplit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _NotificationEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.NotificationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Notification)
	fc.Result = res
	return ec.marshalONotification2githubcomSplitFigosplitfigraphqlmodelNotification(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.NotificationEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationSettings_someoneFollowedYou(ctx context.Context, field graphql.CollectedField, obj *model.NotificationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationSettings_someoneFollowedYou(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SomeoneFollowedYou, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationSettings_someoneFollowedYou(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationSettings_someoneViewedYourSplit(ctx context.Context, field graphql.CollectedField, obj *model.NotificationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationSettings_someoneViewedYourSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SomeoneViewedYourSplit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationSettings_someoneViewedYourSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationsConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.NotificationsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationsConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.NotificationEdge)
	fc.Result = res
	return ec.marshalONotificationEdge2githubcomSplitFigosplitfigraphqlmodelNotificationEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationsConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_NotificationEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_NotificationEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationsConnection_unseenCount(ctx context.Context, field graphql.CollectedField, obj *model.NotificationsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationsConnection_unseenCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnseenCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationsConnection_unseenCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotificationsConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.NotificationsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotificationsConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalOPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotificationsConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotificationsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OwnerAtBlock_owner(ctx context.Context, field graphql.CollectedField, obj *model.OwnerAtBlock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OwnerAtBlock_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OwnerAtBlock().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SplitFiUserOrAddress)
	fc.Result = res
	return ec.marshalOSplitFiUserOrAddress2githubcomSplitFigosplitfigraphqlmodelSplitFiUserOrAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OwnerAtBlock_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OwnerAtBlock",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SplitFiUserOrAddress does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OwnerAtBlock_blockNumber(ctx context.Context, field graphql.CollectedField, obj *model.OwnerAtBlock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OwnerAtBlock_blockNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OwnerAtBlock_blockNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OwnerAtBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_total(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_size(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PdfMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.PDFMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PdfMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PdfMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PdfMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreverifyEmailPayload_email(ctx context.Context, field graphql.CollectedField, obj *model.PreverifyEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreverifyEmailPayload_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.Email)
	fc.Result = res
	return ec.marshalNEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreverifyEmailPayload_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreverifyEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Email does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreverifyEmailPayload_result(ctx context.Context, field graphql.CollectedField, obj *model.PreverifyEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreverifyEmailPayload_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PreverifyEmailResult)
	fc.Result = res
	return ec.marshalNPreverifyEmailResult2githubcomSplitFigosplitfigraphqlmodelPreverifyEmailResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreverifyEmailPayload_result(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreverifyEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PreverifyEmailResult does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_raw(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_thumbnail(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Thumbnail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_thumbnail(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_small(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_small(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Small, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_small(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_medium(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_medium(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Medium, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_medium(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_large(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_large(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Large, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_large(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_srcSet(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SrcSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_srcSet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_liveRender(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveRender, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_liveRender(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreviewURLSet_blurhash(ctx context.Context, field graphql.CollectedField, obj *model.PreviewURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.PreviewURLSet().Blurhash(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Experimental == nil {
				return nil, errors.New("directive experimental is not implemented")
			}
			return ec.directives.Experimental(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreviewURLSet_blurhash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreviewURLSet",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublishSplitPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.PublishSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublishSplitPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublishSplitPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublishSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(model.GqlID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Node)
	fc.Result = res
	return ec.marshalONode2githubcomSplitFigosplitfigraphqlmodelNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Viewer(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.ViewerOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.ViewerOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ViewerOrError)
	fc.Result = res
	return ec.marshalOViewerOrError2githubcomSplitFigosplitfigraphqlmodelViewerOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ViewerOrError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userByUsername(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userByUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserByUsername(rctx, fc.Args["username"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UserByUsernameOrError)
	fc.Result = res
	return ec.marshalOUserByUsernameOrError2githubcomSplitFigosplitfigraphqlmodelUserByUsernameOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userByUsername(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserByUsernameOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userByUsername_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_userById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserByID(rctx, fc.Args["id"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UserByIDOrError)
	fc.Result = res
	return ec.marshalOUserByIdOrError2githubcomSplitFigosplitfigraphqlmodelUserByIDOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserByIdOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_userByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserByAddress(rctx, fc.Args["chainAddress"].(persist.ChainAddress))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.UserByAddressOrError)
	fc.Result = res
	return ec.marshalOUserByAddressOrError2githubcomSplitFigosplitfigraphqlmodelUserByAddressOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserByAddressOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_usersWithTrait(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_usersWithTrait(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UsersWithTrait(rctx, fc.Args["trait"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_usersWithTrait(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_usersWithTrait_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_membershipTiers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_membershipTiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MembershipTiers(rctx, fc.Args["forceRefresh"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MembershipTier)
	fc.Result = res
	return ec.marshalOMembershipTier2githubcomSplitFigosplitfigraphqlmodelMembershipTier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_membershipTiers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MembershipTier_id(ctx, field)
			case "dbid":
				return ec.fieldContext_MembershipTier_dbid(ctx, field)
			case "name":
				return ec.fieldContext_MembershipTier_name(ctx, field)
			case "assetUrl":
				return ec.fieldContext_MembershipTier_assetUrl(ctx, field)
			case "tokenId":
				return ec.fieldContext_MembershipTier_tokenId(ctx, field)
			case "owners":
				return ec.fieldContext_MembershipTier_owners(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MembershipTier", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_membershipTiers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_collectionById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_collectionById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CollectionByID(rctx, fc.Args["id"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CollectionByIDOrError)
	fc.Result = res
	return ec.marshalOCollectionByIdOrError2githubcomSplitFigosplitfigraphqlmodelCollectionByIDOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_collectionById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CollectionByIdOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_collectionById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_collectionsByIds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_collectionsByIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CollectionsByIds(rctx, fc.Args["ids"].([]persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.CollectionByIDOrError)
	fc.Result = res
	return ec.marshalOCollectionByIdOrError2githubcomSplitFigosplitfigraphqlmodelCollectionByIDOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_collectionsByIds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CollectionByIdOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_collectionsByIds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_tokenById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tokenById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TokenByID(rctx, fc.Args["id"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.TokenByIDOrError)
	fc.Result = res
	return ec.marshalOTokenByIdOrError2githubcomSplitFigosplitfigraphqlmodelTokenByIDOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tokenById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TokenByIdOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tokenById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_collectionTokenById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_collectionTokenById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CollectionTokenByID(rctx, fc.Args["tokenId"].(persist.DBID), fc.Args["collectionId"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CollectionTokenByIDOrError)
	fc.Result = res
	return ec.marshalOCollectionTokenByIdOrError2githubcomSplitFigosplitfigraphqlmodelCollectionTokenByIDOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_collectionTokenById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CollectionTokenByIdOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_collectionTokenById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_communityByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_communityByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CommunityByAddress(rctx, fc.Args["communityAddress"].(persist.ChainAddress), fc.Args["forceRefresh"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CommunityByAddressOrError)
	fc.Result = res
	return ec.marshalOCommunityByAddressOrError2githubcomSplitFigosplitfigraphqlmodelCommunityByAddressOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_communityByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CommunityByAddressOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_communityByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_generalAllowlist(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_generalAllowlist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GeneralAllowlist(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_generalAllowlist(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_splitById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_splitById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SplitByID(rctx, fc.Args["id"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SplitByIDPayloadOrError)
	fc.Result = res
	return ec.marshalOSplitByIdPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSplitByIDPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_splitById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SplitByIdPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_splitById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewerSplitById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewerSplitById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ViewerSplitByID(rctx, fc.Args["id"].(persist.DBID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ViewerSplitByIDPayloadOrError)
	fc.Result = res
	return ec.marshalOViewerSplitByIdPayloadOrError2githubcomSplitFigosplitfigraphqlmodelViewerSplitByIDPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewerSplitById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ViewerSplitByIdPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_viewerSplitById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchUsers(rctx, fc.Args["query"].(string), fc.Args["limit"].(*int), fc.Args["usernameWeight"].(*float64), fc.Args["bioWeight"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SearchUsersPayloadOrError)
	fc.Result = res
	return ec.marshalOSearchUsersPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSearchUsersPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchUsersPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchUsers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchSplits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchSplits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchSplits(rctx, fc.Args["query"].(string), fc.Args["limit"].(*int), fc.Args["nameWeight"].(*float64), fc.Args["descriptionWeight"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SearchSplitsPayloadOrError)
	fc.Result = res
	return ec.marshalOSearchSplitsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSearchSplitsPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchSplits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchSplitsPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchSplits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchCommunities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchCommunities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchCommunities(rctx, fc.Args["query"].(string), fc.Args["limit"].(*int), fc.Args["nameWeight"].(*float64), fc.Args["descriptionWeight"].(*float64), fc.Args["poapAddressWeight"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SearchCommunitiesPayloadOrError)
	fc.Result = res
	return ec.marshalOSearchCommunitiesPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSearchCommunitiesPayloadOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchCommunities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchCommunitiesPayloadOrError does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchCommunities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_usersByRole(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_usersByRole(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().UsersByRole(rctx, fc.Args["role"].(persist.Role), fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RetoolAuth == nil {
				return nil, errors.New("directive retoolAuth is not implemented")
			}
			return ec.directives.RetoolAuth(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UsersConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.UsersConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UsersConnection)
	fc.Result = res
	return ec.marshalOUsersConnection2githubcomSplitFigosplitfigraphqlmodelUsersConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_usersByRole(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UsersConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UsersConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UsersConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_usersByRole_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_socialConnections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_socialConnections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SocialConnections(rctx, fc.Args["socialAccountType"].(persist.SocialProvider), fc.Args["excludeAlreadyFollowing"].(*bool), fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SocialConnectionsConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.SocialConnectionsConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SocialConnectionsConnection)
	fc.Result = res
	return ec.marshalOSocialConnectionsConnection2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_socialConnections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_SocialConnectionsConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SocialConnectionsConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SocialConnectionsConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_socialConnections_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_socialQueries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_socialQueries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().SocialQueries(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.SocialQueriesOrError); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/SplitFi/go-splitfi/graphql/model.SocialQueriesOrError`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SocialQueriesOrError)
	fc.Result = res
	return ec.marshalOSocialQueriesOrError2githubcomSplitFigosplitfigraphqlmodelSocialQueriesOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_socialQueries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SocialQueriesOrError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query__service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query__service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.__resolve__service(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(fedruntime.Service)
	fc.Result = res
	return ec.marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query__service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sdl":
				return ec.fieldContext__Service_sdl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _Service", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshCollectionPayload_collection(ctx context.Context, field graphql.CollectedField, obj *model.RefreshCollectionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshCollectionPayload_collection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Collection, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Collection)
	fc.Result = res
	return ec.marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshCollectionPayload_collection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshCollectionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Collection_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Collection_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Collection_version(ctx, field)
			case "name":
				return ec.fieldContext_Collection_name(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Collection_collectorsNote(ctx, field)
			case "split":
				return ec.fieldContext_Collection_split(ctx, field)
			case "layout":
				return ec.fieldContext_Collection_layout(ctx, field)
			case "hidden":
				return ec.fieldContext_Collection_hidden(ctx, field)
			case "tokens":
				return ec.fieldContext_Collection_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Collection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshContractPayload_contract(ctx context.Context, field graphql.CollectedField, obj *model.RefreshContractPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshContractPayload_contract(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contract, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Contract)
	fc.Result = res
	return ec.marshalOContract2githubcomSplitFigosplitfigraphqlmodelContract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshContractPayload_contract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshContractPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Contract_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Contract_dbid(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Contract_lastUpdated(ctx, field)
			case "contractAddress":
				return ec.fieldContext_Contract_contractAddress(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Contract_creatorAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Contract_chain(ctx, field)
			case "name":
				return ec.fieldContext_Contract_name(ctx, field)
			case "profileImageURL":
				return ec.fieldContext_Contract_profileImageURL(ctx, field)
			case "profileBannerURL":
				return ec.fieldContext_Contract_profileBannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Contract_badgeURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshTokenPayload_token(ctx context.Context, field graphql.CollectedField, obj *model.RefreshTokenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshTokenPayload_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Token)
	fc.Result = res
	return ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshTokenPayload_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshTokenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Token_collectorsNote(ctx, field)
			case "media":
				return ec.fieldContext_Token_media(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "description":
				return ec.fieldContext_Token_description(ctx, field)
			case "tokenId":
				return ec.fieldContext_Token_tokenId(ctx, field)
			case "quantity":
				return ec.fieldContext_Token_quantity(ctx, field)
			case "owner":
				return ec.fieldContext_Token_owner(ctx, field)
			case "ownedByWallets":
				return ec.fieldContext_Token_ownedByWallets(ctx, field)
			case "ownershipHistory":
				return ec.fieldContext_Token_ownershipHistory(ctx, field)
			case "tokenMetadata":
				return ec.fieldContext_Token_tokenMetadata(ctx, field)
			case "contract":
				return ec.fieldContext_Token_contract(ctx, field)
			case "externalUrl":
				return ec.fieldContext_Token_externalUrl(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpamByUser":
				return ec.fieldContext_Token_isSpamByUser(ctx, field)
			case "isSpamByProvider":
				return ec.fieldContext_Token_isSpamByProvider(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Token_creatorAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RemoveUserWalletsPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.RemoveUserWalletsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RemoveUserWalletsPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RemoveUserWalletsPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RemoveUserWalletsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResendVerificationEmailPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.ResendVerificationEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResendVerificationEmailPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResendVerificationEmailPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResendVerificationEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchCommunitiesPayload_results(ctx context.Context, field graphql.CollectedField, obj *model.SearchCommunitiesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchCommunitiesPayload_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CommunitySearchResult)
	fc.Result = res
	return ec.marshalOCommunitySearchResult2githubcomSplitFigosplitfigraphqlmodelCommunitySearchResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchCommunitiesPayload_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchCommunitiesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "community":
				return ec.fieldContext_CommunitySearchResult_community(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommunitySearchResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchSplitsPayload_results(ctx context.Context, field graphql.CollectedField, obj *model.SearchSplitsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchSplitsPayload_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SplitSearchResult)
	fc.Result = res
	return ec.marshalOSplitSearchResult2githubcomSplitFigosplitfigraphqlmodelSplitSearchResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchSplitsPayload_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchSplitsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "split":
				return ec.fieldContext_SplitSearchResult_split(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitSearchResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchUsersPayload_results(ctx context.Context, field graphql.CollectedField, obj *model.SearchUsersPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchUsersPayload_results(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Results, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.UserSearchResult)
	fc.Result = res
	return ec.marshalOUserSearchResult2githubcomSplitFigosplitfigraphqlmodelUserSearchResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchUsersPayload_results(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchUsersPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserSearchResult_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSearchResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetSpamPreferencePayload_tokens(ctx context.Context, field graphql.CollectedField, obj *model.SetSpamPreferencePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetSpamPreferencePayload_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SetSpamPreferencePayload().Tokens(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Token)
	fc.Result = res
	return ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetSpamPreferencePayload_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetSpamPreferencePayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Token_collectorsNote(ctx, field)
			case "media":
				return ec.fieldContext_Token_media(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "description":
				return ec.fieldContext_Token_description(ctx, field)
			case "tokenId":
				return ec.fieldContext_Token_tokenId(ctx, field)
			case "quantity":
				return ec.fieldContext_Token_quantity(ctx, field)
			case "owner":
				return ec.fieldContext_Token_owner(ctx, field)
			case "ownedByWallets":
				return ec.fieldContext_Token_ownedByWallets(ctx, field)
			case "ownershipHistory":
				return ec.fieldContext_Token_ownershipHistory(ctx, field)
			case "tokenMetadata":
				return ec.fieldContext_Token_tokenMetadata(ctx, field)
			case "contract":
				return ec.fieldContext_Token_contract(ctx, field)
			case "externalUrl":
				return ec.fieldContext_Token_externalUrl(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpamByUser":
				return ec.fieldContext_Token_isSpamByUser(ctx, field)
			case "isSpamByProvider":
				return ec.fieldContext_Token_isSpamByProvider(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Token_creatorAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialAccounts_twitter(ctx context.Context, field graphql.CollectedField, obj *model.SocialAccounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialAccounts_twitter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Twitter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TwitterSocialAccount)
	fc.Result = res
	return ec.marshalOTwitterSocialAccount2githubcomSplitFigosplitfigraphqlmodelTwitterSocialAccount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialAccounts_twitter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialAccounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_TwitterSocialAccount_type(ctx, field)
			case "social_id":
				return ec.fieldContext_TwitterSocialAccount_social_id(ctx, field)
			case "name":
				return ec.fieldContext_TwitterSocialAccount_name(ctx, field)
			case "username":
				return ec.fieldContext_TwitterSocialAccount_username(ctx, field)
			case "profileImageURL":
				return ec.fieldContext_TwitterSocialAccount_profileImageURL(ctx, field)
			case "display":
				return ec.fieldContext_TwitterSocialAccount_display(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TwitterSocialAccount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnection_id(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnection_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnection_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnection_splitFiUser(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnection_splitFiUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SocialConnection().SplitFiUser(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnection_splitFiUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnection_currentlyFollowing(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnection_currentlyFollowing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentlyFollowing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnection_currentlyFollowing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnection_socialId(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnection_socialId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SocialID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnection_socialId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnection_socialType(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnection_socialType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SocialType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.SocialProvider)
	fc.Result = res
	return ec.marshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnection_socialType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SocialAccountType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnection_displayName(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnection_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnection_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnection_socialUsername(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnection_socialUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SocialUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnection_socialUsername(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnection_profileImage(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnection_profileImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnection_profileImage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnectionsConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnectionsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnectionsConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SocialConnectionsEdge)
	fc.Result = res
	return ec.marshalOSocialConnectionsEdge2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnectionsConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnectionsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SocialConnectionsEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_SocialConnectionsEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SocialConnectionsEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnectionsConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnectionsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnectionsConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnectionsConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnectionsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnectionsEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnectionsEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnectionsEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.SocialConnectionsOrError)
	fc.Result = res
	return ec.marshalOSocialConnectionsOrError2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsOrError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnectionsEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnectionsEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SocialConnectionsOrError does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialConnectionsEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.SocialConnectionsEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialConnectionsEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialConnectionsEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialConnectionsEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SocialQueries_socialConnections(ctx context.Context, field graphql.CollectedField, obj *model.SocialQueries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SocialQueries_socialConnections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.SocialQueries().SocialConnections(rctx, obj, fc.Args["socialAccountType"].(persist.SocialProvider), fc.Args["excludeAlreadyFollowing"].(*bool), fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SocialConnectionsConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.SocialConnectionsConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SocialConnectionsConnection)
	fc.Result = res
	return ec.marshalOSocialConnectionsConnection2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SocialQueries_socialConnections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SocialQueries",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_SocialConnectionsConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SocialConnectionsConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SocialConnectionsConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SocialQueries_socialConnections_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouBackNotification_id(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouBackNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouBackNotification_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouBackNotification_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouBackNotification",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouBackNotification_dbid(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouBackNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouBackNotification_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouBackNotification_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouBackNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouBackNotification_seen(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouBackNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouBackNotification_seen(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouBackNotification_seen(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouBackNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouBackNotification_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouBackNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouBackNotification_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouBackNotification_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouBackNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouBackNotification_updatedTime(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouBackNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouBackNotification_updatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouBackNotification_updatedTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouBackNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouBackNotification_count(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouBackNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouBackNotification_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouBackNotification_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouBackNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouBackNotification_followers(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouBackNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouBackNotification_followers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SomeoneFollowedYouBackNotification().Followers(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GroupNotificationUsersConnection)
	fc.Result = res
	return ec.marshalOGroupNotificationUsersConnection2githubcomSplitFigosplitfigraphqlmodelGroupNotificationUsersConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouBackNotification_followers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouBackNotification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GroupNotificationUsersConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GroupNotificationUsersConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupNotificationUsersConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SomeoneFollowedYouBackNotification_followers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouNotification_id(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouNotification_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouNotification_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouNotification",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouNotification_dbid(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouNotification_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouNotification_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouNotification_seen(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouNotification_seen(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouNotification_seen(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouNotification_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouNotification_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouNotification_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouNotification_updatedTime(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouNotification_updatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouNotification_updatedTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouNotification_count(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouNotification_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouNotification_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneFollowedYouNotification_followers(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneFollowedYouNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneFollowedYouNotification_followers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SomeoneFollowedYouNotification().Followers(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GroupNotificationUsersConnection)
	fc.Result = res
	return ec.marshalOGroupNotificationUsersConnection2githubcomSplitFigosplitfigraphqlmodelGroupNotificationUsersConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneFollowedYouNotification_followers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneFollowedYouNotification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GroupNotificationUsersConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GroupNotificationUsersConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupNotificationUsersConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SomeoneFollowedYouNotification_followers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_id(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_dbid(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_seen(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_seen(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_seen(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_updatedTime(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_updatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_updatedTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_count(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_userViewers(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_userViewers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SomeoneViewedYourSplitNotification().UserViewers(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GroupNotificationUsersConnection)
	fc.Result = res
	return ec.marshalOGroupNotificationUsersConnection2githubcomSplitFigosplitfigraphqlmodelGroupNotificationUsersConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_userViewers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_GroupNotificationUsersConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_GroupNotificationUsersConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupNotificationUsersConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SomeoneViewedYourSplitNotification_userViewers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_nonUserViewerCount(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_nonUserViewerCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NonUserViewerCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_nonUserViewerCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SomeoneViewedYourSplitNotification_split(ctx context.Context, field graphql.CollectedField, obj *model.SomeoneViewedYourSplitNotification) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SomeoneViewedYourSplitNotification_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SomeoneViewedYourSplitNotification().Split(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SomeoneViewedYourSplitNotification_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SomeoneViewedYourSplitNotification",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_id(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_name(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_description(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_position(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_position(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_hidden(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_hidden(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_tokenPreviews(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_tokenPreviews(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Split().TokenPreviews(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_tokenPreviews(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_owner(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Split().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Split_collections(ctx context.Context, field graphql.CollectedField, obj *model.Split) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Split_collections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Split().Collections(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Collection)
	fc.Result = res
	return ec.marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Split_collections(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Split",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Collection_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Collection_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Collection_version(ctx, field)
			case "name":
				return ec.fieldContext_Collection_name(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Collection_collectorsNote(ctx, field)
			case "split":
				return ec.fieldContext_Collection_split(ctx, field)
			case "layout":
				return ec.fieldContext_Collection_layout(ctx, field)
			case "hidden":
				return ec.fieldContext_Collection_hidden(ctx, field)
			case "tokens":
				return ec.fieldContext_Collection_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Collection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_id(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_dbid(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_username(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_bio(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_bio(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bio, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_bio(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_traits(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_traits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Traits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_traits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_universal(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_universal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Universal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_universal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_roles(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Roles(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*persist.Role)
	fc.Result = res
	return ec.marshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_roles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Role does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_socialAccounts(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().SocialAccounts(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SocialAccounts)
	fc.Result = res
	return ec.marshalOSocialAccounts2githubcomSplitFigosplitfigraphqlmodelSocialAccounts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_socialAccounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "twitter":
				return ec.fieldContext_SocialAccounts_twitter(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SocialAccounts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_tokens(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Tokens(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Token)
	fc.Result = res
	return ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Token_collectorsNote(ctx, field)
			case "media":
				return ec.fieldContext_Token_media(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "description":
				return ec.fieldContext_Token_description(ctx, field)
			case "tokenId":
				return ec.fieldContext_Token_tokenId(ctx, field)
			case "quantity":
				return ec.fieldContext_Token_quantity(ctx, field)
			case "owner":
				return ec.fieldContext_Token_owner(ctx, field)
			case "ownedByWallets":
				return ec.fieldContext_Token_ownedByWallets(ctx, field)
			case "ownershipHistory":
				return ec.fieldContext_Token_ownershipHistory(ctx, field)
			case "tokenMetadata":
				return ec.fieldContext_Token_tokenMetadata(ctx, field)
			case "contract":
				return ec.fieldContext_Token_contract(ctx, field)
			case "externalUrl":
				return ec.fieldContext_Token_externalUrl(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpamByUser":
				return ec.fieldContext_Token_isSpamByUser(ctx, field)
			case "isSpamByProvider":
				return ec.fieldContext_Token_isSpamByProvider(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Token_creatorAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_tokensByChain(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().TokensByChain(rctx, obj, fc.Args["chain"].(persist.Chain))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ChainTokens)
	fc.Result = res
	return ec.marshalOChainTokens2githubcomSplitFigosplitfigraphqlmodelChainTokens(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_tokensByChain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "chain":
				return ec.fieldContext_ChainTokens_chain(ctx, field)
			case "tokens":
				return ec.fieldContext_ChainTokens_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainTokens", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SplitFiUser_tokensByChain_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_wallets(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_wallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Wallets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Wallet)
	fc.Result = res
	return ec.marshalOWallet2githubcomSplitFigosplitfigraphqlmodelWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_wallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Wallet_dbid(ctx, field)
			case "chainAddress":
				return ec.fieldContext_Wallet_chainAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Wallet_chain(ctx, field)
			case "walletType":
				return ec.fieldContext_Wallet_walletType(ctx, field)
			case "tokens":
				return ec.fieldContext_Wallet_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_primaryWallet(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().PrimaryWallet(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Wallet)
	fc.Result = res
	return ec.marshalOWallet2githubcomSplitFigosplitfigraphqlmodelWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_primaryWallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Wallet_dbid(ctx, field)
			case "chainAddress":
				return ec.fieldContext_Wallet_chainAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Wallet_chain(ctx, field)
			case "walletType":
				return ec.fieldContext_Wallet_walletType(ctx, field)
			case "tokens":
				return ec.fieldContext_Wallet_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_featuredSplit(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().FeaturedSplit(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_featuredSplit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_splits(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_splits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Splits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_splits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_badges(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_badges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Badges(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Badge)
	fc.Result = res
	return ec.marshalOBadge2githubcomSplitFigosplitfigraphqlmodelBadge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_badges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Badge_name(ctx, field)
			case "imageURL":
				return ec.fieldContext_Badge_imageURL(ctx, field)
			case "contract":
				return ec.fieldContext_Badge_contract(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Badge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_isAuthenticatedUser(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAuthenticatedUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_isAuthenticatedUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_followers(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_followers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Followers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_followers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_following(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_following(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SplitFiUser().Following(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_following(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_sharedFollowers(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.SplitFiUser().SharedFollowers(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UsersConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.UsersConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UsersConnection)
	fc.Result = res
	return ec.marshalOUsersConnection2githubcomSplitFigosplitfigraphqlmodelUsersConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_sharedFollowers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UsersConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UsersConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UsersConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SplitFiUser_sharedFollowers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _SplitFiUser_sharedCommunities(ctx context.Context, field graphql.CollectedField, obj *model.SplitFiUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.SplitFiUser().SharedCommunities(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.AuthRequired == nil {
				return nil, errors.New("directive authRequired is not implemented")
			}
			return ec.directives.AuthRequired(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CommunitiesConnection); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.CommunitiesConnection`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CommunitiesConnection)
	fc.Result = res
	return ec.marshalOCommunitiesConnection2githubcomSplitFigosplitfigraphqlmodelCommunitiesConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitFiUser_sharedCommunities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitFiUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_CommunitiesConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_CommunitiesConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommunitiesConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_SplitFiUser_sharedCommunities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _SplitSearchResult_split(ctx context.Context, field graphql.CollectedField, obj *model.SplitSearchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplitSearchResult_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplitSearchResult_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplitSearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_newNotification(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_newNotification(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().NewNotification(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan model.Notification):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalONotification2githubcomSplitFigosplitfigraphqlmodelNotification(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_newNotification(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_notificationUpdated(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_notificationUpdated(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().NotificationUpdated(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan model.Notification):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalONotification2githubcomSplitFigosplitfigraphqlmodelNotification(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_notificationUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncTokensForUsernamePayload_message(ctx context.Context, field graphql.CollectedField, obj *model.SyncTokensForUsernamePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncTokensForUsernamePayload_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncTokensForUsernamePayload_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncTokensForUsernamePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncTokensPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.SyncTokensPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncTokensPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncTokensPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncTokensPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncingMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.SyncingMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncingMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncingMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncingMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncingMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.SyncingMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncingMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncingMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncingMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncingMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.SyncingMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncingMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncingMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncingMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncingMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.SyncingMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncingMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncingMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncingMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncingMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.SyncingMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncingMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncingMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncingMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TextMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.TextMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TextMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TextMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TextMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_id(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_lastUpdated(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_lastUpdated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_lastUpdated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_collectorsNote(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_collectorsNote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CollectorsNote, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_collectorsNote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_media(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_media(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Media, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.MediaSubtype)
	fc.Result = res
	return ec.marshalOMediaSubtype2githubcomSplitFigosplitfigraphqlmodelMediaSubtype(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_media(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MediaSubtype does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_tokenType(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_tokenType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TokenType)
	fc.Result = res
	return ec.marshalOTokenType2githubcomSplitFigosplitfigraphqlmodelTokenType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_tokenType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TokenType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_chain(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_name(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_description(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_tokenId(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_tokenId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_tokenId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_quantity(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_quantity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_quantity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_owner(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Token().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_ownedByWallets(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_ownedByWallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Token().OwnedByWallets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Wallet)
	fc.Result = res
	return ec.marshalOWallet2githubcomSplitFigosplitfigraphqlmodelWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_ownedByWallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Wallet_dbid(ctx, field)
			case "chainAddress":
				return ec.fieldContext_Wallet_chainAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Wallet_chain(ctx, field)
			case "walletType":
				return ec.fieldContext_Wallet_walletType(ctx, field)
			case "tokens":
				return ec.fieldContext_Wallet_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_ownershipHistory(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_ownershipHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnershipHistory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.OwnerAtBlock)
	fc.Result = res
	return ec.marshalOOwnerAtBlock2githubcomSplitFigosplitfigraphqlmodelOwnerAtBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_ownershipHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_OwnerAtBlock_owner(ctx, field)
			case "blockNumber":
				return ec.fieldContext_OwnerAtBlock_blockNumber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OwnerAtBlock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_tokenMetadata(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_tokenMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenMetadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_tokenMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_contract(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_contract(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Token().Contract(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Contract)
	fc.Result = res
	return ec.marshalOContract2githubcomSplitFigosplitfigraphqlmodelContract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_contract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Contract_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Contract_dbid(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Contract_lastUpdated(ctx, field)
			case "contractAddress":
				return ec.fieldContext_Contract_contractAddress(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Contract_creatorAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Contract_chain(ctx, field)
			case "name":
				return ec.fieldContext_Contract_name(ctx, field)
			case "profileImageURL":
				return ec.fieldContext_Contract_profileImageURL(ctx, field)
			case "profileBannerURL":
				return ec.fieldContext_Contract_profileBannerURL(ctx, field)
			case "badgeURL":
				return ec.fieldContext_Contract_badgeURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_externalUrl(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_externalUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_externalUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_blockNumber(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_blockNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_blockNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_isSpamByUser(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_isSpamByUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSpamByUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_isSpamByUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_isSpamByProvider(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_isSpamByProvider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSpamByProvider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_isSpamByProvider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Token_creatorAddress(ctx context.Context, field graphql.CollectedField, obj *model.Token) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Token_creatorAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatorAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Token_creatorAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Token",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.TokenEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Token)
	fc.Result = res
	return ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Token_collectorsNote(ctx, field)
			case "media":
				return ec.fieldContext_Token_media(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "description":
				return ec.fieldContext_Token_description(ctx, field)
			case "tokenId":
				return ec.fieldContext_Token_tokenId(ctx, field)
			case "quantity":
				return ec.fieldContext_Token_quantity(ctx, field)
			case "owner":
				return ec.fieldContext_Token_owner(ctx, field)
			case "ownedByWallets":
				return ec.fieldContext_Token_ownedByWallets(ctx, field)
			case "ownershipHistory":
				return ec.fieldContext_Token_ownershipHistory(ctx, field)
			case "tokenMetadata":
				return ec.fieldContext_Token_tokenMetadata(ctx, field)
			case "contract":
				return ec.fieldContext_Token_contract(ctx, field)
			case "externalUrl":
				return ec.fieldContext_Token_externalUrl(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpamByUser":
				return ec.fieldContext_Token_isSpamByUser(ctx, field)
			case "isSpamByProvider":
				return ec.fieldContext_Token_isSpamByProvider(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Token_creatorAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.TokenEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenHolder_displayName(ctx context.Context, field graphql.CollectedField, obj *model.TokenHolder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenHolder_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenHolder_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenHolder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenHolder_wallets(ctx context.Context, field graphql.CollectedField, obj *model.TokenHolder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenHolder_wallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TokenHolder().Wallets(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Wallet)
	fc.Result = res
	return ec.marshalOWallet2githubcomSplitFigosplitfigraphqlmodelWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenHolder_wallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenHolder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Wallet_dbid(ctx, field)
			case "chainAddress":
				return ec.fieldContext_Wallet_chainAddress(ctx, field)
			case "chain":
				return ec.fieldContext_Wallet_chain(ctx, field)
			case "walletType":
				return ec.fieldContext_Wallet_walletType(ctx, field)
			case "tokens":
				return ec.fieldContext_Wallet_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenHolder_user(ctx context.Context, field graphql.CollectedField, obj *model.TokenHolder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenHolder_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TokenHolder().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenHolder_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenHolder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenHolder_previewTokens(ctx context.Context, field graphql.CollectedField, obj *model.TokenHolder) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenHolder_previewTokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewTokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenHolder_previewTokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenHolder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenHolderEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.TokenHolderEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenHolderEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TokenHolder)
	fc.Result = res
	return ec.marshalOTokenHolder2githubcomSplitFigosplitfigraphqlmodelTokenHolder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenHolderEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenHolderEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_TokenHolder_displayName(ctx, field)
			case "wallets":
				return ec.fieldContext_TokenHolder_wallets(ctx, field)
			case "user":
				return ec.fieldContext_TokenHolder_user(ctx, field)
			case "previewTokens":
				return ec.fieldContext_TokenHolder_previewTokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TokenHolder", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenHolderEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.TokenHolderEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenHolderEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenHolderEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenHolderEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenHoldersConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.TokenHoldersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenHoldersConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TokenHolderEdge)
	fc.Result = res
	return ec.marshalOTokenHolderEdge2githubcomSplitFigosplitfigraphqlmodelTokenHolderEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenHoldersConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenHoldersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TokenHolderEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TokenHolderEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TokenHolderEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokenHoldersConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.TokenHoldersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokenHoldersConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokenHoldersConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokenHoldersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokensConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.TokensConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokensConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TokenEdge)
	fc.Result = res
	return ec.marshalOTokenEdge2githubcomSplitFigosplitfigraphqlmodelTokenEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokensConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokensConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TokenEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TokenEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TokenEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TokensConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.TokensConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TokensConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TokensConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TokensConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TwitterSocialAccount_type(ctx context.Context, field graphql.CollectedField, obj *model.TwitterSocialAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TwitterSocialAccount_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.SocialProvider)
	fc.Result = res
	return ec.marshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TwitterSocialAccount_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TwitterSocialAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SocialAccountType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TwitterSocialAccount_social_id(ctx context.Context, field graphql.CollectedField, obj *model.TwitterSocialAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TwitterSocialAccount_social_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SocialID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TwitterSocialAccount_social_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TwitterSocialAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TwitterSocialAccount_name(ctx context.Context, field graphql.CollectedField, obj *model.TwitterSocialAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TwitterSocialAccount_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TwitterSocialAccount_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TwitterSocialAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TwitterSocialAccount_username(ctx context.Context, field graphql.CollectedField, obj *model.TwitterSocialAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TwitterSocialAccount_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TwitterSocialAccount_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TwitterSocialAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TwitterSocialAccount_profileImageURL(ctx context.Context, field graphql.CollectedField, obj *model.TwitterSocialAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TwitterSocialAccount_profileImageURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TwitterSocialAccount_profileImageURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TwitterSocialAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TwitterSocialAccount_display(ctx context.Context, field graphql.CollectedField, obj *model.TwitterSocialAccount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TwitterSocialAccount_display(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Display, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TwitterSocialAccount_display(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TwitterSocialAccount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnfollowUserPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UnfollowUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnfollowUserPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnfollowUserPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnfollowUserPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnfollowUserPayload_user(ctx context.Context, field graphql.CollectedField, obj *model.UnfollowUserPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnfollowUserPayload_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UnfollowUserPayload().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnfollowUserPayload_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnfollowUserPayload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_contentRenderURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_contentRenderURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.UnknownMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnsubscribeFromEmailTypePayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UnsubscribeFromEmailTypePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnsubscribeFromEmailTypePayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnsubscribeFromEmailTypePayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnsubscribeFromEmailTypePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateCollectionHiddenPayload_collection(ctx context.Context, field graphql.CollectedField, obj *model.UpdateCollectionHiddenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateCollectionHiddenPayload_collection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Collection, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Collection)
	fc.Result = res
	return ec.marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateCollectionHiddenPayload_collection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateCollectionHiddenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Collection_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Collection_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Collection_version(ctx, field)
			case "name":
				return ec.fieldContext_Collection_name(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Collection_collectorsNote(ctx, field)
			case "split":
				return ec.fieldContext_Collection_split(ctx, field)
			case "layout":
				return ec.fieldContext_Collection_layout(ctx, field)
			case "hidden":
				return ec.fieldContext_Collection_hidden(ctx, field)
			case "tokens":
				return ec.fieldContext_Collection_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Collection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateCollectionInfoPayload_collection(ctx context.Context, field graphql.CollectedField, obj *model.UpdateCollectionInfoPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateCollectionInfoPayload_collection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Collection, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Collection)
	fc.Result = res
	return ec.marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateCollectionInfoPayload_collection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateCollectionInfoPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Collection_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Collection_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Collection_version(ctx, field)
			case "name":
				return ec.fieldContext_Collection_name(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Collection_collectorsNote(ctx, field)
			case "split":
				return ec.fieldContext_Collection_split(ctx, field)
			case "layout":
				return ec.fieldContext_Collection_layout(ctx, field)
			case "hidden":
				return ec.fieldContext_Collection_hidden(ctx, field)
			case "tokens":
				return ec.fieldContext_Collection_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Collection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateCollectionTokensPayload_collection(ctx context.Context, field graphql.CollectedField, obj *model.UpdateCollectionTokensPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateCollectionTokensPayload_collection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Collection, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Collection)
	fc.Result = res
	return ec.marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateCollectionTokensPayload_collection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateCollectionTokensPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Collection_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Collection_dbid(ctx, field)
			case "version":
				return ec.fieldContext_Collection_version(ctx, field)
			case "name":
				return ec.fieldContext_Collection_name(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Collection_collectorsNote(ctx, field)
			case "split":
				return ec.fieldContext_Collection_split(ctx, field)
			case "layout":
				return ec.fieldContext_Collection_layout(ctx, field)
			case "hidden":
				return ec.fieldContext_Collection_hidden(ctx, field)
			case "tokens":
				return ec.fieldContext_Collection_tokens(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Collection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEmailNotificationSettingsPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateEmailNotificationSettingsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEmailNotificationSettingsPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEmailNotificationSettingsPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEmailNotificationSettingsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateEmailPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateEmailPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateEmailPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateFeaturedSplitPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateFeaturedSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateFeaturedSplitPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateFeaturedSplitPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateFeaturedSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdatePrimaryWalletPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdatePrimaryWalletPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdatePrimaryWalletPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdatePrimaryWalletPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdatePrimaryWalletPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSocialAccountDisplayedPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSocialAccountDisplayedPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSocialAccountDisplayedPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSocialAccountDisplayedPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSocialAccountDisplayedPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitCollectionsPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitCollectionsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitCollectionsPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitCollectionsPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitCollectionsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitHiddenPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitHiddenPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitHiddenPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitHiddenPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitHiddenPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitInfoPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitInfoPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitInfoPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitInfoPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitInfoPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitOrderPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitOrderPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitOrderPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitOrderPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitOrderPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateSplitPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.UpdateSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateSplitPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateSplitPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTokenInfoPayload_token(ctx context.Context, field graphql.CollectedField, obj *model.UpdateTokenInfoPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTokenInfoPayload_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Token)
	fc.Result = res
	return ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTokenInfoPayload_token(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTokenInfoPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Token_collectorsNote(ctx, field)
			case "media":
				return ec.fieldContext_Token_media(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "description":
				return ec.fieldContext_Token_description(ctx, field)
			case "tokenId":
				return ec.fieldContext_Token_tokenId(ctx, field)
			case "quantity":
				return ec.fieldContext_Token_quantity(ctx, field)
			case "owner":
				return ec.fieldContext_Token_owner(ctx, field)
			case "ownedByWallets":
				return ec.fieldContext_Token_ownedByWallets(ctx, field)
			case "ownershipHistory":
				return ec.fieldContext_Token_ownershipHistory(ctx, field)
			case "tokenMetadata":
				return ec.fieldContext_Token_tokenMetadata(ctx, field)
			case "contract":
				return ec.fieldContext_Token_contract(ctx, field)
			case "externalUrl":
				return ec.fieldContext_Token_externalUrl(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpamByUser":
				return ec.fieldContext_Token_isSpamByUser(ctx, field)
			case "isSpamByProvider":
				return ec.fieldContext_Token_isSpamByProvider(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Token_creatorAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateUserExperiencePayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateUserExperiencePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateUserExperiencePayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateUserExperiencePayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateUserExperiencePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateUserInfoPayload_viewer(ctx context.Context, field graphql.CollectedField, obj *model.UpdateUserInfoPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateUserInfoPayload_viewer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Viewer)
	fc.Result = res
	return ec.marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateUserInfoPayload_viewer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateUserInfoPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Viewer_id(ctx, field)
			case "user":
				return ec.fieldContext_Viewer_user(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_Viewer_socialAccounts(ctx, field)
			case "viewerSplits":
				return ec.fieldContext_Viewer_viewerSplits(ctx, field)
			case "email":
				return ec.fieldContext_Viewer_email(ctx, field)
			case "notifications":
				return ec.fieldContext_Viewer_notifications(ctx, field)
			case "notificationSettings":
				return ec.fieldContext_Viewer_notificationSettings(ctx, field)
			case "userExperiences":
				return ec.fieldContext_Viewer_userExperiences(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Viewer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UploadPersistedQueriesPayload_message(ctx context.Context, field graphql.CollectedField, obj *model.UploadPersistedQueriesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UploadPersistedQueriesPayload_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UploadPersistedQueriesPayload_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UploadPersistedQueriesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.UserEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEmail_email(ctx context.Context, field graphql.CollectedField, obj *model.UserEmail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEmail_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Email)
	fc.Result = res
	return ec.marshalOEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEmail_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEmail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Email does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEmail_verificationStatus(ctx context.Context, field graphql.CollectedField, obj *model.UserEmail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEmail_verificationStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VerificationStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.EmailVerificationStatus)
	fc.Result = res
	return ec.marshalOEmailVerificationStatus2githubcomSplitFigosplitfiservicepersistEmailVerificationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEmail_verificationStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEmail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EmailVerificationStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserEmail_emailNotificationSettings(ctx context.Context, field graphql.CollectedField, obj *model.UserEmail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserEmail_emailNotificationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailNotificationSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.EmailNotificationSettings)
	fc.Result = res
	return ec.marshalOEmailNotificationSettings2githubcomSplitFigosplitfigraphqlmodelEmailNotificationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEmail_emailNotificationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEmail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unsubscribedFromAll":
				return ec.fieldContext_EmailNotificationSettings_unsubscribedFromAll(ctx, field)
			case "unsubscribedFromNotifications":
				return ec.fieldContext_EmailNotificationSettings_unsubscribedFromNotifications(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EmailNotificationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserExperience_type(ctx context.Context, field graphql.CollectedField, obj *model.UserExperience) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserExperience_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.UserExperienceType)
	fc.Result = res
	return ec.marshalNUserExperienceType2githubcomSplitFigosplitfigraphqlmodelUserExperienceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserExperience_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserExperience",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserExperienceType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserExperience_experienced(ctx context.Context, field graphql.CollectedField, obj *model.UserExperience) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserExperience_experienced(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experienced, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserExperience_experienced(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserExperience",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSearchResult_user(ctx context.Context, field graphql.CollectedField, obj *model.UserSearchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSearchResult_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSearchResult_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSearchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UsersConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.UsersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UsersConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.UserEdge)
	fc.Result = res
	return ec.marshalOUserEdge2githubcomSplitFigosplitfigraphqlmodelUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UsersConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UsersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_UserEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_UserEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UsersConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.UsersConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UsersConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UsersConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UsersConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_PageInfo_total(ctx, field)
			case "size":
				return ec.fieldContext_PageInfo_size(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VerifyEmailPayload_email(ctx context.Context, field graphql.CollectedField, obj *model.VerifyEmailPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VerifyEmailPayload_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.Email)
	fc.Result = res
	return ec.marshalNEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VerifyEmailPayload_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VerifyEmailPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Email does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_previewURLs(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_previewURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviewURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PreviewURLSet)
	fc.Result = res
	return ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_previewURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_PreviewURLSet_raw(ctx, field)
			case "thumbnail":
				return ec.fieldContext_PreviewURLSet_thumbnail(ctx, field)
			case "small":
				return ec.fieldContext_PreviewURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_PreviewURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_PreviewURLSet_large(ctx, field)
			case "srcSet":
				return ec.fieldContext_PreviewURLSet_srcSet(ctx, field)
			case "liveRender":
				return ec.fieldContext_PreviewURLSet_liveRender(ctx, field)
			case "blurhash":
				return ec.fieldContext_PreviewURLSet_blurhash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreviewURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_mediaURL(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_mediaURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_mediaURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_mediaType(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_mediaType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MediaType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_mediaType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_contentRenderURLs(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_contentRenderURLs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRenderURLs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.VideoURLSet)
	fc.Result = res
	return ec.marshalOVideoURLSet2githubcomSplitFigosplitfigraphqlmodelVideoURLSet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_contentRenderURLs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "raw":
				return ec.fieldContext_VideoURLSet_raw(ctx, field)
			case "small":
				return ec.fieldContext_VideoURLSet_small(ctx, field)
			case "medium":
				return ec.fieldContext_VideoURLSet_medium(ctx, field)
			case "large":
				return ec.fieldContext_VideoURLSet_large(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VideoURLSet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoMedia_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.VideoMedia) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoMedia_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MediaDimensions)
	fc.Result = res
	return ec.marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoMedia_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoMedia",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_MediaDimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_MediaDimensions_height(ctx, field)
			case "aspectRatio":
				return ec.fieldContext_MediaDimensions_aspectRatio(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MediaDimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoURLSet_raw(ctx context.Context, field graphql.CollectedField, obj *model.VideoURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoURLSet_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoURLSet_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoURLSet_small(ctx context.Context, field graphql.CollectedField, obj *model.VideoURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoURLSet_small(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Small, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoURLSet_small(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoURLSet_medium(ctx context.Context, field graphql.CollectedField, obj *model.VideoURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoURLSet_medium(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Medium, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoURLSet_medium(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VideoURLSet_large(ctx context.Context, field graphql.CollectedField, obj *model.VideoURLSet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VideoURLSet_large(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Large, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VideoURLSet_large(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VideoURLSet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ViewSplitPayload_split(ctx context.Context, field graphql.CollectedField, obj *model.ViewSplitPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ViewSplitPayload_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ViewSplitPayload_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ViewSplitPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_id(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_user(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SplitFiUser)
	fc.Result = res
	return ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SplitFiUser_id(ctx, field)
			case "dbid":
				return ec.fieldContext_SplitFiUser_dbid(ctx, field)
			case "username":
				return ec.fieldContext_SplitFiUser_username(ctx, field)
			case "bio":
				return ec.fieldContext_SplitFiUser_bio(ctx, field)
			case "traits":
				return ec.fieldContext_SplitFiUser_traits(ctx, field)
			case "universal":
				return ec.fieldContext_SplitFiUser_universal(ctx, field)
			case "roles":
				return ec.fieldContext_SplitFiUser_roles(ctx, field)
			case "socialAccounts":
				return ec.fieldContext_SplitFiUser_socialAccounts(ctx, field)
			case "tokens":
				return ec.fieldContext_SplitFiUser_tokens(ctx, field)
			case "tokensByChain":
				return ec.fieldContext_SplitFiUser_tokensByChain(ctx, field)
			case "wallets":
				return ec.fieldContext_SplitFiUser_wallets(ctx, field)
			case "primaryWallet":
				return ec.fieldContext_SplitFiUser_primaryWallet(ctx, field)
			case "featuredSplit":
				return ec.fieldContext_SplitFiUser_featuredSplit(ctx, field)
			case "splits":
				return ec.fieldContext_SplitFiUser_splits(ctx, field)
			case "badges":
				return ec.fieldContext_SplitFiUser_badges(ctx, field)
			case "isAuthenticatedUser":
				return ec.fieldContext_SplitFiUser_isAuthenticatedUser(ctx, field)
			case "followers":
				return ec.fieldContext_SplitFiUser_followers(ctx, field)
			case "following":
				return ec.fieldContext_SplitFiUser_following(ctx, field)
			case "sharedFollowers":
				return ec.fieldContext_SplitFiUser_sharedFollowers(ctx, field)
			case "sharedCommunities":
				return ec.fieldContext_SplitFiUser_sharedCommunities(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplitFiUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_socialAccounts(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_socialAccounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().SocialAccounts(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SocialAccounts)
	fc.Result = res
	return ec.marshalOSocialAccounts2githubcomSplitFigosplitfigraphqlmodelSocialAccounts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_socialAccounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "twitter":
				return ec.fieldContext_SocialAccounts_twitter(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SocialAccounts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_viewerSplits(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_viewerSplits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().ViewerSplits(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ViewerSplit)
	fc.Result = res
	return ec.marshalOViewerSplit2githubcomSplitFigosplitfigraphqlmodelViewerSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_viewerSplits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "split":
				return ec.fieldContext_ViewerSplit_split(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ViewerSplit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_email(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().Email(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserEmail)
	fc.Result = res
	return ec.marshalOUserEmail2githubcomSplitFigosplitfigraphqlmodelUserEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "email":
				return ec.fieldContext_UserEmail_email(ctx, field)
			case "verificationStatus":
				return ec.fieldContext_UserEmail_verificationStatus(ctx, field)
			case "emailNotificationSettings":
				return ec.fieldContext_UserEmail_emailNotificationSettings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEmail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_notifications(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().Notifications(rctx, obj, fc.Args["before"].(*string), fc.Args["after"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NotificationsConnection)
	fc.Result = res
	return ec.marshalONotificationsConnection2githubcomSplitFigosplitfigraphqlmodelNotificationsConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_notifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_NotificationsConnection_edges(ctx, field)
			case "unseenCount":
				return ec.fieldContext_NotificationsConnection_unseenCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_NotificationsConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationsConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Viewer_notifications_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_notificationSettings(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_notificationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().NotificationSettings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NotificationSettings)
	fc.Result = res
	return ec.marshalONotificationSettings2githubcomSplitFigosplitfigraphqlmodelNotificationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_notificationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "someoneFollowedYou":
				return ec.fieldContext_NotificationSettings_someoneFollowedYou(ctx, field)
			case "someoneViewedYourSplit":
				return ec.fieldContext_NotificationSettings_someoneViewedYourSplit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotificationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Viewer_userExperiences(ctx context.Context, field graphql.CollectedField, obj *model.Viewer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Viewer_userExperiences(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Viewer().UserExperiences(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.UserExperience)
	fc.Result = res
	return ec.marshalOUserExperience2githubcomSplitFigosplitfigraphqlmodelUserExperience(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Viewer_userExperiences(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Viewer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_UserExperience_type(ctx, field)
			case "experienced":
				return ec.fieldContext_UserExperience_experienced(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserExperience", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ViewerSplit_split(ctx context.Context, field graphql.CollectedField, obj *model.ViewerSplit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ViewerSplit_split(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Split, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Split)
	fc.Result = res
	return ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ViewerSplit_split(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ViewerSplit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Split_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Split_dbid(ctx, field)
			case "name":
				return ec.fieldContext_Split_name(ctx, field)
			case "description":
				return ec.fieldContext_Split_description(ctx, field)
			case "position":
				return ec.fieldContext_Split_position(ctx, field)
			case "hidden":
				return ec.fieldContext_Split_hidden(ctx, field)
			case "tokenPreviews":
				return ec.fieldContext_Split_tokenPreviews(ctx, field)
			case "owner":
				return ec.fieldContext_Split_owner(ctx, field)
			case "collections":
				return ec.fieldContext_Split_collections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Split", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_id(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.GqlID)
	fc.Result = res
	return ec.marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_dbid(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_dbid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(persist.DBID)
	fc.Result = res
	return ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_dbid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DBID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_chainAddress(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_chainAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChainAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.ChainAddress)
	fc.Result = res
	return ec.marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_chainAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_ChainAddress_address(ctx, field)
			case "chain":
				return ec.fieldContext_ChainAddress_chain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChainAddress", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_chain(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.Chain)
	fc.Result = res
	return ec.marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Chain does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_walletType(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_walletType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WalletType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*persist.WalletType)
	fc.Result = res
	return ec.marshalOWalletType2githubcomSplitFigosplitfiservicepersistWalletType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_walletType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WalletType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_tokens(ctx context.Context, field graphql.CollectedField, obj *model.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_tokens(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Wallet().Tokens(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Token)
	fc.Result = res
	return ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_tokens(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Token_id(ctx, field)
			case "dbid":
				return ec.fieldContext_Token_dbid(ctx, field)
			case "creationTime":
				return ec.fieldContext_Token_creationTime(ctx, field)
			case "lastUpdated":
				return ec.fieldContext_Token_lastUpdated(ctx, field)
			case "collectorsNote":
				return ec.fieldContext_Token_collectorsNote(ctx, field)
			case "media":
				return ec.fieldContext_Token_media(ctx, field)
			case "tokenType":
				return ec.fieldContext_Token_tokenType(ctx, field)
			case "chain":
				return ec.fieldContext_Token_chain(ctx, field)
			case "name":
				return ec.fieldContext_Token_name(ctx, field)
			case "description":
				return ec.fieldContext_Token_description(ctx, field)
			case "tokenId":
				return ec.fieldContext_Token_tokenId(ctx, field)
			case "quantity":
				return ec.fieldContext_Token_quantity(ctx, field)
			case "owner":
				return ec.fieldContext_Token_owner(ctx, field)
			case "ownedByWallets":
				return ec.fieldContext_Token_ownedByWallets(ctx, field)
			case "ownershipHistory":
				return ec.fieldContext_Token_ownershipHistory(ctx, field)
			case "tokenMetadata":
				return ec.fieldContext_Token_tokenMetadata(ctx, field)
			case "contract":
				return ec.fieldContext_Token_contract(ctx, field)
			case "externalUrl":
				return ec.fieldContext_Token_externalUrl(ctx, field)
			case "blockNumber":
				return ec.fieldContext_Token_blockNumber(ctx, field)
			case "isSpamByUser":
				return ec.fieldContext_Token_isSpamByUser(ctx, field)
			case "isSpamByProvider":
				return ec.fieldContext_Token_isSpamByProvider(ctx, field)
			case "creatorAddress":
				return ec.fieldContext_Token_creatorAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Token", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) __Service_sdl(ctx context.Context, field graphql.CollectedField, obj *fedruntime.Service) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext__Service_sdl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SDL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext__Service_sdl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_Service",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAdminAddWalletInput(ctx context.Context, obj interface{}) (model.AdminAddWalletInput, error) {
	var it model.AdminAddWalletInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "chainAddress", "walletType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "chainAddress":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddress"))
			data, err := ec.unmarshalNChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainAddress = data
		case "walletType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("walletType"))
			data, err := ec.unmarshalNWalletType2githubcomSplitFigosplitfiservicepersistWalletType(ctx, v)
			if err != nil {
				return it, err
			}
			it.WalletType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthMechanism(ctx context.Context, obj interface{}) (model.AuthMechanism, error) {
	var it model.AuthMechanism
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eoa", "gnosisSafe", "debug", "magicLink"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eoa":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eoa"))
			data, err := ec.unmarshalOEoaAuth2githubcomSplitFigosplitfigraphqlmodelEoaAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eoa = data
		case "gnosisSafe":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gnosisSafe"))
			data, err := ec.unmarshalOGnosisSafeAuth2githubcomSplitFigosplitfigraphqlmodelGnosisSafeAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.GnosisSafe = data
		case "debug":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("debug"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalODebugAuth2githubcomSplitFigosplitfigraphqlmodelDebugAuth(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2string(ctx, []interface{}{"local"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.DebugAuth); ok {
				it.Debug = data
			} else if tmp == nil {
				it.Debug = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/graphql/model.DebugAuth`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "magicLink":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("magicLink"))
			data, err := ec.unmarshalOMagicLinkAuth2githubcomSplitFigosplitfigraphqlmodelMagicLinkAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.MagicLink = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChainAddressInput(ctx context.Context, obj interface{}) (persist.ChainAddress, error) {
	var it persist.ChainAddress
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"address", "chain"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "address":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			data, err := ec.unmarshalNAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ChainAddressInput().Address(ctx, &it, data); err != nil {
				return it, err
			}
		case "chain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
			data, err := ec.unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ChainAddressInput().Chain(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChainPubKeyInput(ctx context.Context, obj interface{}) (persist.ChainPubKey, error) {
	var it persist.ChainPubKey
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pubKey", "chain"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pubKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pubKey"))
			data, err := ec.unmarshalNPubKey2githubcomSplitFigosplitfiservicepersistPubKey(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ChainPubKeyInput().PubKey(ctx, &it, data); err != nil {
				return it, err
			}
		case "chain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
			data, err := ec.unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ChainPubKeyInput().Chain(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCollectionLayoutInput(ctx context.Context, obj interface{}) (model.CollectionLayoutInput, error) {
	var it model.CollectionLayoutInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sections", "sectionLayout"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sections"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sections = data
		case "sectionLayout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectionLayout"))
			data, err := ec.unmarshalNCollectionSectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionSectionLayoutInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.SectionLayout = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCollectionSectionLayoutInput(ctx context.Context, obj interface{}) (model.CollectionSectionLayoutInput, error) {
	var it model.CollectionSectionLayoutInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"columns", "whitespace"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "columns":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("columns"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Columns = data
		case "whitespace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("whitespace"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Whitespace = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCollectionTokenSettingsInput(ctx context.Context, obj interface{}) (model.CollectionTokenSettingsInput, error) {
	var it model.CollectionTokenSettingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tokenId", "renderLive"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tokenId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenID = data
		case "renderLive":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("renderLive"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RenderLive = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCollectionInSplitInput(ctx context.Context, obj interface{}) (model.CreateCollectionInSplitInput, error) {
	var it model.CreateCollectionInSplitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "collectorsNote", "tokens", "layout", "tokenSettings", "hidden", "givenID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "collectorsNote":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectorsNote"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectorsNote = data
		case "tokens":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokens"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tokens = data
		case "layout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layout"))
			data, err := ec.unmarshalNCollectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionLayoutInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layout = data
		case "tokenSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenSettings"))
			data, err := ec.unmarshalNCollectionTokenSettingsInput2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettingsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenSettings = data
		case "hidden":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		case "givenID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("givenID"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.GivenID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCollectionInput(ctx context.Context, obj interface{}) (model.CreateCollectionInput, error) {
	var it model.CreateCollectionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "name", "collectorsNote", "tokens", "layout", "tokenSettings", "caption"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "collectorsNote":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectorsNote"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectorsNote = data
		case "tokens":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokens"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tokens = data
		case "layout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layout"))
			data, err := ec.unmarshalNCollectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionLayoutInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layout = data
		case "tokenSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenSettings"))
			data, err := ec.unmarshalNCollectionTokenSettingsInput2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettingsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenSettings = data
		case "caption":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caption"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caption = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSplitInput(ctx context.Context, obj interface{}) (model.CreateSplitInput, error) {
	var it model.CreateSplitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "position"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "position":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (model.CreateUserInput, error) {
	var it model.CreateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "bio", "email", "splitName", "splitDescription", "splitPosition"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "bio":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "splitName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitName = data
		case "splitDescription":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitDescription"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitDescription = data
		case "splitPosition":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitPosition"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitPosition = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDebugAuth(ctx context.Context, obj interface{}) (model.DebugAuth, error) {
	var it model.DebugAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"asUsername", "userId", "chainAddresses"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "asUsername":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("asUsername"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2string(ctx, []interface{}{"local"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.AsUsername = data
			} else if tmp == nil {
				it.AsUsername = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "userId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2string(ctx, []interface{}{"local"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*persist.DBID); ok {
				it.UserID = data
			} else if tmp == nil {
				it.UserID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/SplitFi/go-splitfi/service/persist.DBID`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "chainAddresses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainAddresses"))
			directive0 := func(ctx context.Context) (interface{}, error) {
				return ec.unmarshalOChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, v)
			}
			directive1 := func(ctx context.Context) (interface{}, error) {
				allowed, err := ec.unmarshalNString2string(ctx, []interface{}{"local"})
				if err != nil {
					return nil, err
				}
				if ec.directives.RestrictEnvironment == nil {
					return nil, errors.New("directive restrictEnvironment is not implemented")
				}
				return ec.directives.RestrictEnvironment(ctx, obj, directive0, allowed)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*persist.ChainAddress); ok {
				it.ChainAddresses = data
			} else if tmp == nil {
				it.ChainAddresses = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*github.com/SplitFi/go-splitfi/service/persist.ChainAddress`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDebugSocialAuth(ctx context.Context, obj interface{}) (model.DebugSocialAuth, error) {
	var it model.DebugSocialAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"provider", "id", "username"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "provider":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeepRefreshInput(ctx context.Context, obj interface{}) (model.DeepRefreshInput, error) {
	var it model.DeepRefreshInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"chain"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "chain":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain"))
			data, err := ec.unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, v)
			if err != nil {
				return it, err
			}
			it.Chain = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEoaAuth(ctx context.Context, obj interface{}) (model.EoaAuth, error) {
	var it model.EoaAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"chainPubKey", "nonce", "signature"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "chainPubKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chainPubKey"))
			data, err := ec.unmarshalNChainPubKeyInput2githubcomSplitFigosplitfiservicepersistChainPubKey(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainPubKey = data
		case "nonce":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nonce = data
		case "signature":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signature"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Signature = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGnosisSafeAuth(ctx context.Context, obj interface{}) (model.GnosisSafeAuth, error) {
	var it model.GnosisSafeAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"address", "nonce"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "address":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
			data, err := ec.unmarshalNAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx, v)
			if err != nil {
				return it, err
			}
			it.Address = data
		case "nonce":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nonce = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMagicLinkAuth(ctx context.Context, obj interface{}) (model.MagicLinkAuth, error) {
	var it model.MagicLinkAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"token"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "token":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMintPremiumCardToWalletInput(ctx context.Context, obj interface{}) (model.MintPremiumCardToWalletInput, error) {
	var it model.MintPremiumCardToWalletInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tokenId", "walletAddresses"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tokenId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenID = data
		case "walletAddresses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("walletAddresses"))
			data, err := ec.unmarshalOAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx, v)
			if err != nil {
				return it, err
			}
			it.WalletAddresses = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMoveCollectionToSplitInput(ctx context.Context, obj interface{}) (model.MoveCollectionToSplitInput, error) {
	var it model.MoveCollectionToSplitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sourceCollectionId", "targetSplitId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sourceCollectionId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourceCollectionId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceCollectionID = data
		case "targetSplitId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetSplitId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetSplitID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationSettingsInput(ctx context.Context, obj interface{}) (model.NotificationSettingsInput, error) {
	var it model.NotificationSettingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"someoneFollowedYou", "someoneViewedYourSplit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "someoneFollowedYou":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("someoneFollowedYou"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SomeoneFollowedYou = data
		case "someoneViewedYourSplit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("someoneViewedYourSplit"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SomeoneViewedYourSplit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPreverifyEmailInput(ctx context.Context, obj interface{}) (model.PreverifyEmailInput, error) {
	var it model.PreverifyEmailInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublishSplitInput(ctx context.Context, obj interface{}) (model.PublishSplitInput, error) {
	var it model.PublishSplitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "editId", "caption"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "editId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("editId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EditID = data
		case "caption":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caption"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caption = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetSpamPreferenceInput(ctx context.Context, obj interface{}) (model.SetSpamPreferenceInput, error) {
	var it model.SetSpamPreferenceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tokens", "isSpam"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tokens":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokens"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tokens = data
		case "isSpam":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isSpam"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsSpam = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSocialAuthMechanism(ctx context.Context, obj interface{}) (model.SocialAuthMechanism, error) {
	var it model.SocialAuthMechanism
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"twitter", "debug"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "twitter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("twitter"))
			data, err := ec.unmarshalOTwitterAuth2githubcomSplitFigosplitfigraphqlmodelTwitterAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.Twitter = data
		case "debug":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("debug"))
			data, err := ec.unmarshalODebugSocialAuth2githubcomSplitFigosplitfigraphqlmodelDebugSocialAuth(ctx, v)
			if err != nil {
				return it, err
			}
			it.Debug = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSplitPositionInput(ctx context.Context, obj interface{}) (model.SplitPositionInput, error) {
	var it model.SplitPositionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "position"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "position":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTwitterAuth(ctx context.Context, obj interface{}) (model.TwitterAuth, error) {
	var it model.TwitterAuth
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"code"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "code":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnsubscribeFromEmailTypeInput(ctx context.Context, obj interface{}) (model.UnsubscribeFromEmailTypeInput, error) {
	var it model.UnsubscribeFromEmailTypeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "token"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNEmailUnsubscriptionType2githubcomSplitFigosplitfigraphqlmodelEmailUnsubscriptionType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "token":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCollectionHiddenInput(ctx context.Context, obj interface{}) (model.UpdateCollectionHiddenInput, error) {
	var it model.UpdateCollectionHiddenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"collectionId", "hidden"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "collectionId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectionId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectionID = data
		case "hidden":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCollectionInfoInput(ctx context.Context, obj interface{}) (model.UpdateCollectionInfoInput, error) {
	var it model.UpdateCollectionInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"collectionId", "name", "collectorsNote"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "collectionId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectionId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectionID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "collectorsNote":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectorsNote"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectorsNote = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCollectionInput(ctx context.Context, obj interface{}) (model.UpdateCollectionInput, error) {
	var it model.UpdateCollectionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dbid", "name", "collectorsNote", "tokens", "layout", "tokenSettings", "hidden"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dbid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dbid"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dbid = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "collectorsNote":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectorsNote"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectorsNote = data
		case "tokens":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokens"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tokens = data
		case "layout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layout"))
			data, err := ec.unmarshalNCollectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionLayoutInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layout = data
		case "tokenSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenSettings"))
			data, err := ec.unmarshalNCollectionTokenSettingsInput2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettingsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenSettings = data
		case "hidden":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCollectionTokensInput(ctx context.Context, obj interface{}) (model.UpdateCollectionTokensInput, error) {
	var it model.UpdateCollectionTokensInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"collectionId", "tokens", "layout", "tokenSettings", "caption"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "collectionId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectionId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectionID = data
		case "tokens":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokens"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tokens = data
		case "layout":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layout"))
			data, err := ec.unmarshalNCollectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionLayoutInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layout = data
		case "tokenSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenSettings"))
			data, err := ec.unmarshalNCollectionTokenSettingsInput2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettingsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenSettings = data
		case "caption":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caption"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caption = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEmailInput(ctx context.Context, obj interface{}) (model.UpdateEmailInput, error) {
	var it model.UpdateEmailInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEmailNotificationSettingsInput(ctx context.Context, obj interface{}) (model.UpdateEmailNotificationSettingsInput, error) {
	var it model.UpdateEmailNotificationSettingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unsubscribedFromAll", "unsubscribedFromNotifications"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unsubscribedFromAll":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unsubscribedFromAll"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnsubscribedFromAll = data
		case "unsubscribedFromNotifications":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unsubscribedFromNotifications"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnsubscribedFromNotifications = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSocialAccountDisplayedInput(ctx context.Context, obj interface{}) (model.UpdateSocialAccountDisplayedInput, error) {
	var it model.UpdateSocialAccountDisplayedInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "displayed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "displayed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Displayed = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitCollectionsInput(ctx context.Context, obj interface{}) (model.UpdateSplitCollectionsInput, error) {
	var it model.UpdateSplitCollectionsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "collections"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "collections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collections"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Collections = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitHiddenInput(ctx context.Context, obj interface{}) (model.UpdateSplitHiddenInput, error) {
	var it model.UpdateSplitHiddenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "hidden"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "hidden":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hidden = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitInfoInput(ctx context.Context, obj interface{}) (model.UpdateSplitInfoInput, error) {
	var it model.UpdateSplitInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitInput(ctx context.Context, obj interface{}) (model.UpdateSplitInput, error) {
	var it model.UpdateSplitInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splitId", "name", "description", "caption", "deletedCollections", "updatedCollections", "createdCollections", "order", "editId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splitId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splitId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplitID = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "caption":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caption"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caption = data
		case "deletedCollections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedCollections"))
			data, err := ec.unmarshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedCollections = data
		case "updatedCollections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedCollections"))
			data, err := ec.unmarshalOUpdateCollectionInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedCollections = data
		case "createdCollections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdCollections"))
			data, err := ec.unmarshalOCreateCollectionInSplitInput2githubcomSplitFigosplitfigraphqlmodelCreateCollectionInSplitInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedCollections = data
		case "order":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "editId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("editId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EditID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSplitOrderInput(ctx context.Context, obj interface{}) (model.UpdateSplitOrderInput, error) {
	var it model.UpdateSplitOrderInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"positions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "positions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("positions"))
			data, err := ec.unmarshalNSplitPositionInput2githubcomSplitFigosplitfigraphqlmodelSplitPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Positions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTokenInfoInput(ctx context.Context, obj interface{}) (model.UpdateTokenInfoInput, error) {
	var it model.UpdateTokenInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tokenId", "collectorsNote", "collectionId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tokenId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenId"))
			data, err := ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TokenID = data
		case "collectorsNote":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectorsNote"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectorsNote = data
		case "collectionId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectionId"))
			data, err := ec.unmarshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectionID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserExperienceInput(ctx context.Context, obj interface{}) (model.UpdateUserExperienceInput, error) {
	var it model.UpdateUserExperienceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"experienceType", "experienced"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "experienceType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("experienceType"))
			data, err := ec.unmarshalNUserExperienceType2githubcomSplitFigosplitfigraphqlmodelUserExperienceType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExperienceType = data
		case "experienced":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("experienced"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Experienced = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserInfoInput(ctx context.Context, obj interface{}) (model.UpdateUserInfoInput, error) {
	var it model.UpdateUserInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "bio"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "bio":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bio"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bio = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUploadPersistedQueriesInput(ctx context.Context, obj interface{}) (model.UploadPersistedQueriesInput, error) {
	var it model.UploadPersistedQueriesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"persistedQueries"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "persistedQueries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("persistedQueries"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersistedQueries = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVerifyEmailInput(ctx context.Context, obj interface{}) (model.VerifyEmailInput, error) {
	var it model.VerifyEmailInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"token"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "token":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Token = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _AddRolesToUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.AddRolesToUserPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AddUserWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.AddUserWalletPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.AddUserWalletPayload:
		return ec._AddUserWalletPayload(ctx, sel, &obj)
	case *model.AddUserWalletPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._AddUserWalletPayload(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrAddressOwnedByUser:
		return ec._ErrAddressOwnedByUser(ctx, sel, &obj)
	case *model.ErrAddressOwnedByUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAddressOwnedByUser(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AdminAddWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.AdminAddWalletPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.AdminAddWalletPayload:
		return ec._AdminAddWalletPayload(ctx, sel, &obj)
	case *model.AdminAddWalletPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._AdminAddWalletPayload(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrAddressOwnedByUser:
		return ec._ErrAddressOwnedByUser(ctx, sel, &obj)
	case *model.ErrAddressOwnedByUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAddressOwnedByUser(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _AuthorizationError(ctx context.Context, sel ast.SelectionSet, obj model.AuthorizationError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrNoCookie:
		return ec._ErrNoCookie(ctx, sel, &obj)
	case *model.ErrNoCookie:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNoCookie(ctx, sel, obj)
	case model.ErrInvalidToken:
		return ec._ErrInvalidToken(ctx, sel, &obj)
	case *model.ErrInvalidToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidToken(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CollectionByIdOrError(ctx context.Context, sel ast.SelectionSet, obj model.CollectionByIDOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Collection:
		return ec._Collection(ctx, sel, &obj)
	case *model.Collection:
		if obj == nil {
			return graphql.Null
		}
		return ec._Collection(ctx, sel, obj)
	case model.ErrCollectionNotFound:
		return ec._ErrCollectionNotFound(ctx, sel, &obj)
	case *model.ErrCollectionNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrCollectionNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CollectionTokenByIdOrError(ctx context.Context, sel ast.SelectionSet, obj model.CollectionTokenByIDOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CollectionToken:
		return ec._CollectionToken(ctx, sel, &obj)
	case *model.CollectionToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._CollectionToken(ctx, sel, obj)
	case model.ErrCollectionNotFound:
		return ec._ErrCollectionNotFound(ctx, sel, &obj)
	case *model.ErrCollectionNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrCollectionNotFound(ctx, sel, obj)
	case model.ErrTokenNotFound:
		return ec._ErrTokenNotFound(ctx, sel, &obj)
	case *model.ErrTokenNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrTokenNotFound(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CommunityByAddressOrError(ctx context.Context, sel ast.SelectionSet, obj model.CommunityByAddressOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Community:
		return ec._Community(ctx, sel, &obj)
	case *model.Community:
		if obj == nil {
			return graphql.Null
		}
		return ec._Community(ctx, sel, obj)
	case model.ErrCommunityNotFound:
		return ec._ErrCommunityNotFound(ctx, sel, &obj)
	case *model.ErrCommunityNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrCommunityNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ConnectSocialAccountPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.ConnectSocialAccountPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ConnectSocialAccountPayload:
		return ec._ConnectSocialAccountPayload(ctx, sel, &obj)
	case *model.ConnectSocialAccountPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConnectSocialAccountPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CreateCollectionPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.CreateCollectionPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CreateCollectionPayload:
		return ec._CreateCollectionPayload(ctx, sel, &obj)
	case *model.CreateCollectionPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._CreateCollectionPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CreateSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.CreateSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CreateSplitPayload:
		return ec._CreateSplitPayload(ctx, sel, &obj)
	case *model.CreateSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._CreateSplitPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CreateUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.CreateUserPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.CreateUserPayload:
		return ec._CreateUserPayload(ctx, sel, &obj)
	case *model.CreateUserPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._CreateUserPayload(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	case model.ErrUserAlreadyExists:
		return ec._ErrUserAlreadyExists(ctx, sel, &obj)
	case *model.ErrUserAlreadyExists:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserAlreadyExists(ctx, sel, obj)
	case model.ErrUsernameNotAvailable:
		return ec._ErrUsernameNotAvailable(ctx, sel, &obj)
	case *model.ErrUsernameNotAvailable:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUsernameNotAvailable(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DeepRefreshPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.DeepRefreshPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DeepRefreshPayload:
		return ec._DeepRefreshPayload(ctx, sel, &obj)
	case *model.DeepRefreshPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeepRefreshPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DeleteCollectionPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.DeleteCollectionPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DeleteCollectionPayload:
		return ec._DeleteCollectionPayload(ctx, sel, &obj)
	case *model.DeleteCollectionPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeleteCollectionPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrCollectionNotFound:
		return ec._ErrCollectionNotFound(ctx, sel, &obj)
	case *model.ErrCollectionNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrCollectionNotFound(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DeleteSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.DeleteSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DeleteSplitPayload:
		return ec._DeleteSplitPayload(ctx, sel, &obj)
	case *model.DeleteSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeleteSplitPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DisconnectSocialAccountPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.DisconnectSocialAccountPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DisconnectSocialAccountPayload:
		return ec._DisconnectSocialAccountPayload(ctx, sel, &obj)
	case *model.DisconnectSocialAccountPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._DisconnectSocialAccountPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrNeedsToReconnectSocial:
		return ec._ErrNeedsToReconnectSocial(ctx, sel, &obj)
	case *model.ErrNeedsToReconnectSocial:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNeedsToReconnectSocial(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Error(ctx context.Context, sel ast.SelectionSet, obj model.Error) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ErrCollectionNotFound:
		return ec._ErrCollectionNotFound(ctx, sel, &obj)
	case *model.ErrCollectionNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrCollectionNotFound(ctx, sel, obj)
	case model.ErrTokenNotFound:
		return ec._ErrTokenNotFound(ctx, sel, &obj)
	case *model.ErrTokenNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrTokenNotFound(ctx, sel, obj)
	case model.ErrSplitNotFound:
		return ec._ErrSplitNotFound(ctx, sel, &obj)
	case *model.ErrSplitNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSplitNotFound(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrUserAlreadyExists:
		return ec._ErrUserAlreadyExists(ctx, sel, &obj)
	case *model.ErrUserAlreadyExists:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserAlreadyExists(ctx, sel, obj)
	case model.ErrUsernameNotAvailable:
		return ec._ErrUsernameNotAvailable(ctx, sel, &obj)
	case *model.ErrUsernameNotAvailable:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUsernameNotAvailable(ctx, sel, obj)
	case model.ErrAddressOwnedByUser:
		return ec._ErrAddressOwnedByUser(ctx, sel, &obj)
	case *model.ErrAddressOwnedByUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAddressOwnedByUser(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrCommunityNotFound:
		return ec._ErrCommunityNotFound(ctx, sel, &obj)
	case *model.ErrCommunityNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrCommunityNotFound(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNoCookie:
		return ec._ErrNoCookie(ctx, sel, &obj)
	case *model.ErrNoCookie:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNoCookie(ctx, sel, obj)
	case model.ErrInvalidToken:
		return ec._ErrInvalidToken(ctx, sel, &obj)
	case *model.ErrInvalidToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidToken(ctx, sel, obj)
	case model.ErrNeedsToReconnectSocial:
		return ec._ErrNeedsToReconnectSocial(ctx, sel, &obj)
	case *model.ErrNeedsToReconnectSocial:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNeedsToReconnectSocial(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	case model.ErrSyncFailed:
		return ec._ErrSyncFailed(ctx, sel, &obj)
	case *model.ErrSyncFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSyncFailed(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _FollowAllSocialConnectionsPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.FollowAllSocialConnectionsPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.FollowAllSocialConnectionsPayload:
		return ec._FollowAllSocialConnectionsPayload(ctx, sel, &obj)
	case *model.FollowAllSocialConnectionsPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._FollowAllSocialConnectionsPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrNeedsToReconnectSocial:
		return ec._ErrNeedsToReconnectSocial(ctx, sel, &obj)
	case *model.ErrNeedsToReconnectSocial:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNeedsToReconnectSocial(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _FollowUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.FollowUserPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.FollowUserPayload:
		return ec._FollowUserPayload(ctx, sel, &obj)
	case *model.FollowUserPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._FollowUserPayload(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _GetAuthNoncePayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.GetAuthNoncePayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.AuthNonce:
		return ec._AuthNonce(ctx, sel, &obj)
	case *model.AuthNonce:
		if obj == nil {
			return graphql.Null
		}
		return ec._AuthNonce(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _GroupedNotification(ctx context.Context, sel ast.SelectionSet, obj model.GroupedNotification) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SomeoneFollowedYouNotification:
		return ec._SomeoneFollowedYouNotification(ctx, sel, &obj)
	case *model.SomeoneFollowedYouNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneFollowedYouNotification(ctx, sel, obj)
	case model.SomeoneFollowedYouBackNotification:
		return ec._SomeoneFollowedYouBackNotification(ctx, sel, &obj)
	case *model.SomeoneFollowedYouBackNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneFollowedYouBackNotification(ctx, sel, obj)
	case model.SomeoneViewedYourSplitNotification:
		return ec._SomeoneViewedYourSplitNotification(ctx, sel, &obj)
	case *model.SomeoneViewedYourSplitNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneViewedYourSplitNotification(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _LoginPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.LoginPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.LoginPayload:
		return ec._LoginPayload(ctx, sel, &obj)
	case *model.LoginPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._LoginPayload(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrDoesNotOwnRequiredToken:
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, &obj)
	case *model.ErrDoesNotOwnRequiredToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrDoesNotOwnRequiredToken(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Media(ctx context.Context, sel ast.SelectionSet, obj model.Media) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ImageMedia:
		return ec._ImageMedia(ctx, sel, &obj)
	case *model.ImageMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageMedia(ctx, sel, obj)
	case model.GIFMedia:
		return ec._GIFMedia(ctx, sel, &obj)
	case *model.GIFMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._GIFMedia(ctx, sel, obj)
	case model.VideoMedia:
		return ec._VideoMedia(ctx, sel, &obj)
	case *model.VideoMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._VideoMedia(ctx, sel, obj)
	case model.AudioMedia:
		return ec._AudioMedia(ctx, sel, &obj)
	case *model.AudioMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._AudioMedia(ctx, sel, obj)
	case model.TextMedia:
		return ec._TextMedia(ctx, sel, &obj)
	case *model.TextMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._TextMedia(ctx, sel, obj)
	case model.PDFMedia:
		return ec._PdfMedia(ctx, sel, &obj)
	case *model.PDFMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._PdfMedia(ctx, sel, obj)
	case model.HTMLMedia:
		return ec._HtmlMedia(ctx, sel, &obj)
	case *model.HTMLMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._HtmlMedia(ctx, sel, obj)
	case model.JSONMedia:
		return ec._JsonMedia(ctx, sel, &obj)
	case *model.JSONMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._JsonMedia(ctx, sel, obj)
	case model.GltfMedia:
		return ec._GltfMedia(ctx, sel, &obj)
	case *model.GltfMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._GltfMedia(ctx, sel, obj)
	case model.UnknownMedia:
		return ec._UnknownMedia(ctx, sel, &obj)
	case *model.UnknownMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnknownMedia(ctx, sel, obj)
	case model.SyncingMedia:
		return ec._SyncingMedia(ctx, sel, &obj)
	case *model.SyncingMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._SyncingMedia(ctx, sel, obj)
	case model.InvalidMedia:
		return ec._InvalidMedia(ctx, sel, &obj)
	case *model.InvalidMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidMedia(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _MediaSubtype(ctx context.Context, sel ast.SelectionSet, obj model.MediaSubtype) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ImageMedia:
		return ec._ImageMedia(ctx, sel, &obj)
	case *model.ImageMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageMedia(ctx, sel, obj)
	case model.GIFMedia:
		return ec._GIFMedia(ctx, sel, &obj)
	case *model.GIFMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._GIFMedia(ctx, sel, obj)
	case model.VideoMedia:
		return ec._VideoMedia(ctx, sel, &obj)
	case *model.VideoMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._VideoMedia(ctx, sel, obj)
	case model.AudioMedia:
		return ec._AudioMedia(ctx, sel, &obj)
	case *model.AudioMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._AudioMedia(ctx, sel, obj)
	case model.TextMedia:
		return ec._TextMedia(ctx, sel, &obj)
	case *model.TextMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._TextMedia(ctx, sel, obj)
	case model.PDFMedia:
		return ec._PdfMedia(ctx, sel, &obj)
	case *model.PDFMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._PdfMedia(ctx, sel, obj)
	case model.HTMLMedia:
		return ec._HtmlMedia(ctx, sel, &obj)
	case *model.HTMLMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._HtmlMedia(ctx, sel, obj)
	case model.JSONMedia:
		return ec._JsonMedia(ctx, sel, &obj)
	case *model.JSONMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._JsonMedia(ctx, sel, obj)
	case model.GltfMedia:
		return ec._GltfMedia(ctx, sel, &obj)
	case *model.GltfMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._GltfMedia(ctx, sel, obj)
	case model.UnknownMedia:
		return ec._UnknownMedia(ctx, sel, &obj)
	case *model.UnknownMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnknownMedia(ctx, sel, obj)
	case model.SyncingMedia:
		return ec._SyncingMedia(ctx, sel, &obj)
	case *model.SyncingMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._SyncingMedia(ctx, sel, obj)
	case model.InvalidMedia:
		return ec._InvalidMedia(ctx, sel, &obj)
	case *model.InvalidMedia:
		if obj == nil {
			return graphql.Null
		}
		return ec._InvalidMedia(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _MintPremiumCardToWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.MintPremiumCardToWalletPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.MintPremiumCardToWalletPayload:
		return ec._MintPremiumCardToWalletPayload(ctx, sel, &obj)
	case *model.MintPremiumCardToWalletPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._MintPremiumCardToWalletPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrNeedsToReconnectSocial:
		return ec._ErrNeedsToReconnectSocial(ctx, sel, &obj)
	case *model.ErrNeedsToReconnectSocial:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNeedsToReconnectSocial(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _MoveCollectionToSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.MoveCollectionToSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.MoveCollectionToSplitPayload:
		return ec._MoveCollectionToSplitPayload(ctx, sel, &obj)
	case *model.MoveCollectionToSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._MoveCollectionToSplitPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj model.Node) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DeletedNode:
		return ec._DeletedNode(ctx, sel, &obj)
	case *model.DeletedNode:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeletedNode(ctx, sel, obj)
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.Wallet:
		return ec._Wallet(ctx, sel, &obj)
	case *model.Wallet:
		if obj == nil {
			return graphql.Null
		}
		return ec._Wallet(ctx, sel, obj)
	case model.Token:
		return ec._Token(ctx, sel, &obj)
	case *model.Token:
		if obj == nil {
			return graphql.Null
		}
		return ec._Token(ctx, sel, obj)
	case model.CollectionToken:
		return ec._CollectionToken(ctx, sel, &obj)
	case *model.CollectionToken:
		if obj == nil {
			return graphql.Null
		}
		return ec._CollectionToken(ctx, sel, obj)
	case model.Collection:
		return ec._Collection(ctx, sel, &obj)
	case *model.Collection:
		if obj == nil {
			return graphql.Null
		}
		return ec._Collection(ctx, sel, obj)
	case model.Split:
		return ec._Split(ctx, sel, &obj)
	case *model.Split:
		if obj == nil {
			return graphql.Null
		}
		return ec._Split(ctx, sel, obj)
	case model.MembershipTier:
		return ec._MembershipTier(ctx, sel, &obj)
	case *model.MembershipTier:
		if obj == nil {
			return graphql.Null
		}
		return ec._MembershipTier(ctx, sel, obj)
	case model.Community:
		return ec._Community(ctx, sel, &obj)
	case *model.Community:
		if obj == nil {
			return graphql.Null
		}
		return ec._Community(ctx, sel, obj)
	case model.Contract:
		return ec._Contract(ctx, sel, &obj)
	case *model.Contract:
		if obj == nil {
			return graphql.Null
		}
		return ec._Contract(ctx, sel, obj)
	case model.Viewer:
		return ec._Viewer(ctx, sel, &obj)
	case *model.Viewer:
		if obj == nil {
			return graphql.Null
		}
		return ec._Viewer(ctx, sel, obj)
	case model.SocialConnection:
		return ec._SocialConnection(ctx, sel, &obj)
	case *model.SocialConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._SocialConnection(ctx, sel, obj)
	case model.Notification:
		if obj == nil {
			return graphql.Null
		}
		return ec._Notification(ctx, sel, obj)
	case model.GroupedNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._GroupedNotification(ctx, sel, obj)
	case model.SomeoneFollowedYouNotification:
		return ec._SomeoneFollowedYouNotification(ctx, sel, &obj)
	case *model.SomeoneFollowedYouNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneFollowedYouNotification(ctx, sel, obj)
	case model.SomeoneFollowedYouBackNotification:
		return ec._SomeoneFollowedYouBackNotification(ctx, sel, &obj)
	case *model.SomeoneFollowedYouBackNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneFollowedYouBackNotification(ctx, sel, obj)
	case model.SomeoneViewedYourSplitNotification:
		return ec._SomeoneViewedYourSplitNotification(ctx, sel, &obj)
	case *model.SomeoneViewedYourSplitNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneViewedYourSplitNotification(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Notification(ctx context.Context, sel ast.SelectionSet, obj model.Notification) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.GroupedNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._GroupedNotification(ctx, sel, obj)
	case model.SomeoneFollowedYouNotification:
		return ec._SomeoneFollowedYouNotification(ctx, sel, &obj)
	case *model.SomeoneFollowedYouNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneFollowedYouNotification(ctx, sel, obj)
	case model.SomeoneFollowedYouBackNotification:
		return ec._SomeoneFollowedYouBackNotification(ctx, sel, &obj)
	case *model.SomeoneFollowedYouBackNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneFollowedYouBackNotification(ctx, sel, obj)
	case model.SomeoneViewedYourSplitNotification:
		return ec._SomeoneViewedYourSplitNotification(ctx, sel, &obj)
	case *model.SomeoneViewedYourSplitNotification:
		if obj == nil {
			return graphql.Null
		}
		return ec._SomeoneViewedYourSplitNotification(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _PreverifyEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.PreverifyEmailPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.PreverifyEmailPayload:
		return ec._PreverifyEmailPayload(ctx, sel, &obj)
	case *model.PreverifyEmailPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._PreverifyEmailPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _PublishSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.PublishSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.PublishSplitPayload:
		return ec._PublishSplitPayload(ctx, sel, &obj)
	case *model.PublishSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._PublishSplitPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _RefreshCollectionPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.RefreshCollectionPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RefreshCollectionPayload:
		return ec._RefreshCollectionPayload(ctx, sel, &obj)
	case *model.RefreshCollectionPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._RefreshCollectionPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrSyncFailed:
		return ec._ErrSyncFailed(ctx, sel, &obj)
	case *model.ErrSyncFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSyncFailed(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _RefreshContractPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.RefreshContractPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RefreshContractPayload:
		return ec._RefreshContractPayload(ctx, sel, &obj)
	case *model.RefreshContractPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._RefreshContractPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrSyncFailed:
		return ec._ErrSyncFailed(ctx, sel, &obj)
	case *model.ErrSyncFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSyncFailed(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _RefreshTokenPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.RefreshTokenPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RefreshTokenPayload:
		return ec._RefreshTokenPayload(ctx, sel, &obj)
	case *model.RefreshTokenPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._RefreshTokenPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrSyncFailed:
		return ec._ErrSyncFailed(ctx, sel, &obj)
	case *model.ErrSyncFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSyncFailed(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _RemoveUserWalletsPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.RemoveUserWalletsPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.RemoveUserWalletsPayload:
		return ec._RemoveUserWalletsPayload(ctx, sel, &obj)
	case *model.RemoveUserWalletsPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._RemoveUserWalletsPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ResendVerificationEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.ResendVerificationEmailPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ResendVerificationEmailPayload:
		return ec._ResendVerificationEmailPayload(ctx, sel, &obj)
	case *model.ResendVerificationEmailPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._ResendVerificationEmailPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _RevokeRolesFromUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.RevokeRolesFromUserPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchCommunitiesPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SearchCommunitiesPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SearchCommunitiesPayload:
		return ec._SearchCommunitiesPayload(ctx, sel, &obj)
	case *model.SearchCommunitiesPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._SearchCommunitiesPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchSplitsPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SearchSplitsPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SearchSplitsPayload:
		return ec._SearchSplitsPayload(ctx, sel, &obj)
	case *model.SearchSplitsPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._SearchSplitsPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SearchUsersPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SearchUsersPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SearchUsersPayload:
		return ec._SearchUsersPayload(ctx, sel, &obj)
	case *model.SearchUsersPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._SearchUsersPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SetSpamPreferencePayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SetSpamPreferencePayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SetSpamPreferencePayload:
		return ec._SetSpamPreferencePayload(ctx, sel, &obj)
	case *model.SetSpamPreferencePayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._SetSpamPreferencePayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SocialAccount(ctx context.Context, sel ast.SelectionSet, obj model.SocialAccount) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.TwitterSocialAccount:
		return ec._TwitterSocialAccount(ctx, sel, &obj)
	case *model.TwitterSocialAccount:
		if obj == nil {
			return graphql.Null
		}
		return ec._TwitterSocialAccount(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SocialConnectionsOrError(ctx context.Context, sel ast.SelectionSet, obj model.SocialConnectionsOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SocialConnection:
		return ec._SocialConnection(ctx, sel, &obj)
	case *model.SocialConnection:
		if obj == nil {
			return graphql.Null
		}
		return ec._SocialConnection(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SocialQueriesOrError(ctx context.Context, sel ast.SelectionSet, obj model.SocialQueriesOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SocialQueries:
		return ec._SocialQueries(ctx, sel, &obj)
	case *model.SocialQueries:
		if obj == nil {
			return graphql.Null
		}
		return ec._SocialQueries(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrNeedsToReconnectSocial:
		return ec._ErrNeedsToReconnectSocial(ctx, sel, &obj)
	case *model.ErrNeedsToReconnectSocial:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNeedsToReconnectSocial(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SplitByIdPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SplitByIDPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Split:
		return ec._Split(ctx, sel, &obj)
	case *model.Split:
		if obj == nil {
			return graphql.Null
		}
		return ec._Split(ctx, sel, obj)
	case model.ErrSplitNotFound:
		return ec._ErrSplitNotFound(ctx, sel, &obj)
	case *model.ErrSplitNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSplitNotFound(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SplitFiUserOrAddress(ctx context.Context, sel ast.SelectionSet, obj model.SplitFiUserOrAddress) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case *persist.ChainAddress:
		if obj == nil {
			return graphql.Null
		}
		return ec._ChainAddress(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SplitFiUserOrWallet(ctx context.Context, sel ast.SelectionSet, obj model.SplitFiUserOrWallet) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.Wallet:
		return ec._Wallet(ctx, sel, &obj)
	case *model.Wallet:
		if obj == nil {
			return graphql.Null
		}
		return ec._Wallet(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SyncTokensForUsernamePayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SyncTokensForUsernamePayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SyncTokensForUsernamePayload:
		return ec._SyncTokensForUsernamePayload(ctx, sel, &obj)
	case *model.SyncTokensForUsernamePayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._SyncTokensForUsernamePayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrSyncFailed:
		return ec._ErrSyncFailed(ctx, sel, &obj)
	case *model.ErrSyncFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSyncFailed(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SyncTokensPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.SyncTokensPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SyncTokensPayload:
		return ec._SyncTokensPayload(ctx, sel, &obj)
	case *model.SyncTokensPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._SyncTokensPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrSyncFailed:
		return ec._ErrSyncFailed(ctx, sel, &obj)
	case *model.ErrSyncFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSyncFailed(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _TokenByIdOrError(ctx context.Context, sel ast.SelectionSet, obj model.TokenByIDOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Token:
		return ec._Token(ctx, sel, &obj)
	case *model.Token:
		if obj == nil {
			return graphql.Null
		}
		return ec._Token(ctx, sel, obj)
	case model.ErrTokenNotFound:
		return ec._ErrTokenNotFound(ctx, sel, &obj)
	case *model.ErrTokenNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrTokenNotFound(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UnfollowUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UnfollowUserPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UnfollowUserPayload:
		return ec._UnfollowUserPayload(ctx, sel, &obj)
	case *model.UnfollowUserPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnfollowUserPayload(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UnsubscribeFromEmailTypePayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UnsubscribeFromEmailTypePayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UnsubscribeFromEmailTypePayload:
		return ec._UnsubscribeFromEmailTypePayload(ctx, sel, &obj)
	case *model.UnsubscribeFromEmailTypePayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnsubscribeFromEmailTypePayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateCollectionHiddenPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateCollectionHiddenPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateCollectionHiddenPayload:
		return ec._UpdateCollectionHiddenPayload(ctx, sel, &obj)
	case *model.UpdateCollectionHiddenPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateCollectionHiddenPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateCollectionInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateCollectionInfoPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateCollectionInfoPayload:
		return ec._UpdateCollectionInfoPayload(ctx, sel, &obj)
	case *model.UpdateCollectionInfoPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateCollectionInfoPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateCollectionTokensPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateCollectionTokensPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateCollectionTokensPayload:
		return ec._UpdateCollectionTokensPayload(ctx, sel, &obj)
	case *model.UpdateCollectionTokensPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateCollectionTokensPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateEmailNotificationSettingsPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateEmailNotificationSettingsPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateEmailNotificationSettingsPayload:
		return ec._UpdateEmailNotificationSettingsPayload(ctx, sel, &obj)
	case *model.UpdateEmailNotificationSettingsPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateEmailNotificationSettingsPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateEmailPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateEmailPayload:
		return ec._UpdateEmailPayload(ctx, sel, &obj)
	case *model.UpdateEmailPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateEmailPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateFeaturedSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateFeaturedSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateFeaturedSplitPayload:
		return ec._UpdateFeaturedSplitPayload(ctx, sel, &obj)
	case *model.UpdateFeaturedSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateFeaturedSplitPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdatePrimaryWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdatePrimaryWalletPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdatePrimaryWalletPayload:
		return ec._UpdatePrimaryWalletPayload(ctx, sel, &obj)
	case *model.UpdatePrimaryWalletPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdatePrimaryWalletPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSocialAccountDisplayedPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSocialAccountDisplayedPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateSocialAccountDisplayedPayload:
		return ec._UpdateSocialAccountDisplayedPayload(ctx, sel, &obj)
	case *model.UpdateSocialAccountDisplayedPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSocialAccountDisplayedPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrNeedsToReconnectSocial:
		return ec._ErrNeedsToReconnectSocial(ctx, sel, &obj)
	case *model.ErrNeedsToReconnectSocial:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNeedsToReconnectSocial(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitCollectionsPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitCollectionsPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateSplitCollectionsPayload:
		return ec._UpdateSplitCollectionsPayload(ctx, sel, &obj)
	case *model.UpdateSplitCollectionsPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitCollectionsPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitHiddenPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitHiddenPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateSplitHiddenPayload:
		return ec._UpdateSplitHiddenPayload(ctx, sel, &obj)
	case *model.UpdateSplitHiddenPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitHiddenPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitInfoPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateSplitInfoPayload:
		return ec._UpdateSplitInfoPayload(ctx, sel, &obj)
	case *model.UpdateSplitInfoPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitInfoPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitOrderPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitOrderPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateSplitOrderPayload:
		return ec._UpdateSplitOrderPayload(ctx, sel, &obj)
	case *model.UpdateSplitOrderPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitOrderPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateSplitPayload:
		return ec._UpdateSplitPayload(ctx, sel, &obj)
	case *model.UpdateSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateSplitPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateTokenInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateTokenInfoPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateTokenInfoPayload:
		return ec._UpdateTokenInfoPayload(ctx, sel, &obj)
	case *model.UpdateTokenInfoPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateTokenInfoPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateUserExperiencePayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateUserExperiencePayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateUserExperiencePayload:
		return ec._UpdateUserExperiencePayload(ctx, sel, &obj)
	case *model.UpdateUserExperiencePayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateUserExperiencePayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpdateUserInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UpdateUserInfoPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UpdateUserInfoPayload:
		return ec._UpdateUserInfoPayload(ctx, sel, &obj)
	case *model.UpdateUserInfoPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UpdateUserInfoPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	case model.ErrUsernameNotAvailable:
		return ec._ErrUsernameNotAvailable(ctx, sel, &obj)
	case *model.ErrUsernameNotAvailable:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUsernameNotAvailable(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UploadPersistedQueriesPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.UploadPersistedQueriesPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.UploadPersistedQueriesPayload:
		return ec._UploadPersistedQueriesPayload(ctx, sel, &obj)
	case *model.UploadPersistedQueriesPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._UploadPersistedQueriesPayload(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserByAddressOrError(ctx context.Context, sel ast.SelectionSet, obj model.UserByAddressOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserByIdOrError(ctx context.Context, sel ast.SelectionSet, obj model.UserByIDOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UserByUsernameOrError(ctx context.Context, sel ast.SelectionSet, obj model.UserByUsernameOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.SplitFiUser:
		return ec._SplitFiUser(ctx, sel, &obj)
	case *model.SplitFiUser:
		if obj == nil {
			return graphql.Null
		}
		return ec._SplitFiUser(ctx, sel, obj)
	case model.ErrUserNotFound:
		return ec._ErrUserNotFound(ctx, sel, &obj)
	case *model.ErrUserNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrUserNotFound(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _VerifyEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.VerifyEmailPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.VerifyEmailPayload:
		return ec._VerifyEmailPayload(ctx, sel, &obj)
	case *model.VerifyEmailPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._VerifyEmailPayload(ctx, sel, obj)
	case model.ErrInvalidInput:
		return ec._ErrInvalidInput(ctx, sel, &obj)
	case *model.ErrInvalidInput:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrInvalidInput(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ViewSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.ViewSplitPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ViewSplitPayload:
		return ec._ViewSplitPayload(ctx, sel, &obj)
	case *model.ViewSplitPayload:
		if obj == nil {
			return graphql.Null
		}
		return ec._ViewSplitPayload(ctx, sel, obj)
	case model.ErrAuthenticationFailed:
		return ec._ErrAuthenticationFailed(ctx, sel, &obj)
	case *model.ErrAuthenticationFailed:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrAuthenticationFailed(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ViewerOrError(ctx context.Context, sel ast.SelectionSet, obj model.ViewerOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Viewer:
		return ec._Viewer(ctx, sel, &obj)
	case *model.Viewer:
		if obj == nil {
			return graphql.Null
		}
		return ec._Viewer(ctx, sel, obj)
	case model.ErrNotAuthorized:
		return ec._ErrNotAuthorized(ctx, sel, &obj)
	case *model.ErrNotAuthorized:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrNotAuthorized(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ViewerSplitByIdPayloadOrError(ctx context.Context, sel ast.SelectionSet, obj model.ViewerSplitByIDPayloadOrError) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ViewerSplit:
		return ec._ViewerSplit(ctx, sel, &obj)
	case *model.ViewerSplit:
		if obj == nil {
			return graphql.Null
		}
		return ec._ViewerSplit(ctx, sel, obj)
	case model.ErrSplitNotFound:
		return ec._ErrSplitNotFound(ctx, sel, &obj)
	case *model.ErrSplitNotFound:
		if obj == nil {
			return graphql.Null
		}
		return ec._ErrSplitNotFound(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addUserWalletPayloadImplementors = []string{"AddUserWalletPayload", "AddUserWalletPayloadOrError"}

func (ec *executionContext) _AddUserWalletPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AddUserWalletPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, addUserWalletPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddUserWalletPayload")
		case "viewer":

			out.Values[i] = ec._AddUserWalletPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adminAddWalletPayloadImplementors = []string{"AdminAddWalletPayload", "AdminAddWalletPayloadOrError"}

func (ec *executionContext) _AdminAddWalletPayload(ctx context.Context, sel ast.SelectionSet, obj *model.AdminAddWalletPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminAddWalletPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminAddWalletPayload")
		case "user":

			out.Values[i] = ec._AdminAddWalletPayload_user(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var audioMediaImplementors = []string{"AudioMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _AudioMedia(ctx context.Context, sel ast.SelectionSet, obj *model.AudioMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, audioMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AudioMedia")
		case "previewURLs":

			out.Values[i] = ec._AudioMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._AudioMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._AudioMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._AudioMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._AudioMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var authNonceImplementors = []string{"AuthNonce", "GetAuthNoncePayloadOrError"}

func (ec *executionContext) _AuthNonce(ctx context.Context, sel ast.SelectionSet, obj *model.AuthNonce) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authNonceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthNonce")
		case "nonce":

			out.Values[i] = ec._AuthNonce_nonce(ctx, field, obj)

		case "userExists":

			out.Values[i] = ec._AuthNonce_userExists(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var badgeImplementors = []string{"Badge"}

func (ec *executionContext) _Badge(ctx context.Context, sel ast.SelectionSet, obj *model.Badge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, badgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Badge")
		case "name":

			out.Values[i] = ec._Badge_name(ctx, field, obj)

		case "imageURL":

			out.Values[i] = ec._Badge_imageURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "contract":

			out.Values[i] = ec._Badge_contract(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chainAddressImplementors = []string{"ChainAddress", "SplitFiUserOrAddress"}

func (ec *executionContext) _ChainAddress(ctx context.Context, sel ast.SelectionSet, obj *persist.ChainAddress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chainAddressImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChainAddress")
		case "address":

			out.Values[i] = ec._ChainAddress_address(ctx, field, obj)

		case "chain":

			out.Values[i] = ec._ChainAddress_chain(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chainPubKeyImplementors = []string{"ChainPubKey"}

func (ec *executionContext) _ChainPubKey(ctx context.Context, sel ast.SelectionSet, obj *persist.ChainPubKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chainPubKeyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChainPubKey")
		case "pubKey":

			out.Values[i] = ec._ChainPubKey_pubKey(ctx, field, obj)

		case "chain":

			out.Values[i] = ec._ChainPubKey_chain(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var chainTokensImplementors = []string{"ChainTokens"}

func (ec *executionContext) _ChainTokens(ctx context.Context, sel ast.SelectionSet, obj *model.ChainTokens) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chainTokensImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChainTokens")
		case "chain":

			out.Values[i] = ec._ChainTokens_chain(ctx, field, obj)

		case "tokens":

			out.Values[i] = ec._ChainTokens_tokens(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clearAllNotificationsPayloadImplementors = []string{"ClearAllNotificationsPayload"}

func (ec *executionContext) _ClearAllNotificationsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ClearAllNotificationsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clearAllNotificationsPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClearAllNotificationsPayload")
		case "notifications":

			out.Values[i] = ec._ClearAllNotificationsPayload_notifications(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var collectionImplementors = []string{"Collection", "Node", "CollectionByIdOrError"}

func (ec *executionContext) _Collection(ctx context.Context, sel ast.SelectionSet, obj *model.Collection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, collectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Collection")
		case "id":

			out.Values[i] = ec._Collection_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dbid":

			out.Values[i] = ec._Collection_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "version":

			out.Values[i] = ec._Collection_version(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Collection_name(ctx, field, obj)

		case "collectorsNote":

			out.Values[i] = ec._Collection_collectorsNote(ctx, field, obj)

		case "split":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Collection_split(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "layout":

			out.Values[i] = ec._Collection_layout(ctx, field, obj)

		case "hidden":

			out.Values[i] = ec._Collection_hidden(ctx, field, obj)

		case "tokens":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Collection_tokens(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var collectionLayoutImplementors = []string{"CollectionLayout"}

func (ec *executionContext) _CollectionLayout(ctx context.Context, sel ast.SelectionSet, obj *model.CollectionLayout) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, collectionLayoutImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CollectionLayout")
		case "sections":

			out.Values[i] = ec._CollectionLayout_sections(ctx, field, obj)

		case "sectionLayout":

			out.Values[i] = ec._CollectionLayout_sectionLayout(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var collectionSectionLayoutImplementors = []string{"CollectionSectionLayout"}

func (ec *executionContext) _CollectionSectionLayout(ctx context.Context, sel ast.SelectionSet, obj *model.CollectionSectionLayout) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, collectionSectionLayoutImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CollectionSectionLayout")
		case "columns":

			out.Values[i] = ec._CollectionSectionLayout_columns(ctx, field, obj)

		case "whitespace":

			out.Values[i] = ec._CollectionSectionLayout_whitespace(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var collectionTokenImplementors = []string{"CollectionToken", "Node", "CollectionTokenByIdOrError"}

func (ec *executionContext) _CollectionToken(ctx context.Context, sel ast.SelectionSet, obj *model.CollectionToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, collectionTokenImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CollectionToken")
		case "id":

			out.Values[i] = ec._CollectionToken_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "token":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CollectionToken_token(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "collection":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CollectionToken_collection(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tokenSettings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CollectionToken_tokenSettings(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var collectionTokenSettingsImplementors = []string{"CollectionTokenSettings"}

func (ec *executionContext) _CollectionTokenSettings(ctx context.Context, sel ast.SelectionSet, obj *model.CollectionTokenSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, collectionTokenSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CollectionTokenSettings")
		case "renderLive":

			out.Values[i] = ec._CollectionTokenSettings_renderLive(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var communitiesConnectionImplementors = []string{"CommunitiesConnection"}

func (ec *executionContext) _CommunitiesConnection(ctx context.Context, sel ast.SelectionSet, obj *model.CommunitiesConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, communitiesConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommunitiesConnection")
		case "edges":

			out.Values[i] = ec._CommunitiesConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._CommunitiesConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var communityImplementors = []string{"Community", "Node", "CommunityByAddressOrError"}

func (ec *executionContext) _Community(ctx context.Context, sel ast.SelectionSet, obj *model.Community) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, communityImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Community")
		case "dbid":

			out.Values[i] = ec._Community_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "id":

			out.Values[i] = ec._Community_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastUpdated":

			out.Values[i] = ec._Community_lastUpdated(ctx, field, obj)

		case "contractAddress":

			out.Values[i] = ec._Community_contractAddress(ctx, field, obj)

		case "creatorAddress":

			out.Values[i] = ec._Community_creatorAddress(ctx, field, obj)

		case "chain":

			out.Values[i] = ec._Community_chain(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Community_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec._Community_description(ctx, field, obj)

		case "previewImage":

			out.Values[i] = ec._Community_previewImage(ctx, field, obj)

		case "profileImageURL":

			out.Values[i] = ec._Community_profileImageURL(ctx, field, obj)

		case "profileBannerURL":

			out.Values[i] = ec._Community_profileBannerURL(ctx, field, obj)

		case "badgeURL":

			out.Values[i] = ec._Community_badgeURL(ctx, field, obj)

		case "tokensInCommunity":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Community_tokensInCommunity(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "owners":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Community_owners(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var communityEdgeImplementors = []string{"CommunityEdge"}

func (ec *executionContext) _CommunityEdge(ctx context.Context, sel ast.SelectionSet, obj *model.CommunityEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, communityEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommunityEdge")
		case "node":

			out.Values[i] = ec._CommunityEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._CommunityEdge_cursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var communitySearchResultImplementors = []string{"CommunitySearchResult"}

func (ec *executionContext) _CommunitySearchResult(ctx context.Context, sel ast.SelectionSet, obj *model.CommunitySearchResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, communitySearchResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommunitySearchResult")
		case "community":

			out.Values[i] = ec._CommunitySearchResult_community(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var connectSocialAccountPayloadImplementors = []string{"ConnectSocialAccountPayload", "ConnectSocialAccountPayloadOrError"}

func (ec *executionContext) _ConnectSocialAccountPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectSocialAccountPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectSocialAccountPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectSocialAccountPayload")
		case "viewer":

			out.Values[i] = ec._ConnectSocialAccountPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var contractImplementors = []string{"Contract", "Node"}

func (ec *executionContext) _Contract(ctx context.Context, sel ast.SelectionSet, obj *model.Contract) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contractImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Contract")
		case "id":

			out.Values[i] = ec._Contract_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbid":

			out.Values[i] = ec._Contract_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastUpdated":

			out.Values[i] = ec._Contract_lastUpdated(ctx, field, obj)

		case "contractAddress":

			out.Values[i] = ec._Contract_contractAddress(ctx, field, obj)

		case "creatorAddress":

			out.Values[i] = ec._Contract_creatorAddress(ctx, field, obj)

		case "chain":

			out.Values[i] = ec._Contract_chain(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Contract_name(ctx, field, obj)

		case "profileImageURL":

			out.Values[i] = ec._Contract_profileImageURL(ctx, field, obj)

		case "profileBannerURL":

			out.Values[i] = ec._Contract_profileBannerURL(ctx, field, obj)

		case "badgeURL":

			out.Values[i] = ec._Contract_badgeURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createCollectionPayloadImplementors = []string{"CreateCollectionPayload", "CreateCollectionPayloadOrError"}

func (ec *executionContext) _CreateCollectionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateCollectionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createCollectionPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateCollectionPayload")
		case "collection":

			out.Values[i] = ec._CreateCollectionPayload_collection(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createSplitPayloadImplementors = []string{"CreateSplitPayload", "CreateSplitPayloadOrError"}

func (ec *executionContext) _CreateSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createSplitPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateSplitPayload")
		case "split":

			out.Values[i] = ec._CreateSplitPayload_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createUserPayloadImplementors = []string{"CreateUserPayload", "CreateUserPayloadOrError"}

func (ec *executionContext) _CreateUserPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateUserPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createUserPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateUserPayload")
		case "userId":

			out.Values[i] = ec._CreateUserPayload_userId(ctx, field, obj)

		case "splitId":

			out.Values[i] = ec._CreateUserPayload_splitId(ctx, field, obj)

		case "viewer":

			out.Values[i] = ec._CreateUserPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deepRefreshPayloadImplementors = []string{"DeepRefreshPayload", "DeepRefreshPayloadOrError"}

func (ec *executionContext) _DeepRefreshPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeepRefreshPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deepRefreshPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeepRefreshPayload")
		case "chain":

			out.Values[i] = ec._DeepRefreshPayload_chain(ctx, field, obj)

		case "submitted":

			out.Values[i] = ec._DeepRefreshPayload_submitted(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteCollectionPayloadImplementors = []string{"DeleteCollectionPayload", "DeleteCollectionPayloadOrError"}

func (ec *executionContext) _DeleteCollectionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteCollectionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteCollectionPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteCollectionPayload")
		case "split":

			out.Values[i] = ec._DeleteCollectionPayload_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteSplitPayloadImplementors = []string{"DeleteSplitPayload", "DeleteSplitPayloadOrError"}

func (ec *executionContext) _DeleteSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteSplitPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteSplitPayload")
		case "deletedId":

			out.Values[i] = ec._DeleteSplitPayload_deletedId(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deletedNodeImplementors = []string{"DeletedNode", "Node"}

func (ec *executionContext) _DeletedNode(ctx context.Context, sel ast.SelectionSet, obj *model.DeletedNode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deletedNodeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletedNode")
		case "id":

			out.Values[i] = ec._DeletedNode_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbid":

			out.Values[i] = ec._DeletedNode_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var disconnectSocialAccountPayloadImplementors = []string{"DisconnectSocialAccountPayload", "DisconnectSocialAccountPayloadOrError"}

func (ec *executionContext) _DisconnectSocialAccountPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DisconnectSocialAccountPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, disconnectSocialAccountPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DisconnectSocialAccountPayload")
		case "viewer":

			out.Values[i] = ec._DisconnectSocialAccountPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var emailNotificationSettingsImplementors = []string{"EmailNotificationSettings"}

func (ec *executionContext) _EmailNotificationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.EmailNotificationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, emailNotificationSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EmailNotificationSettings")
		case "unsubscribedFromAll":

			out.Values[i] = ec._EmailNotificationSettings_unsubscribedFromAll(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "unsubscribedFromNotifications":

			out.Values[i] = ec._EmailNotificationSettings_unsubscribedFromNotifications(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errAddressOwnedByUserImplementors = []string{"ErrAddressOwnedByUser", "AddUserWalletPayloadOrError", "Error", "AdminAddWalletPayloadOrError"}

func (ec *executionContext) _ErrAddressOwnedByUser(ctx context.Context, sel ast.SelectionSet, obj *model.ErrAddressOwnedByUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errAddressOwnedByUserImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrAddressOwnedByUser")
		case "message":

			out.Values[i] = ec._ErrAddressOwnedByUser_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errAuthenticationFailedImplementors = []string{"ErrAuthenticationFailed", "AddUserWalletPayloadOrError", "Error", "LoginPayloadOrError", "CreateUserPayloadOrError", "FollowUserPayloadOrError", "UnfollowUserPayloadOrError", "ViewSplitPayloadOrError"}

func (ec *executionContext) _ErrAuthenticationFailed(ctx context.Context, sel ast.SelectionSet, obj *model.ErrAuthenticationFailed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errAuthenticationFailedImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrAuthenticationFailed")
		case "message":

			out.Values[i] = ec._ErrAuthenticationFailed_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errCollectionNotFoundImplementors = []string{"ErrCollectionNotFound", "Error", "CollectionByIdOrError", "CollectionTokenByIdOrError", "DeleteCollectionPayloadOrError"}

func (ec *executionContext) _ErrCollectionNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrCollectionNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errCollectionNotFoundImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrCollectionNotFound")
		case "message":

			out.Values[i] = ec._ErrCollectionNotFound_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errCommunityNotFoundImplementors = []string{"ErrCommunityNotFound", "CommunityByAddressOrError", "Error"}

func (ec *executionContext) _ErrCommunityNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrCommunityNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errCommunityNotFoundImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrCommunityNotFound")
		case "message":

			out.Values[i] = ec._ErrCommunityNotFound_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errDoesNotOwnRequiredTokenImplementors = []string{"ErrDoesNotOwnRequiredToken", "GetAuthNoncePayloadOrError", "AuthorizationError", "Error", "LoginPayloadOrError", "CreateUserPayloadOrError"}

func (ec *executionContext) _ErrDoesNotOwnRequiredToken(ctx context.Context, sel ast.SelectionSet, obj *model.ErrDoesNotOwnRequiredToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errDoesNotOwnRequiredTokenImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrDoesNotOwnRequiredToken")
		case "message":

			out.Values[i] = ec._ErrDoesNotOwnRequiredToken_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errInvalidInputImplementors = []string{"ErrInvalidInput", "UserByUsernameOrError", "UserByIdOrError", "UserByAddressOrError", "CollectionByIdOrError", "CommunityByAddressOrError", "SocialConnectionsOrError", "SearchUsersPayloadOrError", "SearchSplitsPayloadOrError", "SearchCommunitiesPayloadOrError", "CreateCollectionPayloadOrError", "DeleteCollectionPayloadOrError", "UpdateCollectionInfoPayloadOrError", "UpdateCollectionTokensPayloadOrError", "UpdateCollectionHiddenPayloadOrError", "UpdateSplitCollectionsPayloadOrError", "UpdateTokenInfoPayloadOrError", "AddUserWalletPayloadOrError", "RemoveUserWalletsPayloadOrError", "UpdateUserInfoPayloadOrError", "RefreshTokenPayloadOrError", "RefreshCollectionPayloadOrError", "RefreshContractPayloadOrError", "Error", "CreateUserPayloadOrError", "FollowUserPayloadOrError", "UnfollowUserPayloadOrError", "VerifyEmailPayloadOrError", "PreverifyEmailPayloadOrError", "UpdateEmailPayloadOrError", "ResendVerificationEmailPayloadOrError", "UpdateEmailNotificationSettingsPayloadOrError", "UnsubscribeFromEmailTypePayloadOrError", "CreateSplitPayloadOrError", "UpdateSplitInfoPayloadOrError", "UpdateSplitHiddenPayloadOrError", "DeleteSplitPayloadOrError", "UpdateSplitOrderPayloadOrError", "UpdateFeaturedSplitPayloadOrError", "UpdateSplitPayloadOrError", "PublishSplitPayloadOrError", "UpdatePrimaryWalletPayloadOrError", "UpdateUserExperiencePayloadOrError", "MoveCollectionToSplitPayloadOrError", "ConnectSocialAccountPayloadOrError", "UpdateSocialAccountDisplayedPayloadOrError", "MintPremiumCardToWalletPayloadOrError", "DisconnectSocialAccountPayloadOrError", "FollowAllSocialConnectionsPayloadOrError"}

func (ec *executionContext) _ErrInvalidInput(ctx context.Context, sel ast.SelectionSet, obj *model.ErrInvalidInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errInvalidInputImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrInvalidInput")
		case "message":

			out.Values[i] = ec._ErrInvalidInput_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "parameters":

			out.Values[i] = ec._ErrInvalidInput_parameters(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "reasons":

			out.Values[i] = ec._ErrInvalidInput_reasons(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errInvalidTokenImplementors = []string{"ErrInvalidToken", "AuthorizationError", "Error"}

func (ec *executionContext) _ErrInvalidToken(ctx context.Context, sel ast.SelectionSet, obj *model.ErrInvalidToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errInvalidTokenImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrInvalidToken")
		case "message":

			out.Values[i] = ec._ErrInvalidToken_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errNeedsToReconnectSocialImplementors = []string{"ErrNeedsToReconnectSocial", "SocialQueriesOrError", "Error", "UpdateSocialAccountDisplayedPayloadOrError", "MintPremiumCardToWalletPayloadOrError", "DisconnectSocialAccountPayloadOrError", "FollowAllSocialConnectionsPayloadOrError"}

func (ec *executionContext) _ErrNeedsToReconnectSocial(ctx context.Context, sel ast.SelectionSet, obj *model.ErrNeedsToReconnectSocial) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errNeedsToReconnectSocialImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrNeedsToReconnectSocial")
		case "socialAccountType":

			out.Values[i] = ec._ErrNeedsToReconnectSocial_socialAccountType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "message":

			out.Values[i] = ec._ErrNeedsToReconnectSocial_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errNoCookieImplementors = []string{"ErrNoCookie", "AuthorizationError", "Error"}

func (ec *executionContext) _ErrNoCookie(ctx context.Context, sel ast.SelectionSet, obj *model.ErrNoCookie) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errNoCookieImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrNoCookie")
		case "message":

			out.Values[i] = ec._ErrNoCookie_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errNotAuthorizedImplementors = []string{"ErrNotAuthorized", "ViewerOrError", "SocialQueriesOrError", "CreateCollectionPayloadOrError", "DeleteCollectionPayloadOrError", "UpdateCollectionInfoPayloadOrError", "UpdateCollectionTokensPayloadOrError", "UpdateCollectionHiddenPayloadOrError", "UpdateSplitCollectionsPayloadOrError", "UpdateTokenInfoPayloadOrError", "SetSpamPreferencePayloadOrError", "AddUserWalletPayloadOrError", "RemoveUserWalletsPayloadOrError", "UpdateUserInfoPayloadOrError", "SyncTokensPayloadOrError", "Error", "DeepRefreshPayloadOrError", "AddRolesToUserPayloadOrError", "RevokeRolesFromUserPayloadOrError", "UploadPersistedQueriesPayloadOrError", "SyncTokensForUsernamePayloadOrError", "CreateSplitPayloadOrError", "UpdateSplitInfoPayloadOrError", "UpdateSplitHiddenPayloadOrError", "DeleteSplitPayloadOrError", "UpdateSplitOrderPayloadOrError", "UpdateFeaturedSplitPayloadOrError", "UpdateSplitPayloadOrError", "PublishSplitPayloadOrError", "UpdatePrimaryWalletPayloadOrError", "AdminAddWalletPayloadOrError", "UpdateUserExperiencePayloadOrError", "MoveCollectionToSplitPayloadOrError", "ConnectSocialAccountPayloadOrError", "UpdateSocialAccountDisplayedPayloadOrError", "MintPremiumCardToWalletPayloadOrError", "DisconnectSocialAccountPayloadOrError", "FollowAllSocialConnectionsPayloadOrError"}

func (ec *executionContext) _ErrNotAuthorized(ctx context.Context, sel ast.SelectionSet, obj *model.ErrNotAuthorized) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errNotAuthorizedImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrNotAuthorized")
		case "message":

			out.Values[i] = ec._ErrNotAuthorized_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cause":

			out.Values[i] = ec._ErrNotAuthorized_cause(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errSplitNotFoundImplementors = []string{"ErrSplitNotFound", "Error", "SplitByIdPayloadOrError", "ViewerSplitByIdPayloadOrError"}

func (ec *executionContext) _ErrSplitNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrSplitNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errSplitNotFoundImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrSplitNotFound")
		case "message":

			out.Values[i] = ec._ErrSplitNotFound_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errSyncFailedImplementors = []string{"ErrSyncFailed", "SyncTokensPayloadOrError", "RefreshTokenPayloadOrError", "RefreshCollectionPayloadOrError", "RefreshContractPayloadOrError", "Error", "SyncTokensForUsernamePayloadOrError"}

func (ec *executionContext) _ErrSyncFailed(ctx context.Context, sel ast.SelectionSet, obj *model.ErrSyncFailed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errSyncFailedImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrSyncFailed")
		case "message":

			out.Values[i] = ec._ErrSyncFailed_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errTokenNotFoundImplementors = []string{"ErrTokenNotFound", "TokenByIdOrError", "Error", "CollectionTokenByIdOrError"}

func (ec *executionContext) _ErrTokenNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrTokenNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errTokenNotFoundImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrTokenNotFound")
		case "message":

			out.Values[i] = ec._ErrTokenNotFound_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errUserAlreadyExistsImplementors = []string{"ErrUserAlreadyExists", "Error", "CreateUserPayloadOrError"}

func (ec *executionContext) _ErrUserAlreadyExists(ctx context.Context, sel ast.SelectionSet, obj *model.ErrUserAlreadyExists) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errUserAlreadyExistsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrUserAlreadyExists")
		case "message":

			out.Values[i] = ec._ErrUserAlreadyExists_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errUserNotFoundImplementors = []string{"ErrUserNotFound", "UserByUsernameOrError", "UserByIdOrError", "UserByAddressOrError", "Error", "LoginPayloadOrError", "FollowUserPayloadOrError", "UnfollowUserPayloadOrError", "AdminAddWalletPayloadOrError"}

func (ec *executionContext) _ErrUserNotFound(ctx context.Context, sel ast.SelectionSet, obj *model.ErrUserNotFound) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errUserNotFoundImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrUserNotFound")
		case "message":

			out.Values[i] = ec._ErrUserNotFound_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var errUsernameNotAvailableImplementors = []string{"ErrUsernameNotAvailable", "UpdateUserInfoPayloadOrError", "Error", "CreateUserPayloadOrError"}

func (ec *executionContext) _ErrUsernameNotAvailable(ctx context.Context, sel ast.SelectionSet, obj *model.ErrUsernameNotAvailable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, errUsernameNotAvailableImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ErrUsernameNotAvailable")
		case "message":

			out.Values[i] = ec._ErrUsernameNotAvailable_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var followAllSocialConnectionsPayloadImplementors = []string{"FollowAllSocialConnectionsPayload", "FollowAllSocialConnectionsPayloadOrError"}

func (ec *executionContext) _FollowAllSocialConnectionsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.FollowAllSocialConnectionsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, followAllSocialConnectionsPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FollowAllSocialConnectionsPayload")
		case "viewer":

			out.Values[i] = ec._FollowAllSocialConnectionsPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var followInfoImplementors = []string{"FollowInfo"}

func (ec *executionContext) _FollowInfo(ctx context.Context, sel ast.SelectionSet, obj *model.FollowInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, followInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FollowInfo")
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FollowInfo_user(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "followedBack":

			out.Values[i] = ec._FollowInfo_followedBack(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var followUserPayloadImplementors = []string{"FollowUserPayload", "FollowUserPayloadOrError"}

func (ec *executionContext) _FollowUserPayload(ctx context.Context, sel ast.SelectionSet, obj *model.FollowUserPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, followUserPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FollowUserPayload")
		case "viewer":

			out.Values[i] = ec._FollowUserPayload_viewer(ctx, field, obj)

		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FollowUserPayload_user(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gIFMediaImplementors = []string{"GIFMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _GIFMedia(ctx context.Context, sel ast.SelectionSet, obj *model.GIFMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gIFMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GIFMedia")
		case "previewURLs":

			out.Values[i] = ec._GIFMedia_previewURLs(ctx, field, obj)

		case "staticPreviewURLs":

			out.Values[i] = ec._GIFMedia_staticPreviewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._GIFMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._GIFMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._GIFMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._GIFMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gltfMediaImplementors = []string{"GltfMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _GltfMedia(ctx context.Context, sel ast.SelectionSet, obj *model.GltfMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gltfMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GltfMedia")
		case "previewURLs":

			out.Values[i] = ec._GltfMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._GltfMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._GltfMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._GltfMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._GltfMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupNotificationUserEdgeImplementors = []string{"GroupNotificationUserEdge"}

func (ec *executionContext) _GroupNotificationUserEdge(ctx context.Context, sel ast.SelectionSet, obj *model.GroupNotificationUserEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupNotificationUserEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupNotificationUserEdge")
		case "node":

			out.Values[i] = ec._GroupNotificationUserEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._GroupNotificationUserEdge_cursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupNotificationUsersConnectionImplementors = []string{"GroupNotificationUsersConnection"}

func (ec *executionContext) _GroupNotificationUsersConnection(ctx context.Context, sel ast.SelectionSet, obj *model.GroupNotificationUsersConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupNotificationUsersConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupNotificationUsersConnection")
		case "edges":

			out.Values[i] = ec._GroupNotificationUsersConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._GroupNotificationUsersConnection_pageInfo(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var htmlMediaImplementors = []string{"HtmlMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _HtmlMedia(ctx context.Context, sel ast.SelectionSet, obj *model.HTMLMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, htmlMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HtmlMedia")
		case "previewURLs":

			out.Values[i] = ec._HtmlMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._HtmlMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._HtmlMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._HtmlMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._HtmlMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var imageMediaImplementors = []string{"ImageMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _ImageMedia(ctx context.Context, sel ast.SelectionSet, obj *model.ImageMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageMedia")
		case "previewURLs":

			out.Values[i] = ec._ImageMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._ImageMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._ImageMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._ImageMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._ImageMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var invalidMediaImplementors = []string{"InvalidMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _InvalidMedia(ctx context.Context, sel ast.SelectionSet, obj *model.InvalidMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invalidMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvalidMedia")
		case "previewURLs":

			out.Values[i] = ec._InvalidMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._InvalidMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._InvalidMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._InvalidMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._InvalidMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var jsonMediaImplementors = []string{"JsonMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _JsonMedia(ctx context.Context, sel ast.SelectionSet, obj *model.JSONMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jsonMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JsonMedia")
		case "previewURLs":

			out.Values[i] = ec._JsonMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._JsonMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._JsonMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._JsonMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._JsonMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loginPayloadImplementors = []string{"LoginPayload", "LoginPayloadOrError"}

func (ec *executionContext) _LoginPayload(ctx context.Context, sel ast.SelectionSet, obj *model.LoginPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loginPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoginPayload")
		case "userId":

			out.Values[i] = ec._LoginPayload_userId(ctx, field, obj)

		case "viewer":

			out.Values[i] = ec._LoginPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var logoutPayloadImplementors = []string{"LogoutPayload"}

func (ec *executionContext) _LogoutPayload(ctx context.Context, sel ast.SelectionSet, obj *model.LogoutPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logoutPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogoutPayload")
		case "viewer":

			out.Values[i] = ec._LogoutPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mediaDimensionsImplementors = []string{"MediaDimensions"}

func (ec *executionContext) _MediaDimensions(ctx context.Context, sel ast.SelectionSet, obj *model.MediaDimensions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mediaDimensionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MediaDimensions")
		case "width":

			out.Values[i] = ec._MediaDimensions_width(ctx, field, obj)

		case "height":

			out.Values[i] = ec._MediaDimensions_height(ctx, field, obj)

		case "aspectRatio":

			out.Values[i] = ec._MediaDimensions_aspectRatio(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var membershipTierImplementors = []string{"MembershipTier", "Node"}

func (ec *executionContext) _MembershipTier(ctx context.Context, sel ast.SelectionSet, obj *model.MembershipTier) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, membershipTierImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MembershipTier")
		case "id":

			out.Values[i] = ec._MembershipTier_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dbid":

			out.Values[i] = ec._MembershipTier_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._MembershipTier_name(ctx, field, obj)

		case "assetUrl":

			out.Values[i] = ec._MembershipTier_assetUrl(ctx, field, obj)

		case "tokenId":

			out.Values[i] = ec._MembershipTier_tokenId(ctx, field, obj)

		case "owners":

			out.Values[i] = ec._MembershipTier_owners(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mintPremiumCardToWalletPayloadImplementors = []string{"MintPremiumCardToWalletPayload", "MintPremiumCardToWalletPayloadOrError"}

func (ec *executionContext) _MintPremiumCardToWalletPayload(ctx context.Context, sel ast.SelectionSet, obj *model.MintPremiumCardToWalletPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mintPremiumCardToWalletPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MintPremiumCardToWalletPayload")
		case "tx":

			out.Values[i] = ec._MintPremiumCardToWalletPayload_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var moveCollectionToSplitPayloadImplementors = []string{"MoveCollectionToSplitPayload", "MoveCollectionToSplitPayloadOrError"}

func (ec *executionContext) _MoveCollectionToSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.MoveCollectionToSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, moveCollectionToSplitPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MoveCollectionToSplitPayload")
		case "oldSplit":

			out.Values[i] = ec._MoveCollectionToSplitPayload_oldSplit(ctx, field, obj)

		case "newSplit":

			out.Values[i] = ec._MoveCollectionToSplitPayload_newSplit(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "addUserWallet":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addUserWallet(ctx, field)
			})

		case "removeUserWallets":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeUserWallets(ctx, field)
			})

		case "updateUserInfo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserInfo(ctx, field)
			})

		case "updateSplitCollections":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplitCollections(ctx, field)
			})

		case "createCollection":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCollection(ctx, field)
			})

		case "deleteCollection":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCollection(ctx, field)
			})

		case "updateCollectionInfo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCollectionInfo(ctx, field)
			})

		case "updateCollectionTokens":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCollectionTokens(ctx, field)
			})

		case "updateCollectionHidden":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCollectionHidden(ctx, field)
			})

		case "updateTokenInfo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTokenInfo(ctx, field)
			})

		case "setSpamPreference":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setSpamPreference(ctx, field)
			})

		case "syncTokens":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_syncTokens(ctx, field)
			})

		case "refreshToken":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshToken(ctx, field)
			})

		case "refreshCollection":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshCollection(ctx, field)
			})

		case "refreshContract":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshContract(ctx, field)
			})

		case "deepRefresh":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deepRefresh(ctx, field)
			})

		case "getAuthNonce":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_getAuthNonce(ctx, field)
			})

		case "createUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})

		case "updateEmail":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEmail(ctx, field)
			})

		case "resendVerificationEmail":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resendVerificationEmail(ctx, field)
			})

		case "updateEmailNotificationSettings":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEmailNotificationSettings(ctx, field)
			})

		case "unsubscribeFromEmailType":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unsubscribeFromEmailType(ctx, field)
			})

		case "login":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_login(ctx, field)
			})

		case "logout":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_logout(ctx, field)
			})

		case "connectSocialAccount":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_connectSocialAccount(ctx, field)
			})

		case "disconnectSocialAccount":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_disconnectSocialAccount(ctx, field)
			})

		case "updateSocialAccountDisplayed":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSocialAccountDisplayed(ctx, field)
			})

		case "followUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_followUser(ctx, field)
			})

		case "followAllSocialConnections":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_followAllSocialConnections(ctx, field)
			})

		case "unfollowUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unfollowUser(ctx, field)
			})

		case "viewSplit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_viewSplit(ctx, field)
			})

		case "updateSplit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplit(ctx, field)
			})

		case "publishSplit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_publishSplit(ctx, field)
			})

		case "createSplit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSplit(ctx, field)
			})

		case "updateSplitHidden":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplitHidden(ctx, field)
			})

		case "deleteSplit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSplit(ctx, field)
			})

		case "updateSplitOrder":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplitOrder(ctx, field)
			})

		case "updateSplitInfo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSplitInfo(ctx, field)
			})

		case "updateFeaturedSplit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFeaturedSplit(ctx, field)
			})

		case "clearAllNotifications":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_clearAllNotifications(ctx, field)
			})

		case "updateNotificationSettings":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateNotificationSettings(ctx, field)
			})

		case "preverifyEmail":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_preverifyEmail(ctx, field)
			})

		case "verifyEmail":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_verifyEmail(ctx, field)
			})

		case "addRolesToUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addRolesToUser(ctx, field)
			})

		case "addWalletToUserUnchecked":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addWalletToUserUnchecked(ctx, field)
			})

		case "revokeRolesFromUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_revokeRolesFromUser(ctx, field)
			})

		case "syncTokensForUsername":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_syncTokensForUsername(ctx, field)
			})

		case "mintPremiumCardToWallet":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_mintPremiumCardToWallet(ctx, field)
			})

		case "uploadPersistedQueries":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_uploadPersistedQueries(ctx, field)
			})

		case "updatePrimaryWallet":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePrimaryWallet(ctx, field)
			})

		case "updateUserExperience":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserExperience(ctx, field)
			})

		case "moveCollectionToSplit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_moveCollectionToSplit(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var notificationEdgeImplementors = []string{"NotificationEdge"}

func (ec *executionContext) _NotificationEdge(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationEdge")
		case "node":

			out.Values[i] = ec._NotificationEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._NotificationEdge_cursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var notificationSettingsImplementors = []string{"NotificationSettings"}

func (ec *executionContext) _NotificationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationSettings")
		case "someoneFollowedYou":

			out.Values[i] = ec._NotificationSettings_someoneFollowedYou(ctx, field, obj)

		case "someoneViewedYourSplit":

			out.Values[i] = ec._NotificationSettings_someoneViewedYourSplit(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var notificationsConnectionImplementors = []string{"NotificationsConnection"}

func (ec *executionContext) _NotificationsConnection(ctx context.Context, sel ast.SelectionSet, obj *model.NotificationsConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationsConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotificationsConnection")
		case "edges":

			out.Values[i] = ec._NotificationsConnection_edges(ctx, field, obj)

		case "unseenCount":

			out.Values[i] = ec._NotificationsConnection_unseenCount(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._NotificationsConnection_pageInfo(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ownerAtBlockImplementors = []string{"OwnerAtBlock"}

func (ec *executionContext) _OwnerAtBlock(ctx context.Context, sel ast.SelectionSet, obj *model.OwnerAtBlock) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ownerAtBlockImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OwnerAtBlock")
		case "owner":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OwnerAtBlock_owner(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "blockNumber":

			out.Values[i] = ec._OwnerAtBlock_blockNumber(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "total":

			out.Values[i] = ec._PageInfo_total(ctx, field, obj)

		case "size":

			out.Values[i] = ec._PageInfo_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pdfMediaImplementors = []string{"PdfMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _PdfMedia(ctx context.Context, sel ast.SelectionSet, obj *model.PDFMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pdfMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PdfMedia")
		case "previewURLs":

			out.Values[i] = ec._PdfMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._PdfMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._PdfMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._PdfMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._PdfMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var preverifyEmailPayloadImplementors = []string{"PreverifyEmailPayload", "PreverifyEmailPayloadOrError"}

func (ec *executionContext) _PreverifyEmailPayload(ctx context.Context, sel ast.SelectionSet, obj *model.PreverifyEmailPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preverifyEmailPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreverifyEmailPayload")
		case "email":

			out.Values[i] = ec._PreverifyEmailPayload_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "result":

			out.Values[i] = ec._PreverifyEmailPayload_result(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var previewURLSetImplementors = []string{"PreviewURLSet"}

func (ec *executionContext) _PreviewURLSet(ctx context.Context, sel ast.SelectionSet, obj *model.PreviewURLSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, previewURLSetImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreviewURLSet")
		case "raw":

			out.Values[i] = ec._PreviewURLSet_raw(ctx, field, obj)

		case "thumbnail":

			out.Values[i] = ec._PreviewURLSet_thumbnail(ctx, field, obj)

		case "small":

			out.Values[i] = ec._PreviewURLSet_small(ctx, field, obj)

		case "medium":

			out.Values[i] = ec._PreviewURLSet_medium(ctx, field, obj)

		case "large":

			out.Values[i] = ec._PreviewURLSet_large(ctx, field, obj)

		case "srcSet":

			out.Values[i] = ec._PreviewURLSet_srcSet(ctx, field, obj)

		case "liveRender":

			out.Values[i] = ec._PreviewURLSet_liveRender(ctx, field, obj)

		case "blurhash":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PreviewURLSet_blurhash(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var publishSplitPayloadImplementors = []string{"PublishSplitPayload", "PublishSplitPayloadOrError"}

func (ec *executionContext) _PublishSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.PublishSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publishSplitPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublishSplitPayload")
		case "split":

			out.Values[i] = ec._PublishSplitPayload_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "viewer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewer(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userByUsername":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userByUsername(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userById":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userByAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userByAddress(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "usersWithTrait":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_usersWithTrait(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "membershipTiers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_membershipTiers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "collectionById":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_collectionById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "collectionsByIds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_collectionsByIds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "tokenById":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tokenById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "collectionTokenById":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_collectionTokenById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "communityByAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_communityByAddress(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "generalAllowlist":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_generalAllowlist(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "splitById":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_splitById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "viewerSplitById":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewerSplitById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "searchUsers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchUsers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "searchSplits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchSplits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "searchCommunities":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchCommunities(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "usersByRole":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_usersByRole(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "socialConnections":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_socialConnections(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "socialQueries":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_socialQueries(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "_service":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__service(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var refreshCollectionPayloadImplementors = []string{"RefreshCollectionPayload", "RefreshCollectionPayloadOrError"}

func (ec *executionContext) _RefreshCollectionPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RefreshCollectionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refreshCollectionPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RefreshCollectionPayload")
		case "collection":

			out.Values[i] = ec._RefreshCollectionPayload_collection(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var refreshContractPayloadImplementors = []string{"RefreshContractPayload", "RefreshContractPayloadOrError"}

func (ec *executionContext) _RefreshContractPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RefreshContractPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refreshContractPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RefreshContractPayload")
		case "contract":

			out.Values[i] = ec._RefreshContractPayload_contract(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var refreshTokenPayloadImplementors = []string{"RefreshTokenPayload", "RefreshTokenPayloadOrError"}

func (ec *executionContext) _RefreshTokenPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RefreshTokenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refreshTokenPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RefreshTokenPayload")
		case "token":

			out.Values[i] = ec._RefreshTokenPayload_token(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var removeUserWalletsPayloadImplementors = []string{"RemoveUserWalletsPayload", "RemoveUserWalletsPayloadOrError"}

func (ec *executionContext) _RemoveUserWalletsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.RemoveUserWalletsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, removeUserWalletsPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RemoveUserWalletsPayload")
		case "viewer":

			out.Values[i] = ec._RemoveUserWalletsPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resendVerificationEmailPayloadImplementors = []string{"ResendVerificationEmailPayload", "ResendVerificationEmailPayloadOrError"}

func (ec *executionContext) _ResendVerificationEmailPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ResendVerificationEmailPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resendVerificationEmailPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResendVerificationEmailPayload")
		case "viewer":

			out.Values[i] = ec._ResendVerificationEmailPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var searchCommunitiesPayloadImplementors = []string{"SearchCommunitiesPayload", "SearchCommunitiesPayloadOrError"}

func (ec *executionContext) _SearchCommunitiesPayload(ctx context.Context, sel ast.SelectionSet, obj *model.SearchCommunitiesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchCommunitiesPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchCommunitiesPayload")
		case "results":

			out.Values[i] = ec._SearchCommunitiesPayload_results(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var searchSplitsPayloadImplementors = []string{"SearchSplitsPayload", "SearchSplitsPayloadOrError"}

func (ec *executionContext) _SearchSplitsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.SearchSplitsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchSplitsPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchSplitsPayload")
		case "results":

			out.Values[i] = ec._SearchSplitsPayload_results(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var searchUsersPayloadImplementors = []string{"SearchUsersPayload", "SearchUsersPayloadOrError"}

func (ec *executionContext) _SearchUsersPayload(ctx context.Context, sel ast.SelectionSet, obj *model.SearchUsersPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchUsersPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchUsersPayload")
		case "results":

			out.Values[i] = ec._SearchUsersPayload_results(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var setSpamPreferencePayloadImplementors = []string{"SetSpamPreferencePayload", "SetSpamPreferencePayloadOrError"}

func (ec *executionContext) _SetSpamPreferencePayload(ctx context.Context, sel ast.SelectionSet, obj *model.SetSpamPreferencePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setSpamPreferencePayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetSpamPreferencePayload")
		case "tokens":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SetSpamPreferencePayload_tokens(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var socialAccountsImplementors = []string{"SocialAccounts"}

func (ec *executionContext) _SocialAccounts(ctx context.Context, sel ast.SelectionSet, obj *model.SocialAccounts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, socialAccountsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SocialAccounts")
		case "twitter":

			out.Values[i] = ec._SocialAccounts_twitter(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var socialConnectionImplementors = []string{"SocialConnection", "Node", "SocialConnectionsOrError"}

func (ec *executionContext) _SocialConnection(ctx context.Context, sel ast.SelectionSet, obj *model.SocialConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, socialConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SocialConnection")
		case "id":

			out.Values[i] = ec._SocialConnection_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "splitFiUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SocialConnection_splitFiUser(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "currentlyFollowing":

			out.Values[i] = ec._SocialConnection_currentlyFollowing(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "socialId":

			out.Values[i] = ec._SocialConnection_socialId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "socialType":

			out.Values[i] = ec._SocialConnection_socialType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "displayName":

			out.Values[i] = ec._SocialConnection_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "socialUsername":

			out.Values[i] = ec._SocialConnection_socialUsername(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "profileImage":

			out.Values[i] = ec._SocialConnection_profileImage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var socialConnectionsConnectionImplementors = []string{"SocialConnectionsConnection"}

func (ec *executionContext) _SocialConnectionsConnection(ctx context.Context, sel ast.SelectionSet, obj *model.SocialConnectionsConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, socialConnectionsConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SocialConnectionsConnection")
		case "edges":

			out.Values[i] = ec._SocialConnectionsConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._SocialConnectionsConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var socialConnectionsEdgeImplementors = []string{"SocialConnectionsEdge"}

func (ec *executionContext) _SocialConnectionsEdge(ctx context.Context, sel ast.SelectionSet, obj *model.SocialConnectionsEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, socialConnectionsEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SocialConnectionsEdge")
		case "node":

			out.Values[i] = ec._SocialConnectionsEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._SocialConnectionsEdge_cursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var socialQueriesImplementors = []string{"SocialQueries", "SocialQueriesOrError"}

func (ec *executionContext) _SocialQueries(ctx context.Context, sel ast.SelectionSet, obj *model.SocialQueries) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, socialQueriesImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SocialQueries")
		case "socialConnections":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SocialQueries_socialConnections(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var someoneFollowedYouBackNotificationImplementors = []string{"SomeoneFollowedYouBackNotification", "Notification", "Node", "GroupedNotification"}

func (ec *executionContext) _SomeoneFollowedYouBackNotification(ctx context.Context, sel ast.SelectionSet, obj *model.SomeoneFollowedYouBackNotification) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, someoneFollowedYouBackNotificationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SomeoneFollowedYouBackNotification")
		case "id":

			out.Values[i] = ec._SomeoneFollowedYouBackNotification_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dbid":

			out.Values[i] = ec._SomeoneFollowedYouBackNotification_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "seen":

			out.Values[i] = ec._SomeoneFollowedYouBackNotification_seen(ctx, field, obj)

		case "creationTime":

			out.Values[i] = ec._SomeoneFollowedYouBackNotification_creationTime(ctx, field, obj)

		case "updatedTime":

			out.Values[i] = ec._SomeoneFollowedYouBackNotification_updatedTime(ctx, field, obj)

		case "count":

			out.Values[i] = ec._SomeoneFollowedYouBackNotification_count(ctx, field, obj)

		case "followers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SomeoneFollowedYouBackNotification_followers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var someoneFollowedYouNotificationImplementors = []string{"SomeoneFollowedYouNotification", "Notification", "Node", "GroupedNotification"}

func (ec *executionContext) _SomeoneFollowedYouNotification(ctx context.Context, sel ast.SelectionSet, obj *model.SomeoneFollowedYouNotification) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, someoneFollowedYouNotificationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SomeoneFollowedYouNotification")
		case "id":

			out.Values[i] = ec._SomeoneFollowedYouNotification_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dbid":

			out.Values[i] = ec._SomeoneFollowedYouNotification_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "seen":

			out.Values[i] = ec._SomeoneFollowedYouNotification_seen(ctx, field, obj)

		case "creationTime":

			out.Values[i] = ec._SomeoneFollowedYouNotification_creationTime(ctx, field, obj)

		case "updatedTime":

			out.Values[i] = ec._SomeoneFollowedYouNotification_updatedTime(ctx, field, obj)

		case "count":

			out.Values[i] = ec._SomeoneFollowedYouNotification_count(ctx, field, obj)

		case "followers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SomeoneFollowedYouNotification_followers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var someoneViewedYourSplitNotificationImplementors = []string{"SomeoneViewedYourSplitNotification", "Notification", "Node", "GroupedNotification"}

func (ec *executionContext) _SomeoneViewedYourSplitNotification(ctx context.Context, sel ast.SelectionSet, obj *model.SomeoneViewedYourSplitNotification) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, someoneViewedYourSplitNotificationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SomeoneViewedYourSplitNotification")
		case "id":

			out.Values[i] = ec._SomeoneViewedYourSplitNotification_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dbid":

			out.Values[i] = ec._SomeoneViewedYourSplitNotification_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "seen":

			out.Values[i] = ec._SomeoneViewedYourSplitNotification_seen(ctx, field, obj)

		case "creationTime":

			out.Values[i] = ec._SomeoneViewedYourSplitNotification_creationTime(ctx, field, obj)

		case "updatedTime":

			out.Values[i] = ec._SomeoneViewedYourSplitNotification_updatedTime(ctx, field, obj)

		case "count":

			out.Values[i] = ec._SomeoneViewedYourSplitNotification_count(ctx, field, obj)

		case "userViewers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SomeoneViewedYourSplitNotification_userViewers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "nonUserViewerCount":

			out.Values[i] = ec._SomeoneViewedYourSplitNotification_nonUserViewerCount(ctx, field, obj)

		case "split":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SomeoneViewedYourSplitNotification_split(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var splitImplementors = []string{"Split", "Node", "SplitByIdPayloadOrError"}

func (ec *executionContext) _Split(ctx context.Context, sel ast.SelectionSet, obj *model.Split) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splitImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Split")
		case "id":

			out.Values[i] = ec._Split_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dbid":

			out.Values[i] = ec._Split_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Split_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec._Split_description(ctx, field, obj)

		case "position":

			out.Values[i] = ec._Split_position(ctx, field, obj)

		case "hidden":

			out.Values[i] = ec._Split_hidden(ctx, field, obj)

		case "tokenPreviews":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Split_tokenPreviews(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "owner":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Split_owner(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "collections":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Split_collections(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var splitFiUserImplementors = []string{"SplitFiUser", "Node", "SplitFiUserOrWallet", "SplitFiUserOrAddress", "UserByUsernameOrError", "UserByIdOrError", "UserByAddressOrError", "AddRolesToUserPayloadOrError", "RevokeRolesFromUserPayloadOrError"}

func (ec *executionContext) _SplitFiUser(ctx context.Context, sel ast.SelectionSet, obj *model.SplitFiUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splitFiUserImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SplitFiUser")
		case "id":

			out.Values[i] = ec._SplitFiUser_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dbid":

			out.Values[i] = ec._SplitFiUser_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "username":

			out.Values[i] = ec._SplitFiUser_username(ctx, field, obj)

		case "bio":

			out.Values[i] = ec._SplitFiUser_bio(ctx, field, obj)

		case "traits":

			out.Values[i] = ec._SplitFiUser_traits(ctx, field, obj)

		case "universal":

			out.Values[i] = ec._SplitFiUser_universal(ctx, field, obj)

		case "roles":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_roles(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "socialAccounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_socialAccounts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tokens":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_tokens(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tokensByChain":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_tokensByChain(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "wallets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_wallets(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "primaryWallet":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_primaryWallet(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "featuredSplit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_featuredSplit(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "splits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_splits(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "badges":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_badges(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "isAuthenticatedUser":

			out.Values[i] = ec._SplitFiUser_isAuthenticatedUser(ctx, field, obj)

		case "followers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_followers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "following":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_following(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "sharedFollowers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_sharedFollowers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "sharedCommunities":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SplitFiUser_sharedCommunities(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var splitSearchResultImplementors = []string{"SplitSearchResult"}

func (ec *executionContext) _SplitSearchResult(ctx context.Context, sel ast.SelectionSet, obj *model.SplitSearchResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splitSearchResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SplitSearchResult")
		case "split":

			out.Values[i] = ec._SplitSearchResult_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "newNotification":
		return ec._Subscription_newNotification(ctx, fields[0])
	case "notificationUpdated":
		return ec._Subscription_notificationUpdated(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var syncTokensForUsernamePayloadImplementors = []string{"SyncTokensForUsernamePayload", "SyncTokensForUsernamePayloadOrError"}

func (ec *executionContext) _SyncTokensForUsernamePayload(ctx context.Context, sel ast.SelectionSet, obj *model.SyncTokensForUsernamePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, syncTokensForUsernamePayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SyncTokensForUsernamePayload")
		case "message":

			out.Values[i] = ec._SyncTokensForUsernamePayload_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var syncTokensPayloadImplementors = []string{"SyncTokensPayload", "SyncTokensPayloadOrError"}

func (ec *executionContext) _SyncTokensPayload(ctx context.Context, sel ast.SelectionSet, obj *model.SyncTokensPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, syncTokensPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SyncTokensPayload")
		case "viewer":

			out.Values[i] = ec._SyncTokensPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var syncingMediaImplementors = []string{"SyncingMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _SyncingMedia(ctx context.Context, sel ast.SelectionSet, obj *model.SyncingMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, syncingMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SyncingMedia")
		case "previewURLs":

			out.Values[i] = ec._SyncingMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._SyncingMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._SyncingMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._SyncingMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._SyncingMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var textMediaImplementors = []string{"TextMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _TextMedia(ctx context.Context, sel ast.SelectionSet, obj *model.TextMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, textMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TextMedia")
		case "previewURLs":

			out.Values[i] = ec._TextMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._TextMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._TextMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._TextMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._TextMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tokenImplementors = []string{"Token", "Node", "TokenByIdOrError"}

func (ec *executionContext) _Token(ctx context.Context, sel ast.SelectionSet, obj *model.Token) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Token")
		case "id":

			out.Values[i] = ec._Token_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dbid":

			out.Values[i] = ec._Token_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creationTime":

			out.Values[i] = ec._Token_creationTime(ctx, field, obj)

		case "lastUpdated":

			out.Values[i] = ec._Token_lastUpdated(ctx, field, obj)

		case "collectorsNote":

			out.Values[i] = ec._Token_collectorsNote(ctx, field, obj)

		case "media":

			out.Values[i] = ec._Token_media(ctx, field, obj)

		case "tokenType":

			out.Values[i] = ec._Token_tokenType(ctx, field, obj)

		case "chain":

			out.Values[i] = ec._Token_chain(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Token_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec._Token_description(ctx, field, obj)

		case "tokenId":

			out.Values[i] = ec._Token_tokenId(ctx, field, obj)

		case "quantity":

			out.Values[i] = ec._Token_quantity(ctx, field, obj)

		case "owner":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Token_owner(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ownedByWallets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Token_ownedByWallets(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ownershipHistory":

			out.Values[i] = ec._Token_ownershipHistory(ctx, field, obj)

		case "tokenMetadata":

			out.Values[i] = ec._Token_tokenMetadata(ctx, field, obj)

		case "contract":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Token_contract(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "externalUrl":

			out.Values[i] = ec._Token_externalUrl(ctx, field, obj)

		case "blockNumber":

			out.Values[i] = ec._Token_blockNumber(ctx, field, obj)

		case "isSpamByUser":

			out.Values[i] = ec._Token_isSpamByUser(ctx, field, obj)

		case "isSpamByProvider":

			out.Values[i] = ec._Token_isSpamByProvider(ctx, field, obj)

		case "creatorAddress":

			out.Values[i] = ec._Token_creatorAddress(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tokenEdgeImplementors = []string{"TokenEdge"}

func (ec *executionContext) _TokenEdge(ctx context.Context, sel ast.SelectionSet, obj *model.TokenEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TokenEdge")
		case "node":

			out.Values[i] = ec._TokenEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._TokenEdge_cursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tokenHolderImplementors = []string{"TokenHolder"}

func (ec *executionContext) _TokenHolder(ctx context.Context, sel ast.SelectionSet, obj *model.TokenHolder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenHolderImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TokenHolder")
		case "displayName":

			out.Values[i] = ec._TokenHolder_displayName(ctx, field, obj)

		case "wallets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TokenHolder_wallets(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TokenHolder_user(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "previewTokens":

			out.Values[i] = ec._TokenHolder_previewTokens(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tokenHolderEdgeImplementors = []string{"TokenHolderEdge"}

func (ec *executionContext) _TokenHolderEdge(ctx context.Context, sel ast.SelectionSet, obj *model.TokenHolderEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenHolderEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TokenHolderEdge")
		case "node":

			out.Values[i] = ec._TokenHolderEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._TokenHolderEdge_cursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tokenHoldersConnectionImplementors = []string{"TokenHoldersConnection"}

func (ec *executionContext) _TokenHoldersConnection(ctx context.Context, sel ast.SelectionSet, obj *model.TokenHoldersConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokenHoldersConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TokenHoldersConnection")
		case "edges":

			out.Values[i] = ec._TokenHoldersConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._TokenHoldersConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tokensConnectionImplementors = []string{"TokensConnection"}

func (ec *executionContext) _TokensConnection(ctx context.Context, sel ast.SelectionSet, obj *model.TokensConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tokensConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TokensConnection")
		case "edges":

			out.Values[i] = ec._TokensConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._TokensConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var twitterSocialAccountImplementors = []string{"TwitterSocialAccount", "SocialAccount"}

func (ec *executionContext) _TwitterSocialAccount(ctx context.Context, sel ast.SelectionSet, obj *model.TwitterSocialAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, twitterSocialAccountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TwitterSocialAccount")
		case "type":

			out.Values[i] = ec._TwitterSocialAccount_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "social_id":

			out.Values[i] = ec._TwitterSocialAccount_social_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._TwitterSocialAccount_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "username":

			out.Values[i] = ec._TwitterSocialAccount_username(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "profileImageURL":

			out.Values[i] = ec._TwitterSocialAccount_profileImageURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "display":

			out.Values[i] = ec._TwitterSocialAccount_display(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var unfollowUserPayloadImplementors = []string{"UnfollowUserPayload", "UnfollowUserPayloadOrError"}

func (ec *executionContext) _UnfollowUserPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UnfollowUserPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unfollowUserPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnfollowUserPayload")
		case "viewer":

			out.Values[i] = ec._UnfollowUserPayload_viewer(ctx, field, obj)

		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UnfollowUserPayload_user(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var unknownMediaImplementors = []string{"UnknownMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _UnknownMedia(ctx context.Context, sel ast.SelectionSet, obj *model.UnknownMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unknownMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnknownMedia")
		case "previewURLs":

			out.Values[i] = ec._UnknownMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._UnknownMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._UnknownMedia_mediaType(ctx, field, obj)

		case "contentRenderURL":

			out.Values[i] = ec._UnknownMedia_contentRenderURL(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._UnknownMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var unsubscribeFromEmailTypePayloadImplementors = []string{"UnsubscribeFromEmailTypePayload", "UnsubscribeFromEmailTypePayloadOrError"}

func (ec *executionContext) _UnsubscribeFromEmailTypePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UnsubscribeFromEmailTypePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unsubscribeFromEmailTypePayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnsubscribeFromEmailTypePayload")
		case "viewer":

			out.Values[i] = ec._UnsubscribeFromEmailTypePayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateCollectionHiddenPayloadImplementors = []string{"UpdateCollectionHiddenPayload", "UpdateCollectionHiddenPayloadOrError"}

func (ec *executionContext) _UpdateCollectionHiddenPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateCollectionHiddenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateCollectionHiddenPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateCollectionHiddenPayload")
		case "collection":

			out.Values[i] = ec._UpdateCollectionHiddenPayload_collection(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateCollectionInfoPayloadImplementors = []string{"UpdateCollectionInfoPayload", "UpdateCollectionInfoPayloadOrError"}

func (ec *executionContext) _UpdateCollectionInfoPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateCollectionInfoPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateCollectionInfoPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateCollectionInfoPayload")
		case "collection":

			out.Values[i] = ec._UpdateCollectionInfoPayload_collection(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateCollectionTokensPayloadImplementors = []string{"UpdateCollectionTokensPayload", "UpdateCollectionTokensPayloadOrError"}

func (ec *executionContext) _UpdateCollectionTokensPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateCollectionTokensPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateCollectionTokensPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateCollectionTokensPayload")
		case "collection":

			out.Values[i] = ec._UpdateCollectionTokensPayload_collection(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateEmailNotificationSettingsPayloadImplementors = []string{"UpdateEmailNotificationSettingsPayload", "UpdateEmailNotificationSettingsPayloadOrError"}

func (ec *executionContext) _UpdateEmailNotificationSettingsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateEmailNotificationSettingsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEmailNotificationSettingsPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEmailNotificationSettingsPayload")
		case "viewer":

			out.Values[i] = ec._UpdateEmailNotificationSettingsPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateEmailPayloadImplementors = []string{"UpdateEmailPayload", "UpdateEmailPayloadOrError"}

func (ec *executionContext) _UpdateEmailPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateEmailPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateEmailPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateEmailPayload")
		case "viewer":

			out.Values[i] = ec._UpdateEmailPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateFeaturedSplitPayloadImplementors = []string{"UpdateFeaturedSplitPayload", "UpdateFeaturedSplitPayloadOrError"}

func (ec *executionContext) _UpdateFeaturedSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateFeaturedSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateFeaturedSplitPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateFeaturedSplitPayload")
		case "viewer":

			out.Values[i] = ec._UpdateFeaturedSplitPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updatePrimaryWalletPayloadImplementors = []string{"UpdatePrimaryWalletPayload", "UpdatePrimaryWalletPayloadOrError"}

func (ec *executionContext) _UpdatePrimaryWalletPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdatePrimaryWalletPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updatePrimaryWalletPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdatePrimaryWalletPayload")
		case "viewer":

			out.Values[i] = ec._UpdatePrimaryWalletPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateSocialAccountDisplayedPayloadImplementors = []string{"UpdateSocialAccountDisplayedPayload", "UpdateSocialAccountDisplayedPayloadOrError"}

func (ec *executionContext) _UpdateSocialAccountDisplayedPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSocialAccountDisplayedPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSocialAccountDisplayedPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSocialAccountDisplayedPayload")
		case "viewer":

			out.Values[i] = ec._UpdateSocialAccountDisplayedPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateSplitCollectionsPayloadImplementors = []string{"UpdateSplitCollectionsPayload", "UpdateSplitCollectionsPayloadOrError"}

func (ec *executionContext) _UpdateSplitCollectionsPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitCollectionsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitCollectionsPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitCollectionsPayload")
		case "split":

			out.Values[i] = ec._UpdateSplitCollectionsPayload_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateSplitHiddenPayloadImplementors = []string{"UpdateSplitHiddenPayload", "UpdateSplitHiddenPayloadOrError"}

func (ec *executionContext) _UpdateSplitHiddenPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitHiddenPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitHiddenPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitHiddenPayload")
		case "split":

			out.Values[i] = ec._UpdateSplitHiddenPayload_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateSplitInfoPayloadImplementors = []string{"UpdateSplitInfoPayload", "UpdateSplitInfoPayloadOrError"}

func (ec *executionContext) _UpdateSplitInfoPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitInfoPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitInfoPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitInfoPayload")
		case "split":

			out.Values[i] = ec._UpdateSplitInfoPayload_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateSplitOrderPayloadImplementors = []string{"UpdateSplitOrderPayload", "UpdateSplitOrderPayloadOrError"}

func (ec *executionContext) _UpdateSplitOrderPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitOrderPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitOrderPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitOrderPayload")
		case "viewer":

			out.Values[i] = ec._UpdateSplitOrderPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateSplitPayloadImplementors = []string{"UpdateSplitPayload", "UpdateSplitPayloadOrError"}

func (ec *executionContext) _UpdateSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateSplitPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateSplitPayload")
		case "split":

			out.Values[i] = ec._UpdateSplitPayload_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateTokenInfoPayloadImplementors = []string{"UpdateTokenInfoPayload", "UpdateTokenInfoPayloadOrError"}

func (ec *executionContext) _UpdateTokenInfoPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateTokenInfoPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTokenInfoPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTokenInfoPayload")
		case "token":

			out.Values[i] = ec._UpdateTokenInfoPayload_token(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateUserExperiencePayloadImplementors = []string{"UpdateUserExperiencePayload", "UpdateUserExperiencePayloadOrError"}

func (ec *executionContext) _UpdateUserExperiencePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateUserExperiencePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateUserExperiencePayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateUserExperiencePayload")
		case "viewer":

			out.Values[i] = ec._UpdateUserExperiencePayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateUserInfoPayloadImplementors = []string{"UpdateUserInfoPayload", "UpdateUserInfoPayloadOrError"}

func (ec *executionContext) _UpdateUserInfoPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateUserInfoPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateUserInfoPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateUserInfoPayload")
		case "viewer":

			out.Values[i] = ec._UpdateUserInfoPayload_viewer(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var uploadPersistedQueriesPayloadImplementors = []string{"UploadPersistedQueriesPayload", "UploadPersistedQueriesPayloadOrError"}

func (ec *executionContext) _UploadPersistedQueriesPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UploadPersistedQueriesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uploadPersistedQueriesPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UploadPersistedQueriesPayload")
		case "message":

			out.Values[i] = ec._UploadPersistedQueriesPayload_message(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (ec *executionContext) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *model.UserEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEdge")
		case "node":

			out.Values[i] = ec._UserEdge_node(ctx, field, obj)

		case "cursor":

			out.Values[i] = ec._UserEdge_cursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userEmailImplementors = []string{"UserEmail"}

func (ec *executionContext) _UserEmail(ctx context.Context, sel ast.SelectionSet, obj *model.UserEmail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userEmailImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserEmail")
		case "email":

			out.Values[i] = ec._UserEmail_email(ctx, field, obj)

		case "verificationStatus":

			out.Values[i] = ec._UserEmail_verificationStatus(ctx, field, obj)

		case "emailNotificationSettings":

			out.Values[i] = ec._UserEmail_emailNotificationSettings(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userExperienceImplementors = []string{"UserExperience"}

func (ec *executionContext) _UserExperience(ctx context.Context, sel ast.SelectionSet, obj *model.UserExperience) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userExperienceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserExperience")
		case "type":

			out.Values[i] = ec._UserExperience_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "experienced":

			out.Values[i] = ec._UserExperience_experienced(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userSearchResultImplementors = []string{"UserSearchResult"}

func (ec *executionContext) _UserSearchResult(ctx context.Context, sel ast.SelectionSet, obj *model.UserSearchResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSearchResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSearchResult")
		case "user":

			out.Values[i] = ec._UserSearchResult_user(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var usersConnectionImplementors = []string{"UsersConnection"}

func (ec *executionContext) _UsersConnection(ctx context.Context, sel ast.SelectionSet, obj *model.UsersConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, usersConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UsersConnection")
		case "edges":

			out.Values[i] = ec._UsersConnection_edges(ctx, field, obj)

		case "pageInfo":

			out.Values[i] = ec._UsersConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var verifyEmailPayloadImplementors = []string{"VerifyEmailPayload", "VerifyEmailPayloadOrError"}

func (ec *executionContext) _VerifyEmailPayload(ctx context.Context, sel ast.SelectionSet, obj *model.VerifyEmailPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, verifyEmailPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VerifyEmailPayload")
		case "email":

			out.Values[i] = ec._VerifyEmailPayload_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var videoMediaImplementors = []string{"VideoMedia", "MediaSubtype", "Media"}

func (ec *executionContext) _VideoMedia(ctx context.Context, sel ast.SelectionSet, obj *model.VideoMedia) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, videoMediaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VideoMedia")
		case "previewURLs":

			out.Values[i] = ec._VideoMedia_previewURLs(ctx, field, obj)

		case "mediaURL":

			out.Values[i] = ec._VideoMedia_mediaURL(ctx, field, obj)

		case "mediaType":

			out.Values[i] = ec._VideoMedia_mediaType(ctx, field, obj)

		case "contentRenderURLs":

			out.Values[i] = ec._VideoMedia_contentRenderURLs(ctx, field, obj)

		case "dimensions":

			out.Values[i] = ec._VideoMedia_dimensions(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var videoURLSetImplementors = []string{"VideoURLSet"}

func (ec *executionContext) _VideoURLSet(ctx context.Context, sel ast.SelectionSet, obj *model.VideoURLSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, videoURLSetImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VideoURLSet")
		case "raw":

			out.Values[i] = ec._VideoURLSet_raw(ctx, field, obj)

		case "small":

			out.Values[i] = ec._VideoURLSet_small(ctx, field, obj)

		case "medium":

			out.Values[i] = ec._VideoURLSet_medium(ctx, field, obj)

		case "large":

			out.Values[i] = ec._VideoURLSet_large(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var viewSplitPayloadImplementors = []string{"ViewSplitPayload", "ViewSplitPayloadOrError"}

func (ec *executionContext) _ViewSplitPayload(ctx context.Context, sel ast.SelectionSet, obj *model.ViewSplitPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, viewSplitPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ViewSplitPayload")
		case "split":

			out.Values[i] = ec._ViewSplitPayload_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var viewerImplementors = []string{"Viewer", "Node", "ViewerOrError"}

func (ec *executionContext) _Viewer(ctx context.Context, sel ast.SelectionSet, obj *model.Viewer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, viewerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Viewer")
		case "id":

			out.Values[i] = ec._Viewer_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_user(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "socialAccounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_socialAccounts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "viewerSplits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_viewerSplits(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "email":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_email(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "notifications":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_notifications(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "notificationSettings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_notificationSettings(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "userExperiences":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Viewer_userExperiences(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var viewerSplitImplementors = []string{"ViewerSplit", "ViewerSplitByIdPayloadOrError"}

func (ec *executionContext) _ViewerSplit(ctx context.Context, sel ast.SelectionSet, obj *model.ViewerSplit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, viewerSplitImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ViewerSplit")
		case "split":

			out.Values[i] = ec._ViewerSplit_split(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var walletImplementors = []string{"Wallet", "Node", "SplitFiUserOrWallet"}

func (ec *executionContext) _Wallet(ctx context.Context, sel ast.SelectionSet, obj *model.Wallet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Wallet")
		case "id":

			out.Values[i] = ec._Wallet_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dbid":

			out.Values[i] = ec._Wallet_dbid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "chainAddress":

			out.Values[i] = ec._Wallet_chainAddress(ctx, field, obj)

		case "chain":

			out.Values[i] = ec._Wallet_chain(ctx, field, obj)

		case "walletType":

			out.Values[i] = ec._Wallet_walletType(ctx, field, obj)

		case "tokens":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Wallet_tokens(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var _ServiceImplementors = []string{"_Service"}

func (ec *executionContext) __Service(ctx context.Context, sel ast.SelectionSet, obj *fedruntime.Service) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ServiceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_Service")
		case "sdl":

			out.Values[i] = ec.__Service_sdl(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx context.Context, v interface{}) (persist.Address, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Address(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx context.Context, sel ast.SelectionSet, v persist.Address) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNAdminAddWalletInput2githubcomSplitFigosplitfigraphqlmodelAdminAddWalletInput(ctx context.Context, v interface{}) (model.AdminAddWalletInput, error) {
	res, err := ec.unmarshalInputAdminAddWalletInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAuthMechanism2githubcomSplitFigosplitfigraphqlmodelAuthMechanism(ctx context.Context, v interface{}) (model.AuthMechanism, error) {
	res, err := ec.unmarshalInputAuthMechanism(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAuthorizationError2githubcomSplitFigosplitfigraphqlmodelAuthorizationError(ctx context.Context, sel ast.SelectionSet, v model.AuthorizationError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthorizationError(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, v interface{}) (persist.Chain, error) {
	var res persist.Chain
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, sel ast.SelectionSet, v persist.Chain) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, v interface{}) ([]persist.Chain, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]persist.Chain, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, sel ast.SelectionSet, v []persist.Chain) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx context.Context, sel ast.SelectionSet, v *persist.ChainAddress) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChainAddress(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx context.Context, v interface{}) (persist.ChainAddress, error) {
	res, err := ec.unmarshalInputChainAddressInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx context.Context, v interface{}) (*persist.ChainAddress, error) {
	res, err := ec.unmarshalInputChainAddressInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChainPubKeyInput2githubcomSplitFigosplitfiservicepersistChainPubKey(ctx context.Context, v interface{}) (*persist.ChainPubKey, error) {
	res, err := ec.unmarshalInputChainPubKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCollectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionLayoutInput(ctx context.Context, v interface{}) (*model.CollectionLayoutInput, error) {
	res, err := ec.unmarshalInputCollectionLayoutInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCollectionSectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionSectionLayoutInput(ctx context.Context, v interface{}) ([]*model.CollectionSectionLayoutInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.CollectionSectionLayoutInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCollectionSectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionSectionLayoutInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCollectionSectionLayoutInput2githubcomSplitFigosplitfigraphqlmodelCollectionSectionLayoutInput(ctx context.Context, v interface{}) (*model.CollectionSectionLayoutInput, error) {
	res, err := ec.unmarshalInputCollectionSectionLayoutInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCollectionTokenSettingsInput2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettingsInput(ctx context.Context, v interface{}) ([]*model.CollectionTokenSettingsInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.CollectionTokenSettingsInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCollectionTokenSettingsInput2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettingsInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNCollectionTokenSettingsInput2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettingsInput(ctx context.Context, v interface{}) (*model.CollectionTokenSettingsInput, error) {
	res, err := ec.unmarshalInputCollectionTokenSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCommunitySearchResult2githubcomSplitFigosplitfigraphqlmodelCommunitySearchResult(ctx context.Context, sel ast.SelectionSet, v *model.CommunitySearchResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CommunitySearchResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateCollectionInput2githubcomSplitFigosplitfigraphqlmodelCreateCollectionInput(ctx context.Context, v interface{}) (model.CreateCollectionInput, error) {
	res, err := ec.unmarshalInputCreateCollectionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSplitInput2githubcomSplitFigosplitfigraphqlmodelCreateSplitInput(ctx context.Context, v interface{}) (model.CreateSplitInput, error) {
	res, err := ec.unmarshalInputCreateSplitInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUserInput2githubcomSplitFigosplitfigraphqlmodelCreateUserInput(ctx context.Context, v interface{}) (model.CreateUserInput, error) {
	res, err := ec.unmarshalInputCreateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx context.Context, v interface{}) (persist.DBID, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.DBID(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx context.Context, sel ast.SelectionSet, v persist.DBID) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx context.Context, v interface{}) ([]persist.DBID, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]persist.DBID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx context.Context, sel ast.SelectionSet, v []persist.DBID) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNDeepRefreshInput2githubcomSplitFigosplitfigraphqlmodelDeepRefreshInput(ctx context.Context, v interface{}) (model.DeepRefreshInput, error) {
	res, err := ec.unmarshalInputDeepRefreshInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx context.Context, v interface{}) (persist.Email, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Email(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx context.Context, sel ast.SelectionSet, v persist.Email) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNEmailUnsubscriptionType2githubcomSplitFigosplitfigraphqlmodelEmailUnsubscriptionType(ctx context.Context, v interface{}) (model.EmailUnsubscriptionType, error) {
	var res model.EmailUnsubscriptionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEmailUnsubscriptionType2githubcomSplitFigosplitfigraphqlmodelEmailUnsubscriptionType(ctx context.Context, sel ast.SelectionSet, v model.EmailUnsubscriptionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx context.Context, v interface{}) (model.GqlID, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model.GqlID(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubcomSplitFigosplitfigraphqlmodelGqlID(ctx context.Context, sel ast.SelectionSet, v model.GqlID) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMintPremiumCardToWalletInput2githubcomSplitFigosplitfigraphqlmodelMintPremiumCardToWalletInput(ctx context.Context, v interface{}) (model.MintPremiumCardToWalletInput, error) {
	res, err := ec.unmarshalInputMintPremiumCardToWalletInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPreverifyEmailInput2githubcomSplitFigosplitfigraphqlmodelPreverifyEmailInput(ctx context.Context, v interface{}) (model.PreverifyEmailInput, error) {
	res, err := ec.unmarshalInputPreverifyEmailInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPreverifyEmailResult2githubcomSplitFigosplitfigraphqlmodelPreverifyEmailResult(ctx context.Context, v interface{}) (model.PreverifyEmailResult, error) {
	var res model.PreverifyEmailResult
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPreverifyEmailResult2githubcomSplitFigosplitfigraphqlmodelPreverifyEmailResult(ctx context.Context, sel ast.SelectionSet, v model.PreverifyEmailResult) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPubKey2githubcomSplitFigosplitfiservicepersistPubKey(ctx context.Context, v interface{}) (persist.PubKey, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.PubKey(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPubKey2githubcomSplitFigosplitfiservicepersistPubKey(ctx context.Context, sel ast.SelectionSet, v persist.PubKey) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNPublishSplitInput2githubcomSplitFigosplitfigraphqlmodelPublishSplitInput(ctx context.Context, v interface{}) (model.PublishSplitInput, error) {
	res, err := ec.unmarshalInputPublishSplitInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRole2githubcomSplitFigosplitfiservicepersistRole(ctx context.Context, v interface{}) (persist.Role, error) {
	var res persist.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRole2githubcomSplitFigosplitfiservicepersistRole(ctx context.Context, sel ast.SelectionSet, v persist.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSetSpamPreferenceInput2githubcomSplitFigosplitfigraphqlmodelSetSpamPreferenceInput(ctx context.Context, v interface{}) (model.SetSpamPreferenceInput, error) {
	res, err := ec.unmarshalInputSetSpamPreferenceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx context.Context, v interface{}) (persist.SocialProvider, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.SocialProvider(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSocialAccountType2githubcomSplitFigosplitfiservicepersistSocialProvider(ctx context.Context, sel ast.SelectionSet, v persist.SocialProvider) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNSocialAuthMechanism2githubcomSplitFigosplitfigraphqlmodelSocialAuthMechanism(ctx context.Context, v interface{}) (model.SocialAuthMechanism, error) {
	res, err := ec.unmarshalInputSocialAuthMechanism(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSplitPositionInput2githubcomSplitFigosplitfigraphqlmodelSplitPositionInput(ctx context.Context, v interface{}) ([]*model.SplitPositionInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.SplitPositionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSplitPositionInput2githubcomSplitFigosplitfigraphqlmodelSplitPositionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSplitPositionInput2githubcomSplitFigosplitfigraphqlmodelSplitPositionInput(ctx context.Context, v interface{}) (*model.SplitPositionInput, error) {
	res, err := ec.unmarshalInputSplitPositionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSplitSearchResult2githubcomSplitFigosplitfigraphqlmodelSplitSearchResult(ctx context.Context, sel ast.SelectionSet, v *model.SplitSearchResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SplitSearchResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUnsubscribeFromEmailTypeInput2githubcomSplitFigosplitfigraphqlmodelUnsubscribeFromEmailTypeInput(ctx context.Context, v interface{}) (model.UnsubscribeFromEmailTypeInput, error) {
	res, err := ec.unmarshalInputUnsubscribeFromEmailTypeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateCollectionHiddenInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionHiddenInput(ctx context.Context, v interface{}) (model.UpdateCollectionHiddenInput, error) {
	res, err := ec.unmarshalInputUpdateCollectionHiddenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateCollectionInfoInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionInfoInput(ctx context.Context, v interface{}) (model.UpdateCollectionInfoInput, error) {
	res, err := ec.unmarshalInputUpdateCollectionInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateCollectionTokensInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionTokensInput(ctx context.Context, v interface{}) (model.UpdateCollectionTokensInput, error) {
	res, err := ec.unmarshalInputUpdateCollectionTokensInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEmailInput2githubcomSplitFigosplitfigraphqlmodelUpdateEmailInput(ctx context.Context, v interface{}) (model.UpdateEmailInput, error) {
	res, err := ec.unmarshalInputUpdateEmailInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEmailNotificationSettingsInput2githubcomSplitFigosplitfigraphqlmodelUpdateEmailNotificationSettingsInput(ctx context.Context, v interface{}) (model.UpdateEmailNotificationSettingsInput, error) {
	res, err := ec.unmarshalInputUpdateEmailNotificationSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSocialAccountDisplayedInput2githubcomSplitFigosplitfigraphqlmodelUpdateSocialAccountDisplayedInput(ctx context.Context, v interface{}) (model.UpdateSocialAccountDisplayedInput, error) {
	res, err := ec.unmarshalInputUpdateSocialAccountDisplayedInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitCollectionsInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitCollectionsInput(ctx context.Context, v interface{}) (model.UpdateSplitCollectionsInput, error) {
	res, err := ec.unmarshalInputUpdateSplitCollectionsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitHiddenInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitHiddenInput(ctx context.Context, v interface{}) (model.UpdateSplitHiddenInput, error) {
	res, err := ec.unmarshalInputUpdateSplitHiddenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitInfoInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitInfoInput(ctx context.Context, v interface{}) (model.UpdateSplitInfoInput, error) {
	res, err := ec.unmarshalInputUpdateSplitInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitInput(ctx context.Context, v interface{}) (model.UpdateSplitInput, error) {
	res, err := ec.unmarshalInputUpdateSplitInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSplitOrderInput2githubcomSplitFigosplitfigraphqlmodelUpdateSplitOrderInput(ctx context.Context, v interface{}) (model.UpdateSplitOrderInput, error) {
	res, err := ec.unmarshalInputUpdateSplitOrderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTokenInfoInput2githubcomSplitFigosplitfigraphqlmodelUpdateTokenInfoInput(ctx context.Context, v interface{}) (model.UpdateTokenInfoInput, error) {
	res, err := ec.unmarshalInputUpdateTokenInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserExperienceInput2githubcomSplitFigosplitfigraphqlmodelUpdateUserExperienceInput(ctx context.Context, v interface{}) (model.UpdateUserExperienceInput, error) {
	res, err := ec.unmarshalInputUpdateUserExperienceInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserInfoInput2githubcomSplitFigosplitfigraphqlmodelUpdateUserInfoInput(ctx context.Context, v interface{}) (model.UpdateUserInfoInput, error) {
	res, err := ec.unmarshalInputUpdateUserInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserExperience2githubcomSplitFigosplitfigraphqlmodelUserExperience(ctx context.Context, sel ast.SelectionSet, v *model.UserExperience) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserExperience(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserExperienceType2githubcomSplitFigosplitfigraphqlmodelUserExperienceType(ctx context.Context, v interface{}) (model.UserExperienceType, error) {
	var res model.UserExperienceType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserExperienceType2githubcomSplitFigosplitfigraphqlmodelUserExperienceType(ctx context.Context, sel ast.SelectionSet, v model.UserExperienceType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNUserSearchResult2githubcomSplitFigosplitfigraphqlmodelUserSearchResult(ctx context.Context, sel ast.SelectionSet, v *model.UserSearchResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserSearchResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVerifyEmailInput2githubcomSplitFigosplitfigraphqlmodelVerifyEmailInput(ctx context.Context, v interface{}) (model.VerifyEmailInput, error) {
	res, err := ec.unmarshalInputVerifyEmailInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWalletType2githubcomSplitFigosplitfiservicepersistWalletType(ctx context.Context, v interface{}) (persist.WalletType, error) {
	var res persist.WalletType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWalletType2githubcomSplitFigosplitfiservicepersistWalletType(ctx context.Context, sel ast.SelectionSet, v persist.WalletType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalN_FieldSet2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_FieldSet2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalN_Service2githubcom99designsgqlgenpluginfederationfedruntimeService(ctx context.Context, sel ast.SelectionSet, v fedruntime.Service) graphql.Marshaler {
	return ec.__Service(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAddRolesToUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelAddRolesToUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.AddRolesToUserPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddRolesToUserPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOAddUserWalletPayloadOrError2githubcomSplitFigosplitfigraphqlmodelAddUserWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.AddUserWalletPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddUserWalletPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx context.Context, v interface{}) (persist.Address, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Address(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx context.Context, sel ast.SelectionSet, v persist.Address) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalOAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx context.Context, v interface{}) ([]persist.Address, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]persist.Address, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx context.Context, sel ast.SelectionSet, v []persist.Address) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNAddress2githubcomSplitFigosplitfiservicepersistAddress(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAdminAddWalletPayloadOrError2githubcomSplitFigosplitfigraphqlmodelAdminAddWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.AdminAddWalletPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdminAddWalletPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOBadge2githubcomSplitFigosplitfigraphqlmodelBadge(ctx context.Context, sel ast.SelectionSet, v []*model.Badge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBadge2githubcomSplitFigosplitfigraphqlmodelBadge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBadge2githubcomSplitFigosplitfigraphqlmodelBadge(ctx context.Context, sel ast.SelectionSet, v *model.Badge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Badge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, v interface{}) (persist.Chain, error) {
	var res persist.Chain
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, sel ast.SelectionSet, v persist.Chain) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, v interface{}) ([]persist.Chain, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]persist.Chain, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, sel ast.SelectionSet, v []persist.Chain) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChain2githubcomSplitFigosplitfiservicepersistChain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, v interface{}) (*persist.Chain, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(persist.Chain)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChain2githubcomSplitFigosplitfiservicepersistChain(ctx context.Context, sel ast.SelectionSet, v *persist.Chain) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx context.Context, sel ast.SelectionSet, v []*persist.ChainAddress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChainAddress2githubcomSplitFigosplitfiservicepersistChainAddress(ctx context.Context, sel ast.SelectionSet, v *persist.ChainAddress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChainAddress(ctx, sel, v)
}

func (ec *executionContext) unmarshalOChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx context.Context, v interface{}) ([]*persist.ChainAddress, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*persist.ChainAddress, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNChainAddressInput2githubcomSplitFigosplitfiservicepersistChainAddress(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOChainTokens2githubcomSplitFigosplitfigraphqlmodelChainTokens(ctx context.Context, sel ast.SelectionSet, v *model.ChainTokens) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChainTokens(ctx, sel, v)
}

func (ec *executionContext) marshalOClearAllNotificationsPayload2githubcomSplitFigosplitfigraphqlmodelClearAllNotificationsPayload(ctx context.Context, sel ast.SelectionSet, v *model.ClearAllNotificationsPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ClearAllNotificationsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx context.Context, sel ast.SelectionSet, v []*model.Collection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCollection2githubcomSplitFigosplitfigraphqlmodelCollection(ctx context.Context, sel ast.SelectionSet, v *model.Collection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Collection(ctx, sel, v)
}

func (ec *executionContext) marshalOCollectionByIdOrError2githubcomSplitFigosplitfigraphqlmodelCollectionByIDOrError(ctx context.Context, sel ast.SelectionSet, v model.CollectionByIDOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CollectionByIdOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOCollectionByIdOrError2githubcomSplitFigosplitfigraphqlmodelCollectionByIDOrError(ctx context.Context, sel ast.SelectionSet, v []model.CollectionByIDOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCollectionByIdOrError2githubcomSplitFigosplitfigraphqlmodelCollectionByIDOrError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCollectionLayout2githubcomSplitFigosplitfigraphqlmodelCollectionLayout(ctx context.Context, sel ast.SelectionSet, v *model.CollectionLayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CollectionLayout(ctx, sel, v)
}

func (ec *executionContext) marshalOCollectionSectionLayout2githubcomSplitFigosplitfigraphqlmodelCollectionSectionLayout(ctx context.Context, sel ast.SelectionSet, v []*model.CollectionSectionLayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCollectionSectionLayout2githubcomSplitFigosplitfigraphqlmodelCollectionSectionLayout(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCollectionSectionLayout2githubcomSplitFigosplitfigraphqlmodelCollectionSectionLayout(ctx context.Context, sel ast.SelectionSet, v *model.CollectionSectionLayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CollectionSectionLayout(ctx, sel, v)
}

func (ec *executionContext) marshalOCollectionToken2githubcomSplitFigosplitfigraphqlmodelCollectionToken(ctx context.Context, sel ast.SelectionSet, v []*model.CollectionToken) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCollectionToken2githubcomSplitFigosplitfigraphqlmodelCollectionToken(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCollectionToken2githubcomSplitFigosplitfigraphqlmodelCollectionToken(ctx context.Context, sel ast.SelectionSet, v *model.CollectionToken) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CollectionToken(ctx, sel, v)
}

func (ec *executionContext) marshalOCollectionTokenByIdOrError2githubcomSplitFigosplitfigraphqlmodelCollectionTokenByIDOrError(ctx context.Context, sel ast.SelectionSet, v model.CollectionTokenByIDOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CollectionTokenByIdOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOCollectionTokenSettings2githubcomSplitFigosplitfigraphqlmodelCollectionTokenSettings(ctx context.Context, sel ast.SelectionSet, v *model.CollectionTokenSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CollectionTokenSettings(ctx, sel, v)
}

func (ec *executionContext) marshalOCommunitiesConnection2githubcomSplitFigosplitfigraphqlmodelCommunitiesConnection(ctx context.Context, sel ast.SelectionSet, v *model.CommunitiesConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CommunitiesConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOCommunity2githubcomSplitFigosplitfigraphqlmodelCommunity(ctx context.Context, sel ast.SelectionSet, v *model.Community) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Community(ctx, sel, v)
}

func (ec *executionContext) marshalOCommunityByAddressOrError2githubcomSplitFigosplitfigraphqlmodelCommunityByAddressOrError(ctx context.Context, sel ast.SelectionSet, v model.CommunityByAddressOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CommunityByAddressOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOCommunityEdge2githubcomSplitFigosplitfigraphqlmodelCommunityEdge(ctx context.Context, sel ast.SelectionSet, v []*model.CommunityEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCommunityEdge2githubcomSplitFigosplitfigraphqlmodelCommunityEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCommunityEdge2githubcomSplitFigosplitfigraphqlmodelCommunityEdge(ctx context.Context, sel ast.SelectionSet, v *model.CommunityEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CommunityEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOCommunitySearchResult2githubcomSplitFigosplitfigraphqlmodelCommunitySearchResult(ctx context.Context, sel ast.SelectionSet, v []*model.CommunitySearchResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCommunitySearchResult2githubcomSplitFigosplitfigraphqlmodelCommunitySearchResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOConnectSocialAccountPayloadOrError2githubcomSplitFigosplitfigraphqlmodelConnectSocialAccountPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.ConnectSocialAccountPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectSocialAccountPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOContract2githubcomSplitFigosplitfigraphqlmodelContract(ctx context.Context, sel ast.SelectionSet, v *model.Contract) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Contract(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCreateCollectionInSplitInput2githubcomSplitFigosplitfigraphqlmodelCreateCollectionInSplitInput(ctx context.Context, v interface{}) ([]*model.CreateCollectionInSplitInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.CreateCollectionInSplitInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOCreateCollectionInSplitInput2githubcomSplitFigosplitfigraphqlmodelCreateCollectionInSplitInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCreateCollectionInSplitInput2githubcomSplitFigosplitfigraphqlmodelCreateCollectionInSplitInput(ctx context.Context, v interface{}) (*model.CreateCollectionInSplitInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateCollectionInSplitInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCreateCollectionPayloadOrError2githubcomSplitFigosplitfigraphqlmodelCreateCollectionPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.CreateCollectionPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CreateCollectionPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOCreateSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelCreateSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.CreateSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CreateSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOCreateUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelCreateUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.CreateUserPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CreateUserPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx context.Context, v interface{}) ([]persist.DBID, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]persist.DBID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx context.Context, sel ast.SelectionSet, v []persist.DBID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNDBID2githubcomSplitFigosplitfiservicepersistDBID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx context.Context, v interface{}) (*persist.DBID, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := persist.DBID(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODBID2githubcomSplitFigosplitfiservicepersistDBID(ctx context.Context, sel ast.SelectionSet, v *persist.DBID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) unmarshalODebugAuth2githubcomSplitFigosplitfigraphqlmodelDebugAuth(ctx context.Context, v interface{}) (*model.DebugAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDebugAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODebugSocialAuth2githubcomSplitFigosplitfigraphqlmodelDebugSocialAuth(ctx context.Context, v interface{}) (*model.DebugSocialAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDebugSocialAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeepRefreshPayloadOrError2githubcomSplitFigosplitfigraphqlmodelDeepRefreshPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.DeepRefreshPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeepRefreshPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalODeleteCollectionPayloadOrError2githubcomSplitFigosplitfigraphqlmodelDeleteCollectionPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.DeleteCollectionPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteCollectionPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalODeleteSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelDeleteSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.DeleteSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalODeletedNode2githubcomSplitFigosplitfigraphqlmodelDeletedNode(ctx context.Context, sel ast.SelectionSet, v *model.DeletedNode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeletedNode(ctx, sel, v)
}

func (ec *executionContext) marshalODisconnectSocialAccountPayloadOrError2githubcomSplitFigosplitfigraphqlmodelDisconnectSocialAccountPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.DisconnectSocialAccountPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DisconnectSocialAccountPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx context.Context, v interface{}) (*persist.Email, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := persist.Email(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEmail2githubcomSplitFigosplitfiservicepersistEmail(ctx context.Context, sel ast.SelectionSet, v *persist.Email) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOEmailNotificationSettings2githubcomSplitFigosplitfigraphqlmodelEmailNotificationSettings(ctx context.Context, sel ast.SelectionSet, v *model.EmailNotificationSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EmailNotificationSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEmailVerificationStatus2githubcomSplitFigosplitfiservicepersistEmailVerificationStatus(ctx context.Context, v interface{}) (*persist.EmailVerificationStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(persist.EmailVerificationStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEmailVerificationStatus2githubcomSplitFigosplitfiservicepersistEmailVerificationStatus(ctx context.Context, sel ast.SelectionSet, v *persist.EmailVerificationStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEoaAuth2githubcomSplitFigosplitfigraphqlmodelEoaAuth(ctx context.Context, v interface{}) (*model.EoaAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEoaAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOFollowAllSocialConnectionsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelFollowAllSocialConnectionsPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.FollowAllSocialConnectionsPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FollowAllSocialConnectionsPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOFollowUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelFollowUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.FollowUserPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FollowUserPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOGetAuthNoncePayloadOrError2githubcomSplitFigosplitfigraphqlmodelGetAuthNoncePayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.GetAuthNoncePayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GetAuthNoncePayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGnosisSafeAuth2githubcomSplitFigosplitfigraphqlmodelGnosisSafeAuth(ctx context.Context, v interface{}) (*model.GnosisSafeAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGnosisSafeAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupNotificationUserEdge2githubcomSplitFigosplitfigraphqlmodelGroupNotificationUserEdge(ctx context.Context, sel ast.SelectionSet, v []*model.GroupNotificationUserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGroupNotificationUserEdge2githubcomSplitFigosplitfigraphqlmodelGroupNotificationUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGroupNotificationUserEdge2githubcomSplitFigosplitfigraphqlmodelGroupNotificationUserEdge(ctx context.Context, sel ast.SelectionSet, v *model.GroupNotificationUserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupNotificationUserEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOGroupNotificationUsersConnection2githubcomSplitFigosplitfigraphqlmodelGroupNotificationUsersConnection(ctx context.Context, sel ast.SelectionSet, v *model.GroupNotificationUsersConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupNotificationUsersConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]*int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2int(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLoginPayloadOrError2githubcomSplitFigosplitfigraphqlmodelLoginPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.LoginPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoginPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOLogoutPayload2githubcomSplitFigosplitfigraphqlmodelLogoutPayload(ctx context.Context, sel ast.SelectionSet, v *model.LogoutPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LogoutPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMagicLinkAuth2githubcomSplitFigosplitfigraphqlmodelMagicLinkAuth(ctx context.Context, v interface{}) (*model.MagicLinkAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMagicLinkAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMediaDimensions2githubcomSplitFigosplitfigraphqlmodelMediaDimensions(ctx context.Context, sel ast.SelectionSet, v *model.MediaDimensions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MediaDimensions(ctx, sel, v)
}

func (ec *executionContext) marshalOMediaSubtype2githubcomSplitFigosplitfigraphqlmodelMediaSubtype(ctx context.Context, sel ast.SelectionSet, v model.MediaSubtype) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MediaSubtype(ctx, sel, v)
}

func (ec *executionContext) marshalOMembershipTier2githubcomSplitFigosplitfigraphqlmodelMembershipTier(ctx context.Context, sel ast.SelectionSet, v []*model.MembershipTier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMembershipTier2githubcomSplitFigosplitfigraphqlmodelMembershipTier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOMembershipTier2githubcomSplitFigosplitfigraphqlmodelMembershipTier(ctx context.Context, sel ast.SelectionSet, v *model.MembershipTier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MembershipTier(ctx, sel, v)
}

func (ec *executionContext) marshalOMintPremiumCardToWalletPayloadOrError2githubcomSplitFigosplitfigraphqlmodelMintPremiumCardToWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.MintPremiumCardToWalletPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MintPremiumCardToWalletPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMoveCollectionToSplitInput2githubcomSplitFigosplitfigraphqlmodelMoveCollectionToSplitInput(ctx context.Context, v interface{}) (*model.MoveCollectionToSplitInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMoveCollectionToSplitInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMoveCollectionToSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelMoveCollectionToSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.MoveCollectionToSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MoveCollectionToSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalONode2githubcomSplitFigosplitfigraphqlmodelNode(ctx context.Context, sel ast.SelectionSet, v model.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalONotification2githubcomSplitFigosplitfigraphqlmodelNotification(ctx context.Context, sel ast.SelectionSet, v model.Notification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Notification(ctx, sel, v)
}

func (ec *executionContext) marshalONotification2githubcomSplitFigosplitfigraphqlmodelNotification(ctx context.Context, sel ast.SelectionSet, v []model.Notification) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONotification2githubcomSplitFigosplitfigraphqlmodelNotification(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONotificationEdge2githubcomSplitFigosplitfigraphqlmodelNotificationEdge(ctx context.Context, sel ast.SelectionSet, v []*model.NotificationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONotificationEdge2githubcomSplitFigosplitfigraphqlmodelNotificationEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONotificationEdge2githubcomSplitFigosplitfigraphqlmodelNotificationEdge(ctx context.Context, sel ast.SelectionSet, v *model.NotificationEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotificationEdge(ctx, sel, v)
}

func (ec *executionContext) marshalONotificationSettings2githubcomSplitFigosplitfigraphqlmodelNotificationSettings(ctx context.Context, sel ast.SelectionSet, v *model.NotificationSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotificationSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotificationSettingsInput2githubcomSplitFigosplitfigraphqlmodelNotificationSettingsInput(ctx context.Context, v interface{}) (*model.NotificationSettingsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotificationSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotificationsConnection2githubcomSplitFigosplitfigraphqlmodelNotificationsConnection(ctx context.Context, sel ast.SelectionSet, v *model.NotificationsConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotificationsConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOOwnerAtBlock2githubcomSplitFigosplitfigraphqlmodelOwnerAtBlock(ctx context.Context, sel ast.SelectionSet, v []*model.OwnerAtBlock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOwnerAtBlock2githubcomSplitFigosplitfigraphqlmodelOwnerAtBlock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOOwnerAtBlock2githubcomSplitFigosplitfigraphqlmodelOwnerAtBlock(ctx context.Context, sel ast.SelectionSet, v *model.OwnerAtBlock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OwnerAtBlock(ctx, sel, v)
}

func (ec *executionContext) marshalOPageInfo2githubcomSplitFigosplitfigraphqlmodelPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.PageInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOPreverifyEmailPayloadOrError2githubcomSplitFigosplitfigraphqlmodelPreverifyEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.PreverifyEmailPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PreverifyEmailPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx context.Context, sel ast.SelectionSet, v []*model.PreviewURLSet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPreviewURLSet2githubcomSplitFigosplitfigraphqlmodelPreviewURLSet(ctx context.Context, sel ast.SelectionSet, v *model.PreviewURLSet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PreviewURLSet(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPubKey2githubcomSplitFigosplitfiservicepersistPubKey(ctx context.Context, v interface{}) (persist.PubKey, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := persist.PubKey(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPubKey2githubcomSplitFigosplitfiservicepersistPubKey(ctx context.Context, sel ast.SelectionSet, v persist.PubKey) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) marshalOPublishSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelPublishSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.PublishSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PublishSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalORefreshCollectionPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRefreshCollectionPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.RefreshCollectionPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RefreshCollectionPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalORefreshContractPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRefreshContractPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.RefreshContractPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RefreshContractPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalORefreshTokenPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRefreshTokenPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.RefreshTokenPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RefreshTokenPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalORemoveUserWalletsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRemoveUserWalletsPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.RemoveUserWalletsPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RemoveUserWalletsPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOResendVerificationEmailPayloadOrError2githubcomSplitFigosplitfigraphqlmodelResendVerificationEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.ResendVerificationEmailPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResendVerificationEmailPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalORevokeRolesFromUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelRevokeRolesFromUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.RevokeRolesFromUserPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RevokeRolesFromUserPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx context.Context, v interface{}) ([]*persist.Role, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*persist.Role, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx context.Context, sel ast.SelectionSet, v []*persist.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx context.Context, v interface{}) (*persist.Role, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(persist.Role)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORole2githubcomSplitFigosplitfiservicepersistRole(ctx context.Context, sel ast.SelectionSet, v *persist.Role) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSearchCommunitiesPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSearchCommunitiesPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SearchCommunitiesPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchCommunitiesPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSearchSplitsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSearchSplitsPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SearchSplitsPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchSplitsPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSearchUsersPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSearchUsersPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SearchUsersPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchUsersPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSetSpamPreferencePayloadOrError2githubcomSplitFigosplitfigraphqlmodelSetSpamPreferencePayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SetSpamPreferencePayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SetSpamPreferencePayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSocialAccounts2githubcomSplitFigosplitfigraphqlmodelSocialAccounts(ctx context.Context, sel ast.SelectionSet, v *model.SocialAccounts) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SocialAccounts(ctx, sel, v)
}

func (ec *executionContext) marshalOSocialConnectionsConnection2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsConnection(ctx context.Context, sel ast.SelectionSet, v *model.SocialConnectionsConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SocialConnectionsConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOSocialConnectionsEdge2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsEdge(ctx context.Context, sel ast.SelectionSet, v []*model.SocialConnectionsEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSocialConnectionsEdge2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSocialConnectionsEdge2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsEdge(ctx context.Context, sel ast.SelectionSet, v *model.SocialConnectionsEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SocialConnectionsEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOSocialConnectionsOrError2githubcomSplitFigosplitfigraphqlmodelSocialConnectionsOrError(ctx context.Context, sel ast.SelectionSet, v model.SocialConnectionsOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SocialConnectionsOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSocialQueriesOrError2githubcomSplitFigosplitfigraphqlmodelSocialQueriesOrError(ctx context.Context, sel ast.SelectionSet, v model.SocialQueriesOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SocialQueriesOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx context.Context, sel ast.SelectionSet, v []*model.Split) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSplit2githubcomSplitFigosplitfigraphqlmodelSplit(ctx context.Context, sel ast.SelectionSet, v *model.Split) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Split(ctx, sel, v)
}

func (ec *executionContext) marshalOSplitByIdPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSplitByIDPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SplitByIDPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SplitByIdPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx context.Context, sel ast.SelectionSet, v []*model.SplitFiUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSplitFiUser2githubcomSplitFigosplitfigraphqlmodelSplitFiUser(ctx context.Context, sel ast.SelectionSet, v *model.SplitFiUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SplitFiUser(ctx, sel, v)
}

func (ec *executionContext) marshalOSplitFiUserOrAddress2githubcomSplitFigosplitfigraphqlmodelSplitFiUserOrAddress(ctx context.Context, sel ast.SelectionSet, v model.SplitFiUserOrAddress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SplitFiUserOrAddress(ctx, sel, v)
}

func (ec *executionContext) marshalOSplitSearchResult2githubcomSplitFigosplitfigraphqlmodelSplitSearchResult(ctx context.Context, sel ast.SelectionSet, v []*model.SplitSearchResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSplitSearchResult2githubcomSplitFigosplitfigraphqlmodelSplitSearchResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOSyncTokensForUsernamePayloadOrError2githubcomSplitFigosplitfigraphqlmodelSyncTokensForUsernamePayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SyncTokensForUsernamePayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SyncTokensForUsernamePayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOSyncTokensPayloadOrError2githubcomSplitFigosplitfigraphqlmodelSyncTokensPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.SyncTokensPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SyncTokensPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx context.Context, sel ast.SelectionSet, v []*model.Token) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOToken2githubcomSplitFigosplitfigraphqlmodelToken(ctx context.Context, sel ast.SelectionSet, v *model.Token) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Token(ctx, sel, v)
}

func (ec *executionContext) marshalOTokenByIdOrError2githubcomSplitFigosplitfigraphqlmodelTokenByIDOrError(ctx context.Context, sel ast.SelectionSet, v model.TokenByIDOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TokenByIdOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOTokenEdge2githubcomSplitFigosplitfigraphqlmodelTokenEdge(ctx context.Context, sel ast.SelectionSet, v []*model.TokenEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTokenEdge2githubcomSplitFigosplitfigraphqlmodelTokenEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTokenEdge2githubcomSplitFigosplitfigraphqlmodelTokenEdge(ctx context.Context, sel ast.SelectionSet, v *model.TokenEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TokenEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOTokenHolder2githubcomSplitFigosplitfigraphqlmodelTokenHolder(ctx context.Context, sel ast.SelectionSet, v []*model.TokenHolder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTokenHolder2githubcomSplitFigosplitfigraphqlmodelTokenHolder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTokenHolder2githubcomSplitFigosplitfigraphqlmodelTokenHolder(ctx context.Context, sel ast.SelectionSet, v *model.TokenHolder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TokenHolder(ctx, sel, v)
}

func (ec *executionContext) marshalOTokenHolderEdge2githubcomSplitFigosplitfigraphqlmodelTokenHolderEdge(ctx context.Context, sel ast.SelectionSet, v []*model.TokenHolderEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTokenHolderEdge2githubcomSplitFigosplitfigraphqlmodelTokenHolderEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTokenHolderEdge2githubcomSplitFigosplitfigraphqlmodelTokenHolderEdge(ctx context.Context, sel ast.SelectionSet, v *model.TokenHolderEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TokenHolderEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOTokenHoldersConnection2githubcomSplitFigosplitfigraphqlmodelTokenHoldersConnection(ctx context.Context, sel ast.SelectionSet, v *model.TokenHoldersConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TokenHoldersConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTokenType2githubcomSplitFigosplitfigraphqlmodelTokenType(ctx context.Context, v interface{}) (*model.TokenType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.TokenType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTokenType2githubcomSplitFigosplitfigraphqlmodelTokenType(ctx context.Context, sel ast.SelectionSet, v *model.TokenType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOTokensConnection2githubcomSplitFigosplitfigraphqlmodelTokensConnection(ctx context.Context, sel ast.SelectionSet, v *model.TokensConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TokensConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTwitterAuth2githubcomSplitFigosplitfigraphqlmodelTwitterAuth(ctx context.Context, v interface{}) (*model.TwitterAuth, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTwitterAuth(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTwitterSocialAccount2githubcomSplitFigosplitfigraphqlmodelTwitterSocialAccount(ctx context.Context, sel ast.SelectionSet, v *model.TwitterSocialAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TwitterSocialAccount(ctx, sel, v)
}

func (ec *executionContext) marshalOUnfollowUserPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUnfollowUserPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UnfollowUserPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UnfollowUserPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUnsubscribeFromEmailTypePayloadOrError2githubcomSplitFigosplitfigraphqlmodelUnsubscribeFromEmailTypePayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UnsubscribeFromEmailTypePayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UnsubscribeFromEmailTypePayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateCollectionHiddenPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionHiddenPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateCollectionHiddenPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateCollectionHiddenPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateCollectionInfoPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateCollectionInfoPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateCollectionInfoPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUpdateCollectionInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionInput(ctx context.Context, v interface{}) ([]*model.UpdateCollectionInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.UpdateCollectionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOUpdateCollectionInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpdateCollectionInput2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionInput(ctx context.Context, v interface{}) (*model.UpdateCollectionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUpdateCollectionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpdateCollectionTokensPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateCollectionTokensPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateCollectionTokensPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateCollectionTokensPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateEmailNotificationSettingsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateEmailNotificationSettingsPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEmailNotificationSettingsPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateEmailNotificationSettingsPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateEmailPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateEmailPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateEmailPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateFeaturedSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateFeaturedSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateFeaturedSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateFeaturedSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdatePrimaryWalletPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdatePrimaryWalletPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdatePrimaryWalletPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdatePrimaryWalletPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSocialAccountDisplayedPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSocialAccountDisplayedPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSocialAccountDisplayedPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSocialAccountDisplayedPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitCollectionsPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitCollectionsPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitCollectionsPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitCollectionsPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitHiddenPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitHiddenPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitHiddenPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitHiddenPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitInfoPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitInfoPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitInfoPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitOrderPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitOrderPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitOrderPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitOrderPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateTokenInfoPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateTokenInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateTokenInfoPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateTokenInfoPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateUserExperiencePayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateUserExperiencePayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateUserExperiencePayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateUserExperiencePayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateUserInfoPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUpdateUserInfoPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UpdateUserInfoPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateUserInfoPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUploadPersistedQueriesInput2githubcomSplitFigosplitfigraphqlmodelUploadPersistedQueriesInput(ctx context.Context, v interface{}) (*model.UploadPersistedQueriesInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUploadPersistedQueriesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUploadPersistedQueriesPayloadOrError2githubcomSplitFigosplitfigraphqlmodelUploadPersistedQueriesPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.UploadPersistedQueriesPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UploadPersistedQueriesPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUserByAddressOrError2githubcomSplitFigosplitfigraphqlmodelUserByAddressOrError(ctx context.Context, sel ast.SelectionSet, v model.UserByAddressOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserByAddressOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUserByIdOrError2githubcomSplitFigosplitfigraphqlmodelUserByIDOrError(ctx context.Context, sel ast.SelectionSet, v model.UserByIDOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserByIdOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUserByUsernameOrError2githubcomSplitFigosplitfigraphqlmodelUserByUsernameOrError(ctx context.Context, sel ast.SelectionSet, v model.UserByUsernameOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserByUsernameOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOUserEdge2githubcomSplitFigosplitfigraphqlmodelUserEdge(ctx context.Context, sel ast.SelectionSet, v []*model.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserEdge2githubcomSplitFigosplitfigraphqlmodelUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUserEdge2githubcomSplitFigosplitfigraphqlmodelUserEdge(ctx context.Context, sel ast.SelectionSet, v *model.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOUserEmail2githubcomSplitFigosplitfigraphqlmodelUserEmail(ctx context.Context, sel ast.SelectionSet, v *model.UserEmail) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserEmail(ctx, sel, v)
}

func (ec *executionContext) marshalOUserExperience2githubcomSplitFigosplitfigraphqlmodelUserExperience(ctx context.Context, sel ast.SelectionSet, v []*model.UserExperience) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserExperience2githubcomSplitFigosplitfigraphqlmodelUserExperience(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUserSearchResult2githubcomSplitFigosplitfigraphqlmodelUserSearchResult(ctx context.Context, sel ast.SelectionSet, v []*model.UserSearchResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserSearchResult2githubcomSplitFigosplitfigraphqlmodelUserSearchResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOUsersConnection2githubcomSplitFigosplitfigraphqlmodelUsersConnection(ctx context.Context, sel ast.SelectionSet, v *model.UsersConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UsersConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOVerifyEmailPayloadOrError2githubcomSplitFigosplitfigraphqlmodelVerifyEmailPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.VerifyEmailPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VerifyEmailPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOVideoURLSet2githubcomSplitFigosplitfigraphqlmodelVideoURLSet(ctx context.Context, sel ast.SelectionSet, v *model.VideoURLSet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VideoURLSet(ctx, sel, v)
}

func (ec *executionContext) marshalOViewSplitPayloadOrError2githubcomSplitFigosplitfigraphqlmodelViewSplitPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.ViewSplitPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ViewSplitPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOViewer2githubcomSplitFigosplitfigraphqlmodelViewer(ctx context.Context, sel ast.SelectionSet, v *model.Viewer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Viewer(ctx, sel, v)
}

func (ec *executionContext) marshalOViewerOrError2githubcomSplitFigosplitfigraphqlmodelViewerOrError(ctx context.Context, sel ast.SelectionSet, v model.ViewerOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ViewerOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOViewerSplit2githubcomSplitFigosplitfigraphqlmodelViewerSplit(ctx context.Context, sel ast.SelectionSet, v []*model.ViewerSplit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOViewerSplit2githubcomSplitFigosplitfigraphqlmodelViewerSplit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOViewerSplit2githubcomSplitFigosplitfigraphqlmodelViewerSplit(ctx context.Context, sel ast.SelectionSet, v *model.ViewerSplit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ViewerSplit(ctx, sel, v)
}

func (ec *executionContext) marshalOViewerSplitByIdPayloadOrError2githubcomSplitFigosplitfigraphqlmodelViewerSplitByIDPayloadOrError(ctx context.Context, sel ast.SelectionSet, v model.ViewerSplitByIDPayloadOrError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ViewerSplitByIdPayloadOrError(ctx, sel, v)
}

func (ec *executionContext) marshalOWallet2githubcomSplitFigosplitfigraphqlmodelWallet(ctx context.Context, sel ast.SelectionSet, v []*model.Wallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWallet2githubcomSplitFigosplitfigraphqlmodelWallet(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOWallet2githubcomSplitFigosplitfigraphqlmodelWallet(ctx context.Context, sel ast.SelectionSet, v *model.Wallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Wallet(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWalletType2githubcomSplitFigosplitfiservicepersistWalletType(ctx context.Context, v interface{}) (*persist.WalletType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(persist.WalletType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWalletType2githubcomSplitFigosplitfiservicepersistWalletType(ctx context.Context, sel ast.SelectionSet, v *persist.WalletType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
